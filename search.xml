<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis 使用详解]]></title>
    <url>%2F2018%2F09%2F17%2FMybatis-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MyBatis 本是apache的一个开源项目iBatis 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 官方地址 简介使用123456789101112131415161718192021&lt;!--全局配置文件 mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;!-- 对应配置文件路径 * --&gt;&lt;/mappers&gt; &lt;/configuration&gt; 12345678910&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 对应接口全类名位置 ## --&gt; &lt;!-- 对应接口方法 ### --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; 12345//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlog(Integer id);&#125; Mybatis底层与数据库交互是使用SqlSession完成的，SqlSession非线程安全，每次使用应当获取新对象，mapper接口的实现由mybatis生成一个代理对象。 123456789public void test()&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();SqlSession session = sqlSessionFactory.openSession(); try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(1); &#125; finally &#123; session.close(); &#125; &#125; 全局配置文件properties标签1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;properties resource="db.properties" url="网络路径/本地路径"&gt;&lt;/properties&gt; &lt;!--resource:类路径 url：网络路径/本地路径 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 12345#db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mydql://localhost:3306/dbjdbc.username=usernamejdbc.password=password settings标签12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCaseEnables " value="true" /&gt; &lt;!-- 驼峰命名适配 --&gt; &lt;setting name="jdbcTypeForNull" value="null"/&gt; &lt;!-- 空值映射为null --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 懒加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;!-- 按需加载 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!--开启二级缓存 --&gt; &lt;/settings&gt;&lt;/configuration&gt; typeAliases标签12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="org.mybatis.example.bean.Blog" alias="blog"&gt;&lt;/typeAlias&gt; &lt;!-- mapper中就不用写全类名了，不写alias即默认为类名--&gt; &lt;package name="org.mybatis.example.bean"/&gt; &lt;!--当前包及其子包自动别名--&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 123456&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- blog 别名使用--&gt; &lt;select id="selectBlog" resultType="blog"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; 1234567//通过@Alias注解使用别名//批量扫描注解优先@Alias("blog")public class Blog&#123; private Integer id; ...&#125; Alias(默认别名) Mapped Type _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map plugins插件在四大对象执行前后进行拦截，原理为动态代理。 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments标签123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;!--指定默认使用环境来快速切换环境--&gt; &lt;environment id="env"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 事务管理器 type: JDBC|MANAGED 自定义 --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 数据源配置 type：UNPOOLED|POOLED|JNDI 自定义--&gt; &lt;property name="driver" value="$&#123;oracle.driver&#125;"/&gt; &lt;property name="url" value="$&#123;oracle.url&#125;"/&gt; &lt;property name="username" value="$&#123;oracle.username&#125;"/&gt; &lt;property name="password" value="$&#123;oracle.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; databaseIdProvider标签12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="env"&gt; &lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt;&lt;/configuration&gt; 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 发送带oracle的查询语句 --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" databsesId="oracle"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" databsesId="mysql"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; mapper标签12345678910111213141516&lt;!--全局配置文件 mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;mappers&gt; &lt;mapper url=""&gt;&lt;/mapper&gt; &lt;!-- 磁盘路径 --&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;!-- 类路径 --&gt; &lt;mapper class="org.mybatis.example.dao.BlogMapperAnnotation"/&gt; &lt;!--1. mapper和接口 同名同路径--&gt; &lt;!--2. 添加注解方法的接口--&gt; &lt;package name="org.mybatis.example.dao"/&gt; &lt;!-- 批量扫描 xml 接口 同包 --&gt; &lt;/mappers&gt; &lt;/configuration&gt; 123456//org.mybatis.example.dao.BlogMapperAnnotationpublic interface BlogMapperAnnotation&#123; // 对应mapper中方法 ### @Select("select * from Blog where id = #&#123;id&#125;") public Blog selectBlog(Integer id);&#125; 映射文件CRUD123456789//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlog(Integer id); public boolean insertdBlog(Blog blog); public Integer updateBlog(Blog blog); public boolean deleteBlog(Integer id); //自动返回 Integer 、Long、Boolean 类型&#125; 12345678910111213141516171819202122&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog set ... 字段 = #&#123;属性名&#125; where 字段 = #&#123;属性名&#125; &lt;/update&gt; &lt;delete id="deleteBlog"&gt; delete from Blog where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 自增主键123456789101112131415161718192021222324252627282930313233&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- mysql 等支持 自增主键 数据库--&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" useGeneratedKeys="true" keyProperty="#&#123;id&#125;" databaseId="mysql"&gt; &lt;!-- 使用自增主键策略 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;!-- Oracle 从序列中获取 111--&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" databaseId="oracle"&gt; &lt;selectKey KeyProperty="#&#123;id&#125;" order="BEFORE" resultTyoe"Integer"&gt; &lt;!-- 使用查询序列 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; select Blog_sql.nextval from dual &lt;/selectKey&gt; insert into Blog...values(#&#123;id&#125;,#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;!-- Oracle 从序列中获取 222 多条问题 --&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" databaseId="oracle"&gt; &lt;selectKey KeyProperty="#&#123;id&#125;" order="AFTER" resultTyoe"Integer"&gt; &lt;!-- 使用查询序列 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; select Blog_sql.currval from dual &lt;/selectKey&gt; insert into Blog...values(Blog_sql.nextval,#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;/mapper&gt; 参数处理多参数时，参数会封装成map，可以使用注解指定参数的关键字(key)。 123456789101112131415//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlogById(Integer id); public Blog selectBlogByIdAndName(@Param("id")Integer id,@Param("name")String name); public Blog selectBlogByPojo(Blog blog); public Blog selectBlogByMap(Map&lt;String,Object&gt; map); public Blog selectBlogByCollection(List&lt;Integer&gt; list);&#125;Page&#123; int index； int size; List&lt;Blog&gt; list;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 单个参数 --&gt; &lt;!-- 当只有单个参数时，不会有任何处理 #&#123;任意填写&#125; 都可以取出参数--&gt; &lt;select id="selectBlogById" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 多个参数 --&gt; &lt;!-- 未指定参数名 --&gt; &lt;!-- 使用多个参数时，入参会被处理，参数会被封装为一个map--&gt; &lt;!-- 取值所用的key为 [ param1 ... paramN 0... n ]--&gt; &lt;select id="selectBlogByIdAndName" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;param1&#125; and name = #&#123;param2&#125; &lt;/select&gt; &lt;!-- 使用@Param（""） 注解指明接口中的参数后可以直接取用--&gt; &lt;!-- 原取参数规则仍旧适用 --&gt; &lt;select id="selectBlogByIdAndName" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入pojo --&gt; &lt;!-- 直接取用即可 --&gt; &lt;!-- 多参数包含对象时 param2.id 或注解后 blog.id --&gt; &lt;select id="selectBlogByPojo" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入 map --&gt; &lt;!-- 直接取用 按照存入map时的key 即取用的 key 和 存入map时 key 相同 --&gt; &lt;select id="selectBlogByMap" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入集合类型 --&gt; &lt;!-- 取出第一个参数 集合类型取参数使用 collection[0] 数组类型取参数使用 list[0] --&gt; &lt;select id="selectBlogByMap" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;list[0]&#125; &lt;/select&gt; &lt;/mapper&gt; $与#区别1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = $&#123;name&#125;&lt;/select&gt; &lt;!-- 执行Sql：select * from Blog where id = ? and name = blog_01 --&gt; &lt;!-- #&#123;&#125; 采用预编译形式 可以防止sql注入发生 $&#123;&#125; 采用字符串拼串方式 可能被注入 --&gt; select * from $&#123;year&#125;_Blog where id =#&#123;id&#125; //分表 select * from Blog order by $&#123;name&#125; $&#123;order&#125; where id = #&#123;id&#125; //排序&lt;/mapper&gt; #{} 取值时可以对参数进行限定javaType、jdbcType、mode、numbericScale、resultMap、typeHandler、jdbcTypeName 12345&lt;!-- 部分数据库在字段为null 可能无法识别mybatis传入的null值 --&gt;&lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog values(#&#123;id&#125;，#&#123;name,jdbcType=Null&#125;) &lt;!-- name 为空 Oracle 数据库正常 默认映射为 jdbcType.OTHER --&gt;&lt;/insert&gt; 返回值处理123456public interface BlogMapper&#123; public List&lt;Blog&gt; selectBlogByName(String name); public Map&lt;Stirng,Object&gt; selectBlogMap(Integer id); @MapKey("id") public Map&lt;Stirng,Blog&gt; selectBlogMaps(String name);&#125; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlogByName" resultType="org.mybatis.example.bean.Blog"&gt; &lt;!-- 返回为列表 返回类型为集合元素类型 Blog--&gt; select * from Blog where name like #&#123;name&#125; &lt;/select&gt; &lt;select id="selectBlogMap" resultType="map"&gt; &lt;!-- 返回值为map 返回类型为 map --&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectBlogByName" resultType="org.mybatis.example.bean.Blog"&gt; &lt;!-- 返回为map&lt;String,Blog&gt; 返回类型为集合元素类型 Blog--&gt; &lt;!-- 接口使用注解修饰 @MapKey("id") 标注map的key使用哪个字段 --&gt; select * from Blog where name like #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; resultMap自定义结果集 12345678910111213141516&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--自定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result colume="regist_time" property="reistTime"/&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 级联查询 1234567891011121314151617&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--级联查 属性 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="group_id" property="group.id"&gt; &lt;result column="group_name" property="group.name"&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog b,Group g where b.id = g.id and b.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; association12345678910111213141516171819&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--级联查 联合 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;association property="org.mybatis.example.bean.Group"&gt; &lt;id column "group_id" property="id"/&gt; &lt;result column="group_name" property="name"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select (distinct)* from Blog b,Group g where b.id = g.id and b.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 分步查询 12345678910111213141516171819&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 联合 分步查询 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;association property="group" select="org.mybatis.example.dao.GroupMapper.getGroupById" column="group_id"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog &lt;/select&gt; &lt;/mapper&gt; 懒加载 12345&lt;!-- 分步查询的条件下 在全局配置文件中开启懒加载 按需加载等功能 即可--&gt;&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;!-- 懒加载 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;!-- 按需加载 --&gt; collection1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.GroupMapper"&gt; &lt;resultMap type="org.mybatis.example.bean.Group" id="CustomizeGroup"&gt; &lt;id column="group_id" property="id"/&gt; &lt;result column="group_name" property="name"/&gt; &lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 一个组中包含多个Blog --&gt; &lt;select id="selectBlog" resultMap="CustomizeGroup"&gt; select * from Group g left join Blog b on g.id = b.id where g.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 分步查询 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.GroupMapper"&gt; &lt;resultMap type="org.mybatis.example.bean.Group" id="CustomizeGroup"&gt; &lt;id column="group_id" property="id"/&gt; &lt;result column="group_name" property="name"/&gt; &lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog" select="org.mybatis.example.dao.GroupMapper.selectBlogByGroupId" column="id"&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 一个组中包含多个Blog --&gt; &lt;select id="selectBlog" resultMap="CustomizeGroup"&gt; select * from Group &lt;/select&gt; &lt;/mapper&gt; 懒加载 123456&lt;!-- 同上一个示例 --&gt;&lt;!-- 分步查询的条件下 在全局配置文件中开启懒加载 按需加载等功能 即可--&gt;&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;!-- 懒加载 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;!-- 按需加载 --&gt; 传递多参 手动懒加载 12345&lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog" select="org.mybatis.example.dao.GroupMapper.selectBlogByGroupId" column="&#123;group_id = id&#125;" fetchType="lazy"&gt; &lt;!-- column="&#123;key1=column1,key2=column2&#125; fetchType="lazy|eager"--&gt;&lt;/collection&gt; discriminator1234567891011121314151617181920212223242526272829&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 联合 分步查询 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;discriminator javaType="sex" column="string"&gt; &lt;case value="0" resultType=""&gt; &lt;association property="group" select="org.mybatis.example.dao.GroupMapper.getGroupById" column="group_id"&gt; &lt;/association&gt; &lt;/case&gt; &lt;case value="1" resultType="org.mybatis.example.bean.Blog"&gt; &lt;result column="sex" property="name"/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog &lt;/select&gt; &lt;/mapper&gt; 动态SQLIF标签1234567public class User&#123; private int id; private String name; private String sex; private String email; private Dept dept;&#125; 123public class UserMapper&#123; public List&lt;User&gt; getUsersbyIf(User user);&#125; 1234567891011121314&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user where&lt;!-- 1=1 --&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125;&lt;!-- and id=#&#123;id&#125; --&gt; &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;/select&gt; &lt;/mapper&gt;&lt;!-- 当没有id时 sql语句会出现问题 --&gt; WHERE标签12345678910111213141516&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;where&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;!-- id=#&#123;id&#125; and --&gt; &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; and sex=#&#123;sex&#125; &lt;!-- id=#&#123;id&#125; and--&gt; &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; and email=#&#123;email&#125; &lt;!-- email=#&#123;email&#125; --&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; &lt;!-- and后置不好使 --&gt; TRIM标签123456789101112131415&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;trim prefix="where" prefixOverrides="xxx" suffix="" suffixOverrides="and"&gt; &lt;!-- 添加 where 前缀 覆盖xxx 添加后缀 覆盖and --&gt; &lt;if test="id!=null"&gt; xxx id=#&#123;id&#125; and &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; sex=#&#123;sex&#125; and &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; email=#&#123;email&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; CHOOSE标签12345678910111213&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;where&gt; &lt;choose&gt; &lt;when test="id!=null"&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;when test="sex!=null"&gt;sex=#&#123;sex&#125;&lt;/when&gt; &lt;when test"emall!=null and emall!=''"&gt; email=#&#123;email&#125;&lt;/when&gt; &lt;otherwith&gt;1 = 1&lt;/otherwith&gt; &lt;/choose&gt; &lt;!-- 只会进入第一个配置成功的条件 如传入id和sex 只会查询 id --&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; SET标签12345678910&lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog &lt;set&gt; &lt;if test="属性！=null and 属性！='' "&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;/set&gt;&lt;!-- 作用就是可以在插入的时候正确去掉最后一个逗号 --&gt; where 字段 = #&#123;属性名&#125;&lt;/update&gt; FOREACH标签12345678&lt;!-- 传入一个包含多个id的List --&gt;&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user where id in( &lt;foreach collection="users_id" item="user_id" separator="," open"(" close=")"&gt; &lt;!--还可以添加index属性 遍历List时 index为索引 遍历map时index为键值--&gt; #&#123;user_id&#125; &lt;/foreach&gt;&lt;/select&gt; Bind标签123456&lt;!-- 例如：模糊查询拼串 --&gt;&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; &lt;bind name="_name" value="'%'+name+'%'"&gt; select * from user where name like #&#123;_name&#125; &lt;!-- 不安全 select * from user where name like '%$&#123;name&#125;%' --&gt;&lt;/select&gt; 内置参数_parameter 单个参数：_parameter为这个参数多个参数：_parameter为封装map _databaseId 当全局配置中配置了DatabaseIdProvider标签时，_databaseId代表当前数据库的别名。 1public List&lt;User&gt; getUser(User user); 12345678910111213141516&lt;select id="getUser" resultMap="com.wang.test.bean.User"&gt; &lt;if test="_databaseId=='oracle' "&gt; select * from oracle_user &lt;if test="_parameter!=null"&gt; where sex = #&#123;_parameter.sex&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test="_databaseId=='mysql'"&gt; select * from user &lt;if test="_parameter!=null"&gt; where sex = #&#123;_parameter.sex&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; SQL标签123456789&lt;!-- 抽取常用的相同的sql片段，使用时引入即可 --&gt;&lt;sql id="insColm"&gt; id,name,sex,dept_id&lt;/sql&gt;&lt;insert&gt; insert into user( &lt;include refid="insColm"/&gt;) values ...&lt;/insert&gt; 批量保存Mysql 批量方式一 1public void saveUsers(@Param("users")List&lt;User&gt;); 123456789&lt;!-- 批量保存 --&gt;&lt;!-- Mysql 方式 --&gt;&lt;!-- insert into user values (),(),() --&gt;&lt;insert id="saveUsers"&gt; insert into user values &lt;foreach collection="users" item="user" separator=","&gt; (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方式二 1234567&lt;insert id="saveUsers"&gt;&lt;!-- insert into user values ();insert into user values ();insert into user values (); --&gt; &lt;foreach collection="users" item="user" separator=";"&gt; insert into user values (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; &lt;!-- 开启数据库的连接属性 jdbc:mysql//lo....?allowMultiQueries=true--&gt; Oracle 批量保存方式一 1234567891011121314&lt;!-- 批量保存 --&gt;&lt;!-- Oracle 方式 --&gt;&lt;!-- 代码块 begin insert into user values (),(),()； insert into user values (),(),()； insert into user values (),(),()； end； --&gt;&lt;insert id="saveUsers" databaseId="oracle"&gt; &lt;foreach collection="users" item="user" separator=";" open="begin" close="end;"&gt; insert into user values (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方式二 12345678910111213141516171819&lt;!-- 批量保存 --&gt;&lt;!-- Oracle 方式 --&gt;&lt;!-- 中间表方式 insert into user(id,name,email,dept_id) select user_seq.nextval,name,email,dept_id from( select 'value1' name,'value2' email,'value3' dept_id from dual union select 'value1' name,'value2' email,'value3' dept_id from dual union select 'value1' name,'value2' email,'value3' dept_id from dual ) --&gt;&lt;insert id="saveUsers" databaseId="oracle"&gt; insert into user(id,name,email,dept_id) select user_seq.nextval,name,email,dept_id from &lt;foreach collection="users" item="user" separator="union" open="(" close=")" &gt; select #&#123;user.id&#125; name,#&#123;user.email&#125; email,#&#123;user.dept.id&#125; dept_id from dual &lt;/foreach&gt;&lt;/insert&gt; 缓存一级缓存默认只开启一级缓存，一级缓存时SqlSession级别的缓存，这也就是说处在数据库相同会话中的操作，数据会被缓存，查询可以取到缓存值，减少查询次数。当然缓存会有他的存在时间和区域。缓存失效情况： 不同的SqlSession对象 相同SqlSession查询条件不同 相同SqlSession查询间隔数据操作 相同SqlSession查询前清空缓存 二级缓存全局缓存，基于命名空间级别的缓存，一个命名空间对应一个二级缓存。当会话关闭时，一级缓存中的数据会被保存到二级缓存中。12345678#redis.propertiesredis.host=127.0.0.1redis.port=6379redis.pass=123456redis.maxIdle=200redis.maxActive=1024redis.maxWait=10000redis.testOnBorrow=true 12345678910111213141516171819202122232425262728293031&lt;!-- applicationContext-redis.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd "&gt;&lt;!-- 连接池基本参数配置，类似数据库连接池 --&gt; &lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true"/&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;redis.maxActive&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;"/&gt; &lt;/bean&gt; &lt;!-- 连接池配置，类似数据库连接池 --&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="hostName" value="$&#123;redis.host&#125;"&gt;&lt;/property&gt; &lt;property name="port" value="$&#123;redis.port&#125;"&gt;&lt;/property&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.pass&#125;"&gt;&lt;/property&gt; --&gt; &lt;property name="poolConfig" ref="poolConfig"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="redisCacheTransfer" class="cn.qlq.jedis.RedisCacheTransfer"&gt; &lt;property name="jedisConnectionFactory" ref="jedisConnectionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class RedisCache implements Cache &#123; // 初始化Jedis private Jedis jedis = new Jedis("127.0.0.1", 6379); private String cacheId; /* * MyBatis会把映射文件的命名空间作为 * 唯一标识cacheId，标识这个缓存策略属于哪个namespace * 这里定义好，并提供一个构造器，初始化这个cacheId即可 */ public RedisCache (String cacheId)&#123; this.cacheId = cacheId; &#125; /** * 清空缓存 */ @Override public void clear() &#123; // 但这方法不建议实现 &#125; @Override public String getId() &#123; return cacheId; &#125; /** * MyBatis会自动调用这个方法检测缓存 * 中是否存在该对象。既然是自己实现的缓存 * ，那么当然是到Redis中找了。 */ @Override public Object getObject(Object arg0) &#123; // arg0 在这里是键 try &#123; byte [] bt = jedis.get(SerializableTools.ObjToByteArray(arg0)); if (bt == null) &#123; // 如果没有这个对象，直接返回null return null; &#125; return SerializableTools.byteArrayToObj(bt); &#125; catch (Exception e) &#123;e.printStackTrace();&#125; return null; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return new ReentrantReadWriteLock(); &#125; @Override public int getSize() &#123; return Integer.parseInt(Long.toString(jedis.dbSize())); &#125; /** * MyBatis在读取数据时，会自动调用此方法 * 将数据设置到缓存中。这里就写入Redis */ @Override public void putObject(Object arg0, Object arg1) &#123; /* * arg0是key , arg1是值 * MyBatis会把查询条件当做键，查询结果当做值。 */ try &#123; jedis.set(SerializableTools.ObjToByteArray(arg0), SerializableTools.ObjToByteArray(arg1)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * MyBatis缓存策略会自动检测内存的大小，由此 * 决定是否删除缓存中的某些数据 */ @Override public Object removeObject(Object arg0) &#123; Object object = getObject(arg0); try &#123; jedis.del(SerializableTools.ObjToByteArray(arg0)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class SerializableTools &#123; /** * 反序列化 * * @param bt * @return * @throws IOException * @throws Exception */ public static Object byteArrayToObj(byte[] bt) throws Exception &#123; ByteArrayInputStream bais = new ByteArrayInputStream(bt); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; /** * 对象序列化 * * @param obj * @return * @throws IOException */ public static byte[] ObjToByteArray(Object obj) throws IOException &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(obj); return bos.toByteArray(); &#125;&#125; 整合Redis，配置好Redis与Spring的集成后，重写Cache接口，在mapper的缓存标签中使用自定义的实现即可，即在type中写自己的实现，在Springboot中整合更容易，使用系统提供的注解并重写缓存序列化方法即可。 12345678910111213141516&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024" type="自定义缓存实现"&gt; &lt;!-- 对应接口方法 ### --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" useCache="true"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 增删改默认缓存清空--&gt; &lt;insert flushCache="true" /&gt;&lt;/mapper&gt;&lt;!-- 全局配置开启 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt; eviction:缓存回收策略 LRU(默认) 最近最少使用的将缓存，移除长时间不使用的对象 FIFO 先进先出，按照队列方式处理缓存 SOFT 软引用，基于垃圾回收器状态和软引用规则来移除对象缓存 WEAK 弱引用，积极移除基于垃圾收集器状态和弱引用规则的对象缓存 flushInterval: 缓存刷新间隔 默认不清空缓存，单位为毫秒。 readOnly 读写性，为真只读，直接传递引用，为假可改，使用序列化反序列化，默认为假，POJO对象必须实现序列化接口。 size 缓存存放元素个数 type 指定自定义缓存的全类名，当引入第三方缓存框架时，通过实现提供的接口，即可接管缓存工作。 框架整合123456&lt;!-- mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 进行一些个性化配置 --&gt;&lt;/configuration&gt; 1234567891011121314151617181920212223&lt;!-- mapper 存放位置无要求 --&gt;&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog set ... 字段 = #&#123;属性名&#125; where 字段 = #&#123;属性名&#125; &lt;/update&gt; &lt;delete id="deleteBlog"&gt; delete from Blog where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- applicationContext.xml --&gt;&lt;beans ...&gt; &lt;context:component-scan base-package="org.mybatis.example" use-default-filters="false"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!--数据源 --&gt; &lt;context:property-placeholder location="classpath:db.properties"&gt; &lt;bean id="datasource" class="com....."&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt; &lt;property name="..." value=""&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注解事务 声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="datasource"&gt;&lt;/property&gt; &lt;!-- 配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt; &lt;!-- 别名 --&gt; &lt;property name="typeAliasesPackage" value="org.mybatis.example.bean"&gt;&lt;/property&gt; &lt;!-- sql映射文件路径 --&gt; &lt;property name="mapperLocations" value="classpath*:mybatis/mapper/*Mapper.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mybatis-spring:scan base-package="org.mybatis.example.dao"&gt; &lt;/beans&gt; 12345678910111213141516&lt;!-- spring-servlet.xml--&gt;...&lt;beans ...&gt; &lt;!-- 只扫描Controller --&gt; &lt;context:component-scan base-package="org.mybatis.example" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.Controller"/&gt; &lt;/context:component-scan&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt; &lt;/beans&gt; 逆向工程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- generator.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime="MyBatis3Simple":生成简单版的CRUD MyBatis3:豪华版 --&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage="test.model"：目标包名 targetProject="\MBGTestProject\src"：目标工程 --&gt; &lt;javaModelGenerator targetPackage="com.test.mybatis.bean" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：sql映射生成策略： --&gt; &lt;sqlMapGenerator targetPackage="com.test.mybatis.dao" targetProject=".\conf"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.test.mybatis.dao" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt; &lt;table tableName="tbl_dept" domainObjectName="Department"&gt;&lt;/table&gt; &lt;table tableName="tbl_employee" domainObjectName="Employee"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 1234567891011public void testMbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("generator.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 存储过程1234567public class Page&#123; private int start; private int end; private int count; private List&lt;User&gt; users; ...&#125; 1234567create or replace procedure page_select(p_start in int,p_end in int,p_count out int,p_emps out sys_refcursor)begin select count(*) into p_count from user; open p_emps for select * from (select rownnum rn,e.* from user where rownum &lt;= p_end) where rn&gt;p_start;end 1public void pageSelect(Page page); 123456&lt;resultMap type="org.mybatis.example.bean.User" id="PageUser"&gt; ...&lt;/resultMap&gt;&lt;select id="pageSelect" resultType="org.mybatis.example.bean.Page" statementType="CALLABLE"&gt; &#123;call page_select(#&#123;start,mode=IN,jdbcType=INTEGER&#125;,#&#123;end,mode=IN,jdbcType=INTETER&#125;,#&#123;count,mode=OUT,jdbcType=INTEGER&#125;,#&#123;emps,mode=OUT,jdbcType=CURSOR,javaType=ResultSet,resultMap=PageUser&#125;)&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>XMl配置</tag>
        <tag>整合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 使用方法]]></title>
    <url>%2F2018%2F09%2F17%2FSpring-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。轻量级非入侵式框架，简化企业级应用开发，IOC(DI)、AOP容器框架。 使用方法 1234567891011121314151617&lt;!-- server.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 12345678910111213141516171819&lt;!-- dao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; 12345678/ create and configure beansApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");// retrieve configured instancePetStoreService service = context.getBean("petStore", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); Bean概述Spring 的Loc容器管理一个或多个bean，这些bean使用容器给定的配置，在容器中，这些bean会被定义为BeanDefinition对象将包含： Bean实现的类全类名 Bean的行为元素，作用域，生命周期回调等 引用bean执行其工作所需的其他bean，这些引用也称为协作者或依赖关系。 在新创建的对象中要设置的其他配置设置，例如，管理连接池的bean中要使用的连接数，或池的大小限制。 Bean定义属性 Property Explained in… class Instantiating beans name Naming beans scope Bean scopes constructor arguments Dependency Injection properties Dependency Injection autowiring mode Autowiring collaborators lazy-initialization mode Lazy-initialized beans initialization method Initialization callbacks destruction method Destruction callbacks 构造实例化123&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt; 静态工厂实例化123&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 工厂实例化123456789&lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 12345678public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂多个工厂方法 1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 依赖注入依赖注入(Dependency injection)是一个对象定义其依赖关系的过程，也就是说，与之协作的其他对象，如通过构造参数、工厂参数、属性等，将在本对象构造后或从工厂方法返回后进行注入。这个过程从根本上说就是bean本身的逆过程，bean本身通过类的构造或服务定位控制其他依赖对象的实例化或位置。 构造器注入下面的例子说明，通过构造器注入了一个依赖，这个依赖中的逻辑部分被注入方式隐藏，即这个只需注入依赖即可完成对应功能实现。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; xml编写方式 构造器注入的参数是已知类型的bean时，在构造参数上不需要指定参数的类型，直接进行引用即可。 12345678package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ...两个构造参数 &#125;&#125; 123456789101112&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;!-- 声明这个bean --&gt; &lt;!-- --&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 当注入的参数是简单类型，即无法确定类型的时候，可以进行类型指定或者参数的索引位置指定或参数名称指定。 123456789101112131415package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg name="years" value="7500000"/&gt; &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;&lt;/bean&gt; 属性注入下面示例中，依赖使用了一个属性，而这个属性的注入方式是使用的类中的set方法完成的。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on the MovieFinder private MovieFinder movieFinder; // a setter method so that the Spring container can inject a MovieFinder public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 属性注入示例,可以书写引用属性也可以使用字引用标签的方式。 12345678910111213&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- setter injection using the nested ref element --&gt; &lt;property name="beanOne"&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/property&gt; &lt;!-- setter injection using the neater ref attribute --&gt; &lt;property name="beanTwo" ref="yetAnotherBean"/&gt; &lt;property name="integerProperty" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 1234567891011121314151617181920public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) &#123; this.beanOne = beanOne; &#125; public void setBeanTwo(YetAnotherBean beanTwo) &#123; this.beanTwo = beanTwo; &#125; public void setIntegerProperty(int i) &#123; this.i = i; &#125;&#125; 此示例使用构造器方式实现上面的属性注入方式，用于对比两种注入方式。 123456789101112131415public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public ExampleBean( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123; this.beanOne = anotherBean; this.beanTwo = yetAnotherBean; this.i = i; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- constructor injection using the nested ref element --&gt; &lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/constructor-arg&gt; &lt;!-- constructor injection using the neater ref attribute --&gt; &lt;constructor-arg ref="yetAnotherBean"/&gt; &lt;constructor-arg type="int" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 详细依赖及配置直接给定值直接给定的如初始值、字符串等。 1234567891011121314151617181920212223&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="masterkaoli"/&gt;&lt;/bean&gt;&lt;!-- 还可以引入P命名空间来简化&lt;property&gt;标签的编写 这有那么一点点秀 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="masterkaoli"/&gt;&lt;/beans&gt; 引用其他在需要注入的位置直接添加引用属性或引用标签既可以 123456&lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;&lt;!-- constructor injection using the neater ref attribute --&gt;&lt;constructor-arg ref="yetAnotherBean"/&gt; 父子容器，用子容器中的bean代理父容器中的bean 12345678910111213&lt;!-- in the parent context --&gt;&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt; &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;&lt;!-- in the child (descendant) context --&gt;&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt; class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt; &lt;/property&gt; &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt; 内部创建可以在bean的property标签内继续创建新的bean，内部bean可以没有id属性 123456789&lt;bean id="outer" class="..."&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 集合类型赋值12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 属性值合并为集合 12345678910111213141516171819&lt;beans&gt; &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="child" parent="parent"&gt; &lt;property name="adminEmails"&gt; &lt;!-- the merge is specified on the child collection definition --&gt; &lt;props merge="true"&gt;&lt;!-- 这里将会合并 例如 setAdminEmils 传入一个map --&gt; &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;beans&gt; 强类型集合，当集合中的数据需要进行类型转换时，spring将自动完成类型转换工作 12345678public class Foo &#123; private Map&lt;String, Float&gt; accounts; public void setAccounts(Map&lt;String, Float&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 1234567891011&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="accounts"&gt; &lt;map&gt; &lt;entry key="one" value="9.99"/&gt; &lt;entry key="two" value="2.75"/&gt; &lt;entry key="six" value="3.99"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 空值规定空参数视为空字符串，null标签处理null值 123456789&lt;bean class="ExampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt;&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; C&amp;P属性标签12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt; &lt;!-- traditional declaration --&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;constructor-arg value="foo@bar.com"/&gt; &lt;property name="email" value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;!-- c-namespace declaration --&gt; &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com" p:email="foo@bar.com"/&gt;&lt;/beans&gt; 提前加载意思就是说，我这个bean在实例化前，你还得给我准备好我依赖的bean 12&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;&lt;bean id="manager" class="ManagerBean" /&gt; 懒加载1234567&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true"/&gt;&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;&lt;!-- 容器级别的懒加载 --&gt;&lt;beans default-lazy-init="true"&gt; &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt; ###方法注入 查找方式，使用cglib动态代理方式，生成代理子类 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager &#123; public Object process(Object commandState) &#123; // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); &#125; // okay... but where is the implementation of this method? protected abstract Command createCommand();&#125; 12345678910&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt; &lt;lookup-method name="createCommand" bean="myCommand"/&gt; &lt;!-- 还可以使用@Lookup（"myCommand"） 注解标注上面类中的方法 --&gt;&lt;/bean&gt; 任意方法替换方式 123456789101112131415161718192021public class MyValueCalculator &#123; public String computeValue(String input) &#123; // some real code... &#125; // some other methods...&#125;/** * meant to be used to override the existing computeValue(String) * implementation in MyValueCalculator */public class ReplacementComputeValue implements MethodReplacer &#123; public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123; // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; &#125;&#125; 12345678&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt; &lt;!-- arbitrary method replacement --&gt; &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt; 作用域 模式 描述 singleton 单例模式 prototype 原型模式、多例模式 request 每一个http请求都会创建一个单例的bean，仅web应用 session 在session的生命周期中存在，仅web应用 application ServletContext生命周期中存在，仅web应用 websocket WebSocket生命周期存在，仅web应用 单例模式 原型模式]]></content>
      <categories>
        <category>Spring 教程</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
</search>
