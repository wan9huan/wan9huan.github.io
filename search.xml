<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring 使用方法]]></title>
    <url>%2F2018%2F09%2F17%2FSpring-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。轻量级非入侵式框架，简化企业级应用开发，IOC(DI)、AOPring容器框架。 使用方法 1234567891011121314151617&lt;!-- server.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 12345678910111213141516171819&lt;!-- dao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; 12345678/ create and configure beansApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");// retrieve configured instancePetStoreService service = context.getBean("petStore", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); Bean概述Spring 的Loc容器管理一个或多个bean，这些bean使用容器给定的配置，在容器中，这些bean会被定义为BeanDefinition对象将包含： Bean实现的类全类名 Bean的行为元素，作用域，生命周期回调等 引用bean执行其工作所需的其他bean，这些引用也称为协作者或依赖关系。 在新创建的对象中要设置的其他配置设置，例如，管理连接池的bean中要使用的连接数，或池的大小限制。 Bean定义属性 Property Explained in… class Instantiating beans name Naming beans scope Bean scopes constructor arguments Dependency Injection properties Dependency Injection autowiring mode Autowiring collaborators lazy-initialization mode Lazy-initialized beans initialization method Initialization callbacks destruction method Destruction callbacks 构造实例化123&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt; 静态工厂实例化123&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 工厂实例化123456789&lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 12345678public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂多个工厂方法 1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 依赖注入依赖注入(Dependency injection)是一个对象定义其依赖关系的过程，也就是说，与之协作的其他对象，如通过构造参数、工厂参数、属性等，将在本对象构造后或从工厂方法返回后进行注入。这个过程从根本上说就是bean本身的逆过程，bean本身通过类的构造或服务定位控制其他依赖对象的实例化或位置。 构造器注入下面的例子说明，通过构造器注入了一个依赖，这个依赖中的逻辑部分被注入方式隐藏，即这个只需注入依赖即可完成对应功能实现。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; xml编写方式 构造器注入的参数是已知类型的bean时，在构造参数上不需要指定参数的类型，直接进行引用即可。 12345678package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ...两个构造参数 &#125;&#125; 123456789101112&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;!-- 声明这个bean --&gt; &lt;!-- --&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 当注入的参数是简单类型，即无法确定类型的时候，可以进行类型指定或者参数的索引位置指定或参数名称指定。 123456789101112131415package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg name="years" value="7500000"/&gt; &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;&lt;/bean&gt; 属性注入下面示例中，依赖使用了一个属性，而这个属性的注入方式是使用的类中的set方法完成的。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on the MovieFinder private MovieFinder movieFinder; // a setter method so that the Spring container can inject a MovieFinder public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 属性注入示例,可以书写引用属性也可以使用字引用标签的方式。 12345678910111213&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- setter injection using the nested ref element --&gt; &lt;property name="beanOne"&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/property&gt; &lt;!-- setter injection using the neater ref attribute --&gt; &lt;property name="beanTwo" ref="yetAnotherBean"/&gt; &lt;property name="integerProperty" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 1234567891011121314151617181920public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) &#123; this.beanOne = beanOne; &#125; public void setBeanTwo(YetAnotherBean beanTwo) &#123; this.beanTwo = beanTwo; &#125; public void setIntegerProperty(int i) &#123; this.i = i; &#125;&#125; 此示例使用构造器方式实现上面的属性注入方式，用于对比两种注入方式。 123456789101112131415public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public ExampleBean( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123; this.beanOne = anotherBean; this.beanTwo = yetAnotherBean; this.i = i; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- constructor injection using the nested ref element --&gt; &lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/constructor-arg&gt; &lt;!-- constructor injection using the neater ref attribute --&gt; &lt;constructor-arg ref="yetAnotherBean"/&gt; &lt;constructor-arg type="int" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 详细依赖及配置直接给定值直接给定的如初始值、字符串等。 1234567891011121314151617181920212223&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="masterkaoli"/&gt;&lt;/bean&gt;&lt;!-- 还可以引入P命名空间来简化&lt;property&gt;标签的编写 这有那么一点点秀 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="masterkaoli"/&gt;&lt;/beans&gt; 引用其他在需要注入的位置直接添加引用属性或引用标签既可以 123456&lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;&lt;!-- constructor injection using the neater ref attribute --&gt;&lt;constructor-arg ref="yetAnotherBean"/&gt; 父子容器，用子容器中的bean代理父容器中的bean 12345678910111213&lt;!-- in the parent context --&gt;&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt; &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;&lt;!-- in the child (descendant) context --&gt;&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt; class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt; &lt;/property&gt; &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt; 内部创建可以在bean的property标签内继续创建新的bean，内部bean可以没有id属性 123456789&lt;bean id="outer" class="..."&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 集合类型赋值12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 属性值合并为集合 12345678910111213141516171819&lt;beans&gt; &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="child" parent="parent"&gt; &lt;property name="adminEmails"&gt; &lt;!-- the merge is specified on the child collection definition --&gt; &lt;props merge="true"&gt;&lt;!-- 这里将会合并 例如 setAdminEmils 传入一个map --&gt; &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;beans&gt; 强类型集合，当集合中的数据需要进行类型转换时，spring将自动完成类型转换工作 12345678public class Foo &#123; private Map&lt;String, Float&gt; accounts; public void setAccounts(Map&lt;String, Float&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 1234567891011&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="accounts"&gt; &lt;map&gt; &lt;entry key="one" value="9.99"/&gt; &lt;entry key="two" value="2.75"/&gt; &lt;entry key="six" value="3.99"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 空值规定空参数视为空字符串，null标签处理null值 123456789&lt;bean class="ExampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt;&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; C&amp;P属性标签12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt; &lt;!-- traditional declaration --&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;constructor-arg value="foo@bar.com"/&gt; &lt;property name="email" value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;!-- c-namespace declaration --&gt; &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com" p:email="foo@bar.com"/&gt;&lt;/beans&gt; 提前加载意思就是说，我这个bean在实例化前，你还得给我准备好我依赖的bean 12&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;&lt;bean id="manager" class="ManagerBean" /&gt; 懒加载1234567&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true"/&gt;&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;&lt;!-- 容器级别的懒加载 --&gt;&lt;beans default-lazy-init="true"&gt; &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt; ###方法注入 查找方式，使用cglib动态代理方式，生成代理子类 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager &#123; public Object process(Object commandState) &#123; // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); &#125; // okay... but where is the implementation of this method? protected abstract Command createCommand();&#125; 12345678910&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt; &lt;lookup-method name="createCommand" bean="myCommand"/&gt; &lt;!-- 还可以使用@Lookup（"myCommand"） 注解标注上面类中的方法 --&gt;&lt;/bean&gt; 任意方法替换方式 123456789101112131415161718192021public class MyValueCalculator &#123; public String computeValue(String input) &#123; // some real code... &#125; // some other methods...&#125;/** * meant to be used to override the existing computeValue(String) * implementation in MyValueCalculator */public class ReplacementComputeValue implements MethodReplacer &#123; public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123; // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; &#125;&#125; 12345678&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt; &lt;!-- arbitrary method replacement --&gt; &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt; 作用域 模式 描述 singleton 单例模式 prototype 原型模式、多例模式 request 每一个http请求都会创建一个单例的bean，仅web应用 session 在session的生命周期中存在，仅web应用 application ServletContext生命周期中存在，仅web应用 websocket WebSocket生命周期存在，仅web应用 单例模式 原型模式]]></content>
      <categories>
        <category>Spring 教程</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
</search>
