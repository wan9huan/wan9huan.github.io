<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE-Chapter-3]]></title>
    <url>%2F2019%2F04%2F18%2FJavaSE-Chapter3%2F</url>
    <content type="text"><![CDATA[面向对象更加强调运用人类在日常的是为逻辑中采用的思想方法与原则 抽象、分类、继承、聚合、多态 第三章 初入Java面向对象的世界 面向对象 面向对象更加强调运用人类在日常的是为逻辑中采用的思想方法与原则 抽象、分类、继承、聚合、多态 面向对象与面向过程​ 面向过程：强调的是功能行为 ​ 面向过程：将功能封装进对象，强调具备了功能的对象 面向对象三大特征​ 封装、继承、多态 OOP思想概述 类 ：对现实世界事物的抽象定义 对象：类的实体（实例） ​ ​ ps. 类就像汽车设计图 对象就像实际的汽车 ​ 类(class)和对象(object)是面向对象的核心概念。类是对现实世界事物的描述，类是抽象、概念上的定义。 ​ 面向对象的开发方式： 先找具有所需功能的对象 对象不存在时创建所需功能的对象 面向对象简化开发提高代码复用 面向对象程序设计的重点：类的设计 定义类其实是定义类中的成员（成员变量、成员方法） 类 定义类其实是定义类中的成员（成员变量、成员方法） 类的定义12345678910111213141516171819public class Teacher&#123; String name; int age; String gende; public void teach()&#123; System.out.println("老师上课")； &#125; public void eat()&#123; System.out.println("老师吃饭")； &#125; public void introduce()&#123; System.out.println("姓名："+name+“年龄”) System.out.println("年龄:"+age); &#125; &#125; 类的属性 描述事物的特征 ​ 属性用来描述事物的特征，用属性变量来保存数据，属性也叫做成员变量，分为两类： 对象属性(实例属性):隶属于对象，以来于对象存在而存在 类属性(类变量)：类中的静态属性 ​ 类中定义的成员变量。 12345678910示例： public class Student&#123; public int source; private String name; private int age; private char sex; //成员变量、对象属性、类属性 ... &#125; 类的方法​ 方法也叫做成员方法，分为两类： 对象方法(实例方法)：隶属于对象通过对象来调用，内部用this调用。 类方法：隶属于类，通过该类即可访问 ​ 类中定义的方法。 123456789101112131415161718192021示例： public class Teacher&#123; String name; int age; String gende; //以下为类中定义的方法 public void teach()&#123; System.out.println("老师上课")； &#125; public void eat()&#123; System.out.println("老师吃饭")； &#125; public void introduce()&#123; System.out.println("姓名："+name+“年龄”) System.out.println("年龄:"+age); &#125; &#125; 访问属性和方法​ 通过对象访问属性和方法，使用对象加.的方式。 对象创建（简单了解）​ 通过new关键字可以将一个类进行实例化，实例化即创建某个类的对象，类的实例即是一个对象。 12// Techer类型 对象的引用 new关键字 构造方法 Teacher teacher = new Teacher(); 访问方法及属性​ 通过对象加上.的方式访问对象的方法或属性非private属性 123456789101112131415示例： public class TeacherTest&#123; public static void main(String[] args)&#123; //创建对象teacher Teacher teacher = new Teacher(); //给teacher对象的属性赋值 teacher.name = "王欢"； teacher。age = "24"; //调用teacher对象的 teach() 方法 teacher.teach(); &#125;&#125; 示例示例一 打印日期​ 创建文件MyDate.java 12345678910public class MyDate&#123; int year; int month; int day; public String getMyDate()&#123; return year+"年"+month+“月”+day+"日"； &#125;&#125; ​ 创建测试类 MyDateTest.java 1234567891011121314151617public class MyDateTest&#123; public static void main(String[] args)&#123; MyDate myBirthDay = new MyDate(); myBirthDay.year = 1995; myBirthDay.month = 8; myBirthDay.day = 17; MyDate today = new MyDate(); today.year = 2019; today.month = 4; today.day = 16; System.out.println("生日:"+myBirthday.getMyDate()); System.out.println("今天:"+today.getMyDate()); &#125;&#125; 示例二 实例与引用 封装性​ 将类的成员变量私有化，使用get、set方法读取和设置成员变量的值，体现了类的封装性，保护数据。 隐藏一个类中不需要对外提供的实现细节 使用者只能通过实现定制好的方法来访问数据 便于加入控制逻辑，限制对属性的不合理操作 便于修改，增强代码的可维护性 123456789101112131415161718192021222324252627282930313233343536373839404142434445//示例：getter、setter方法 public class Dog&#123; private String color; private String name; private int age; public void cry()&#123; System.out.println("狗狗叫呢！"); &#125; public String eat(String something)&#123; return "狗吃了"+something; &#125; public void say()&#123; System.out.println("狗会说话了？"); &#125; public String getColor() &#123; return color; &#125; public void setColor(String color) &#123; this.color = color; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; if（age&lt;20&amp;&amp;age&gt;0） this.age = age; else return; &#125; &#125; 匿名对象​ 实例化对象后直接使用，没有使用对应的引用变量进行接收。适用于对象实例化只需要进行一次调用的请情况下，调用完成对象将由GC垃圾回收进行处理。 ​ new Teacher().eat(); 构造器 创建对象 初始化对象 ​ 对象的构造器用于创建对象，在创建对象时完成对象的初始化工作。构造器(构造方法)在创建对象时由JVM执行。 构造器特征 构造器名与类名相同 不用声明返回值 不能为使用static、final、synchronized、abstract、native修饰 不能由return语句返回值 示例123456789101112131415161718192021222324public class Dog&#123; private String color; private String name; private int age; public Dog()&#123;&#125;//无参构造器 //当类中未编写构造器时默认有一个 无参构造器 //当编写了有参构造器时，默认没有 无参构造器 按需自行编写它 //带参数构造 public Dog(String color, String name, int age)&#123; this.color = color; this.name = name; this.age = age; &#125; //构造器也是类方法 可以重载 public Dog(String color,String name)&#123; this.color = color; ths.name = name; &#125;...&#125; 12345678910111213141516171819202122232425262728public class Dog&#123; private String color; private String name; private int age; public Dog()&#123; this("白色","小白")； //必须放在首行！ &#125; //无参构造器 //当类中未编写构造器时默认有一个 无参构造器 //当编写了有参构造器时，默认没有 无参构造器 按需自行编写它 //带参数构造 public Dog(String color, String name, int age)&#123; this.color = color; this.name = name; this.age = age; &#125; //构造器也是类方法 可以重载 public Dog(String color,String name)&#123; this.color = color; ths.name = name; &#125;...&#125; ​ ps. 一般类中保留两个构造器，一个无参构造器和一个全参数构造器。 ​ JavaBean JavaBean是一个普通的Java类 ​ JavaBean是一种Java语言写成的可重用组件。用户可以使用JavaBean将功能、处理、值、数据库访问和其他人户可以用java代码创造的对象进行打包，并由其他开发者在其他功能中使用这些对象。 ​ JavaBean提供了一种随时随地的复制和粘贴的功能，不用关心任何改变。 ​ JavaBean标准 类是公共类型 类中含有公共无参构造器 有属性并由对应的getter、setter方法 1234567891011121314151617181920212223242526示例：//Computer.java public class Computer &#123; private double cpu; private int memory; public Computer() &#123; &#125; public double getCpu() &#123; return cpu; &#125; public void setCpu(double cpu) &#123; this.cpu = cpu; &#125; public int getMemory() &#123; return memory; &#125; public void setMemory(int memory) &#123; this.memory = memory; &#125; &#125; 包 package package语句规范类的整理 解决类名冲突问题 ​ package语句应放在java源文件的第一行。 1234//package 包名.子包名.子子包名.子子子包名// 组织.机构名称.项目名称.模块名称// org、com、edupackage org.apache.oracle.JdbcDriver package关键字使用后编译java文件时命令需要使用java -d . *.java 其他类中使用需要使用类全限定名称org.apache.orcle.JdbcDriver 包 import import语句告诉编译器到哪里去寻找类 ​ 为使用定义在不同包中的Java类，需用·import语句来引入指定包层次下所需要的类或全部类。 123//import 包名.子包名.子子包名.子子子包包.类名(或 [表示全部]) import org.apache.oracle.JdbcDriver; import org.apache.oracle.*; 数组​ 数组是一组相同类型的数据的集合，数组是对象。元素是数组中的一个数据，任意类型的数据都可以创建数组。 数据多个形同类型数据的组合，实现堆这些数据的统一管理 数组中的元素可以是任何数据类型(基本数据类型、引用类型) 数组是引用类型，数组型数据是对象。 数组中每个元素相当于该对象的成员变量。 声明数组123456789101112131415示例： int[] intArray; //声明了一个int数组 intArray = new int[5]; //创建数组：使用new关键字 中括号内数字表示元素个数 //数组一旦创建长度和数据类型将无法再被修改 intArray[0] = 11; intArray[1] = 22; intArray[2] = 33; intArray[3] = 44; intArray[4] = 55;//以下语句编译无报错但运行时会报错IndexOoutOfBoundsException//intArray[5] = 666; ​ ps.数组在内存中时是连续 数组长度过大可能会创建失败 循环写读12345678910111213141516171819示例： int[] intArrays = new int[5]; //循环赋值 for(int i=0; i&lt;5; i++)&#123; intArrays[i] = i; &#125; //循环遍历 for(int i=0; i&lt;intArrays.length; i++)&#123; //intArrays.length是数组的长度 length是常量不可修改 System.out.println(intArrays[i]); &#125; //增强for循环遍历 // 局部变量 待遍历数组 for(int intArray:intArrays)&#123; System.out.println(intArray); &#125; 初始化数组1234567891011121314151617181920示例： //动态初始化 int[] intArrays = new int[3]; intArrays[0] = 1; intArrays[1] = 11; intArrays[2] = 111; //静态初始化 int[] intArrays = new int[]&#123;1,11,111&#125;; int[] intArrays； intArrays = new int[]&#123;1,11,111&#125;; int[] intArrays = &#123;1,11,111&#125;; //int[] intArrays； //编译报错intArrays = &#123;1,11,111&#125;; × //以下写法编译报错 //int[] intArrays = new int[6]&#123;1,11,111&#125;; × 对象数组123456789101112示例： Cat[] cats = new Cat[3]; cats[0] = new cat("灰灰")； //cats[1] = new Cat("靓靓")； cats[2] = new Cat("花花"); for(Cat cat:cats)&#123; cat.say(); &#125; //cats[2] 未实例化运行时报错空指针异常 //NullPointerException 对象关联​ 将其他类最为属性声明到当前类中，当前类拥有了一个类对象属性，并可以在类中任何地方直接使用这个对象。 ​ 对相关联就是在一个类中声明一个成员是另一个类，即类中包含了一个类类型的成员变量例如：private Compuer computer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101示例：//Computer.java public class Computer &#123; private double cpu; private int memory; public Computer() &#123; &#125; public Computer(double cpu, int memory) &#123; this.cpu = cpu; this.memory = memory; &#125; public double getCpu() &#123; return cpu; &#125; public void setCpu(double cpu) &#123; this.cpu = cpu; &#125; public int getMemory() &#123; return memory; &#125; public void setMemory(int memory) &#123; this.memory = memory; &#125; @Override public String toString() &#123; return "Computer&#123;" + "cpu=" + cpu + ", memory=" + memory + '&#125;'; &#125; &#125;//Teacher.java public class Teacher &#123; private String name; private String gender; private int age; //此成员是Couputer类型 private Computer computer; public Teacher() &#123; &#125; public Teacher(String name, String gender, int age, Computer computer) &#123; this.name = name; this.gender = gender; this.age = age; this.computer = computer; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Computer getComputer() &#123; return computer; &#125; public void setComputer(Computer computer) &#123; this.computer = computer; &#125; @Override public String toString() &#123; return "Teacher&#123;" + "name='" + name + '\'' + ", gender='" + gender + '\'' + ", age=" + age + ", computer=" + computer + '&#125;'; &#125; &#125; ​ 增强for循环 ​ 增强for循环又称为foreach循环常用于遍历数组。 123456789// for(数组元素类型 临时变量名：数组名) int[] intArray = &#123;1,2,3,4,5&#125; for(int i =0; i&lt;5; i++) System.out.println(intArray[i]); //增强for循环 for(int i: intArray) System.out.println(i); ​ 随机数产生 ​ 使用Math类的静态方法random()来产生随机数，此静态方法返回一个0~1之间的随机浮点数 1234567891011//默认产生0~1之间的浮点数double random = Math.ramdom();//产生0~100之间的浮点数double random = Math.random()*100;//产生0~100的随机整数int randomInt = (int)(Math.random*100);//产生一个[20,70)的随机整数int random = 20 + (int)(50*Math.random()); 数组运算示例统计运算​ 统计运算即求数组的最大值、最小值、总和值、平均值等 12345678910//变量后方代码复用 int max=0; int min=0; int sum=0; int avg=0; int count=0; int intArray[] = &#123; 1, 3, 5, 7, 9&#125;; int intArrayNumber[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; int maxIndex = -1; int minIndex = -1; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546示例：基本统计运算 for(int i:intArray) &#123; sum+=i; // count++; &#125; count = intArray.length; //整数相除保留整数 avg = sum/count; System.out.println("元素个数："+count); System.out.println("总和值："+sum); System.out.println("平均值："+avg); for(int i=0; i&lt;intArray.length; i++)&#123; if(i == 0) &#123; min=intArray[i]; max=intArray[i]; &#125; if(intArray[i]&gt;max) max = intArray[i]; else if(intArray[i]&lt;min) min = intArray[i]; &#125; System.out.println("最大值:"+max); System.out.println("最小值:"+min); //以下计算数组中能被2整出最大值 max = 0x0FFFFFFF; for(int i=0; i&lt;intArray.length; i++)&#123; if(intArray[i] % 2 == 0 )&#123; if(intArray[i]&lt;min) min=intArray[i]; &#125; &#125; if(min == 0x0fffffff)&#123; System.out.println("数组中不存在能被2整出的数！")； &#125; else&#123; System.out.println("数组中能被2整出的数:"+max) &#125; 12345678910示例：计算能被7整出的最大整数（int型） maxIndex = 0x0FFFFFFF; boolean flag = true; while(flag)&#123; if(maxIndex % 7 ==0) flag = false; else maxIndex--; &#125; System.out.println("能被7整除的最大整数是" + maxIndex); 数组反转​ 引入一个临时变量作为交换时暂存的位置，将数组的末尾元素和数组的头部元素依次进行交换，执行数组长度/2次循环完成数组的反转。 12345678示例：反转数组 int temp; for(int i=0; i&lt;intArray.length/2; i++)&#123; temp = intArray[i]; intArray[i] = intArry[intArray.length-i-1]; intArray[intArray.length-i-1]=temp &#125; 数组扩容​ 将原数组的元素赋值到新数组后，将新数组赋值给原数组引用。 123456789int[] intArrayNew = new int[10];//将原来数组值赋值到新数组中for(int i=0; i&lt;intArray.length; i++)&#123; intArrayNew[i] = intArray[i];&#125;//将新数组引用赋值给原数组引用intArray = intArrayNew; 123456789101112131415//int intArryNumber[] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;//将以上数组中的全部偶数存放到新的数组中 int[] intArrayDouble = new int[10]; //记录已存放数组的最大下标 int index=0; //遍历原数组 for(int i:intArray)&#123; if(i%2==0) &#123; intArrayDouble[index] = i; index++; &#125; &#125; 排序算法冒泡法排序​ 使用双重for循环加上if判断的方式，数组中的元素依次和自身数组相比，依次确定数组的最大值(最小值)并替换到数组的最前端。 123456789int temp;for(int i=0; i&lt;orignArray.length; i++)&#123; for(int j=0;j&lt;orignArray.length-i-1;j++) if(orignArray[j]&lt;orignArray[j+1])&#123; temp = orignArray[j]; orignArray[j] = orignArray[j+1]; orignArray[j+1] = temp; &#125;&#125; 选择排序​ 双重for循环，相比较于冒泡法，将数组中元素的位置调换转移到外层for循环中执行，内层for循环通过一个变量标记每次比较的最大值(最小值)。 12345678910111213for(int i=0; i&lt;orignArray.length-1; i++)&#123; int temp; int index = 0; for (int j= i+1; j&lt;orignArray.length; j++)&#123; if(orignArray[index] &gt; orignArray[i]) index = i; &#125; temp = orignArray[i]; orignArray[i] = orignArray[index]; orignArray[index] = temp;&#125; 快速排序1234567891011121314151617public int[] fastSort(int[] orignArray,int begin,int end)&#123; if(begin&gt;=end) return orignArray; int key = orignArray[begin]; int keyIndex = begin; for(int i=begin; i&lt; end; i++)&#123; if(orignArray[i]&lt;key)&#123; orignArray[keyIndex] = orignArray[i]; keyIndex++; orignArray[i] = orignArray[keyIndex]; &#125; &#125; orignArray[keyIndex] = key; fastSort(orignArray,begin,keyIndex); fastSort(orignArray,keyIndex+1,end);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java基础复习</tag>
        <tag>数组入门</tag>
        <tag>数组运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE-Chapter-2]]></title>
    <url>%2F2019%2F04%2F16%2FJavaSE-Chapter2%2F</url>
    <content type="text"><![CDATA[​ Java基础入门，基本运算、方法定义、流程控制等 第二章进制世界上又两种人，认识二进制的和不认识二进制的人 常见进制12345678283975 #按照权值进行分型 2 * 10^5 #该位置数字乘以权值+ 8 *10^+ 3*10^3+ 9*10^2+ 7*10^1+ 5*10^0 # 权值 = 10^N 十进制数 十进制：逢10进1，计算权值时以10为底的n次幂 二进制：逢2进1，计算权值时以2为底的n次幂 八进制：逢8进1，计算权值时以8为底的n次幂 十六进制：逢16进1，计算权值时以16为底的n次幂(1..9、A…F) 0xffff 使用前缀ox表示该数字为十六进制数 07使用0前缀表示八进制 0b二进制 12345示例：00110110转换为十进制数2^1 + 2^2 + 2^4 + 2^5 = 2+4+16+32 = 54示例：0x2371转换为十进制数1*16^0 + 7*16^1 + 3*16^2 + 2*16^3 = 1+112+768+8192 = 9073 进制对照 二进制 八进制 十六进制 十进制 0000 0 0 0 0001 1 1 1 0010 2 2 2 0011 3 3 3 0100 4 4 4 0101 5 5 5 0110 6 6 6 0111 7 7 7 1000 10 8 8 1001 11 9 9 1010 12 A 10 1011 13 B 11 1100 14 C 12 1101 15 D 13 1110 16 E 14 1111 17 F 15 10000 20 F1 16 10001 21 F2 17 ps. 0b1111 1111 = 0x ff ps.计算机底层存储数据使用二进制 12345678示例：将十六进制数 0x2B3C7F82转换为二进制 2 B 3 C 7 F 8 20010 1011 0011 1100 0111 1111 1000 0010示例：将二进制数 01111010111010101010110010101100转十六进制0111 1010 1110 1010 1010 1100 1010 1100 6 A E A A C A C结果为：0x6AEAACAC 符号位​ 正数的补码是其原码，负数的补码为其反码加一 ​ ps.反码即该编码各位上的数依次取反的结果 12345示例： 0000 0111 byte型整数：十六进制 0x07 十进制 7 1110 0110 byte型负数：十六进制 0x1A 十进制 26 减一：1110 0110 - 1 = 1110 0101 取反：0001 1010 12345678910111213141516171819byte型最大值：1111 1111 ： -1最小值：1000 1000 ： -128short型最大值：0111 1111 1111 1111 = 0x7FFFF = 32767最小值：1000 0000 0000 0000 = 0x8000 = -32768int型最大值：0111 1111 1111... = 0x7FFFFFFF最小值：1000 0000 0000... = 0x80000000long型最大值：0x7FFFFFFFFFFFFFFF最小值：0x8000000000000000char型最大值：0xFFFF最小值：0x0000 运算符位运算符 12345678示例：public class BinaryTest&#123; public static void main(String[] args)&#123; byte b = (byte)0xC2; // 0x000000C2 System.out.println(b); System.out.println(b &lt;&lt; 2); //-248 &#125;&#125; ps.位运算是直接对二进制进行运算 12345678910111213141516171819202122232425262728293031323334public class BinaryTest&#123; public static void main(String[] args)&#123; int n1 = 0xd7; int n2 = 0xc5; // int n1 = 0x7a; // int n2 = 0x9c; /* d7:1101 0111 c5:1100 0101 &amp;: 1100 0101 |: 1101 0111 ^: 0001 0110 ni:0011 1010 n2:0011 1010 */ // 0111 1010 // 1001 1100 // 0001 1000 = 24 System.out.println(n1 &amp; n2); // 0111 1010 // 1001 1100 // 1111 1110 = 254 System.out.println(n1 | n2); // 0111 1010 // 1000 0101 = -123 System.out.println(~n1); // 1001 1100 // 0110 0011 = -157 System.out.println(~n2); // 0111 1010 // 1001 1100 // 1110 0110 = 230 System.out.println(n1 ^ n2); &#125;&#125; 自增注意事项12345678int n = 10;n = n++;system.out.println("n="+n);//n的值为10 赋值语句从右至左 // 右n的值为10待赋值给左// 右n自增为11// 将待赋值的10赋值给左侧//结束 += 和 + 的区别123456short s =3;s = s+2; //发生了类型变化 右侧为int型s+=2; // 未发生类型变化 比较运算符 运算符 运算 范例 结果 适用范围 == 相等于 1 == 1 true 所有数据 != 不等于 1 != 1 false 所有数据 &lt; 小于 2&lt;3 true 基本数据 &gt; 大于 2&gt;3 false 基本数据 &lt;= 小等于 2&lt;=3 true 基本数据 &gt;= 大等于 2&gt;3 false 基本数据 instanceof 逻辑运算符 &amp; 逻辑与 | 逻辑或 ! 逻辑非 &amp;&amp; 短路与 || 短路或 ^ 逻辑异或 ps. &amp; 运算两边都会参与运算 不会短路 &amp;&amp; 运算会短路 a b a&amp;b a I b !a a&amp;&amp;b a^b a II b true fase true true fase true fase true true fase fase true fase fase true true fase true fase true true fase true true fase true fase fase true fase fase fase 123456789101112131415示例： 3&lt;x&lt;6 //错误写法 x&gt;3 &amp; x&lt;6 int x = 1; int y = 1; if(x++ == 2 &amp; ++ y =2) System.out.println("判断为真！")； //此处 x最终为2 y最终为2 int x = 1; int y = 1; if(x++ == 2 &amp;&amp; ++ y =2) System.out.println("判断为真！")；//此处 x最终为2 y最终为1 发生了运算短路 三目运算符​ (条件表达式)?表达式1:表达式2 表示式为ture取表达式1的值 表达式为fals取表达式2的值 123456789变量如下： int n = 10; int m = 20; int k = 40; int max;示例：取两个数中较大的数 max = (n&gt;m)?n:m;示例：取出三个数中的较大数 max = (n&gt;m)？(n&gt;k)?n:k:(m&gt;k)?m:k 运算符优先级​ 从左到右，搞优先级优先进行运算 流程控制 顺序结构：程序按顺序从上到下执行 分支结构：根据判断条件选择分支进行执行 循环结构：按照循环条件进行循环执行 分支结构基本if语句​ 当括号中的条件为真时执行后面的分支内容。 ​ ps.java中分支结构括号中的内容必须时布尔型 123456if(a == 0) System.out.println("a等于0")；if(a != 0 )&#123; System.out.println("a不等于0")； System.out.println("请重新输入!");&#125; if-else语句​ 当括号中的条件为真时，执行if后的分支内容，括号条件为假时，执行else后的分支内容。 12345if(a == 0) System.out.println("a等于0")；else&#123; System.out.println("a不等于0")； System.out.println("请重新输入!"); &#125; if-else嵌套​ 判断规则与if-else相同，将if-else进行嵌套。 123456if(a == 0) System.out.println("a等于0");else if(a == 1) System.out.println("a等于0"); else &#123; if (a==3) System.out.println("a等于3"); System.out.println("a不等于1或者0"); &#125; switch分支结构选择变量​ 变量的数据类型：byte，int，char，short，String，枚举型 基本结构1234567891011121314151617181920switch(变量)&#123; case 常量1： ... break； case 常量2： ... break; case 常量3： ... break; case 常量4： ... break; case 常量5： ... break; default: ... break;&#125; 循环结构​ 在某些条件满足的情况下，反复执行特定代码的功能，包含一下四个部分。 初始化部分(init_statement) 循环条件部分(test_exp) 循环体部分(body_statement) 迭代部分(alter_statement) ps.while循环、do/while循环、for循环 while循环语法格式1234while(布尔型测试表达式)&#123; ... 循环条件修改语句；&#125; 1234567891011121314示例： public void testWhile()&#123; int count; //初始化语句 int i = 1; //循环因子 while(i&lt;10)&#123; //循环条件 count += i; //循环体语句 i++; //迭代语句 &#125; System.out.println("count:"+count); &#125; do-while循环语法格式1234do&#123; ... 循环条件修改语句；&#125;while(布尔型测试表达式) 123456789101112示例：public void testDoWhile&#123; int result = 0,i=1; //初始化语句及循环因子 do&#123; result+=i //循环体语句 i++ //迭代语句 &#125;while(i&lt;=5)//循环条件 System.out.println("result:"+result);&#125; for循环语法格式123for(初始化语句;布尔测试表达式;循环条件修改语句)&#123; ... &#125; 123int count;for(int i=1; i&lt;100; i++) count+=i;System.out.println("count:"+count); 无限循环​ 当循环次数不确定时，优选while循环。 1234示例： boolean flag = true; while(flag)&#123; ... &#125; do&#123;...&#125;while(flag)//至少循环一次 1234示例： boolean flag = true; for(;;;)&#123;...&#125; for(;flag;)&#123;...&#125; 特殊流程控制break 语句​ break语句用于终止某个语句块的执行。 12345678示例： for(int i=0; i&lt;10; i++) if( i==3 ) break; label：for(int i=0; i&lt;10; i++)&#123; for(int i=0; i&lt;10; i++) if( i==3 ) break lable; &#125; countinue语句​ 只能用于循环语句，跳过某次循环。 return语句​ 结束方法，方法执行的返回。 方法 某种功能的封装 方法 = 方法签名 + 方法体 ​ 方法是类或对象行为特征的抽象，也成为函数。Java中方法不能独立存在，必须在类中定义。 语法格式1234权限修饰符 返回值类型 方法名(参数类型 参数1,参数类型 形参2,...)&#123; ... return 返回值;&#125; 12345678910示例： public String printHello(int name)&#123;//方法签名 Stirng hello = "Hello! "+ name; return hello; &#125; public static void main(String args[])&#123; //方法调用 String welcome = printHello(); //int a = printHello(); × &#125; 形式参数：在方法被调用时用于接收外部传入的数据的变量 参数类型：形式参数的数据类型 返回值：方法在执行完毕后返还给调用它的程序的数据 返回值类型：方法要返回的结构的数据类型 实际参数：调用方法时实际穿个函数形式参数的数据 ps. 返回值为void的方法表示无返回值 重载 重载让方法调用变得简单 ​ 在同一个类中，方法名相同，参数不同就形成重载。参数不同体现在类型不同、顺序不同、参数个数不同。 12345678910111213141516示例： public class OverLoadTest&#123; public static int add(int a, int b)&#123; return a+b; &#125; public static int add(int a, byte b)&#123; return a+b; &#125; public static int add(int a, double b)&#123; return (int)a+b; &#125; &#125; 方法的参数传递​ java中只有值传递，形参是实参的一个复制品。 方法调用的原理栈帧​ 方法栈中的组成单元，包括了方法及其局部变量。 方法栈​ 一个先进后出的结构，用于存放方法，其单元由栈帧组成。 方法栈原理 说明： main函数中调用add方法 main函数调用参数传递后压栈 开始add方法的方法体执行 add方法中又调用test方法 add方法入栈 进行test方法执行 test执行完成出栈 add执行完成出栈 (将返回值拷贝到临时空间) main方法执行 (从临时取获得返回值继续执行) 跨类调用方法​ 通过类名大写加上.的方式可以访问该类的静态方法。 123456789101112 public class Method&#123; public static String getMethod()&#123; return "Method"; &#125; &#125; public class Test&#123; public static void main(String[] args)&#123; String method = Method.getMethod; Sysem.out.println() &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>基础入门</tag>
        <tag>常见运算</tag>
        <tag>Java简介</tag>
        <tag>循环语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop]]></title>
    <url>%2F2018%2F10%2F05%2FHadoop%2F</url>
    <content type="text"></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>入门</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zookeeper]]></title>
    <url>%2F2018%2F10%2F05%2FZookeeper%2F</url>
    <content type="text"><![CDATA[Zookeeper是一个开源的分布式工具，为分布式应用提供协调服务，由Apache开源管理。基于观察这模式设计的分布式服务管理框架，接受观察者注册，当数据发生变法，通知观察者做出相应的反应。 简介集群中包括一个领导者（Leader），多个跟随者（Follower）组成的集群，只要集群中有半数以上节点存活，集群就能正常服务。数据一致，每个Server保存相同数据副本，无论访问哪一个Server都是一样的。客户端更新请求顺序执行，更新具有原子性，数据在一定时间内，客户端能读取到最新数据。 数据结构 树形结构，每一个节点称为ZNode，一个节点默认存储1MB数据，可以通过其路径唯一标示进行访问。 使用场景 统一命名服务 多IP对应一个域名 统一配置管理 Kafka集群 配置文件写入节点 统一集群管理 注册服务 实时监控服务转态 服务器节点动态上下线 服务状态注册 客户端实时观察服务状态 软负载均衡 设置访问节点负载均衡 切换访问动态平衡 下载Zookeeper 官网 安装]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2018%2F10%2F02%2FJavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 数据类型基本数据类型 String：任意字符串 Number：任意数字 boolean：true/false undefined：undefined null：null 引用类型 Object：任意对象 Function：可执行对象 Array：数组类型，下标访问 判断类型 typeof：类型判断。undefined/数值/字符串/布尔值 instanceof：判断对象是否为某个类型 a instanceof Object ===：判断引用是否为完全相等，即指向同一个地址 内存模型JavaScript的内存模型中包含堆栈，对象的引用存储在栈中，堆中存储了对象的实例。加载代码到内存中，同样包含一个方法区。 分配内存 -&gt; 存储数据 -&gt; 释放内存。局部变量在执行完成后自动释放，对象在没有引用的情况下会被垃圾回收。 对象对象可以封装多个数据，一个对象代表一个事物的抽象，统一管理多个数据。 123456789101112131415161718var car = &#123; name:'BMW', price:'100w', setName:function(name)&#123; this.name = name &#125;, setPrice:function(price)&#123; this.price = price &#125; //方法认为是一种特别的属性&#125;car.setName("宝马");car.setPrice("100万");console.log(car.name);car['setName']("奔驰");console.log(car['name']); 函数函数声明1234567891011121314151617181920212223242526//直接调用function check(num)&#123; if (num &lt; 60)&#123; console.log("不及格！") &#125; else if(num&gt;=60&amp;&amp;num&lt;90)&#123; console.log("中等！") &#125;else if (num &gt;= 90) &#123; console.log("优秀！") &#125;else&#123;console.log("错误！")&#125;&#125;check(60);check(80);check(90);check("a");//对象调用var obj =&#123;&#125;function fn() &#123; this.name = "name" console.log("this is a function!");&#125;fn.call(obj);console.log(obj.name) 回调函数事件回调函数、定时器回调函数、ajax请求回调函数、声明周期回调函数 12345678910111213&lt;body&gt;&lt;button id = "btn"&gt;按钮测试！&lt;/button&gt;&lt;script type="text/javascript"&gt; document.getElementById('btn').onclick = function () &#123; alert(this.innerHTML) &#125; // 事件回调 setTimeout(function () &#123; alert("Time out"),2000 &#125;) //定时器回调&lt;/script&gt;&lt;/body&gt; IIFEImmediatel-Invoked Function Expression：立即执行函数表达式 1234(function()&#123; console.log("立即执行函数！")&#125;)()//匿名函数自调用 this指针 全局：window 函数内部：指向当前函数对象 调用：指向调用者 原型每个函数都有一个prototype属性，这个属性默认指向一个空Object对象，对象中包括一个构造器函数(constructor),prototype对象中包括了很多操作的方法，类似于类构造，这个对象中包含了很多方法。当一个对象属于某一类对象的时候，它会拥有一个原型属性，这个属性中包括了这一类对象的所有方法。类似于继承。 1234console.log(fn.prototype)//fn.prototype即为原型对象console.log(fn.prototype.constructor===fn)//构造器指向函数本身 显式原型上面描述的属性即为函数的显式原型。 12function abc()&#123;&#125;console.log(abc.prototype) 隐式原型实例对象将包含一个隐式原型，即实例过后的对象将包含一个_proto_属性，其值对行为其构造函数的显式原型值，即实例化对象指向原型对象。 简单理解，这两个原型，显式原型是函数定义就指向的原型对象，类似Java中的父类，而隐式原型是实例后的属性，同样也指向父函数。原型对象中的方法，可以在实例对象中直接进行调用，而其调用方法是通过隐式原型属性获取到了父对象的方法。 12fn.prototype 指向某个对象 Objectfn._proto_ 指向某个对象 Object 原型链 执行方法是，现在实例中寻找，再到隐式原型寻找，再到运行对象寻找，寻找方法会沿着隐式原型一直寻找到Object对象。 12345678910111213141516function A()&#123;&#125;A.prototype.n = 1var b = new A()A.prototype = &#123; n:2, m:3&#125;var c = new A()console.log(b.n,b.m,c.n,c.m) # 1 undefined 2 3 上下文12345678var a = 3function fn()&#123; console.log(a) var a =4&#125;fn()# undefined 变量提升，在执行输出语句之前，变量a就已经声明了，只是没有进行赋值，所有结果是undefined，函数也具有这样的特性。 代码分为全局代码和函数代码。 全局执行 代码分类(位置) 全局代码 函数(局部)代码 全局执行上下文 在执行全局代码前将window确定为全局执行上下文 对全局数据进行预处理 var定义的全局变量==&gt;undefined, 添加为window的属性 function声明的全局函数==&gt;赋值(fun), 添加为window的方法 this==&gt;赋值(window) 开始执行全局代码 函数执行上下文 在调用函数, 准备执行函数体之前, 创建对应的函数执行上下文对象(虚拟的, 存在于栈中) 对局部数据进行预处理 形参变量==&gt;赋值(实参)==&gt;添加为执行上下文的属性 arguments==&gt;赋值(实参列表), 添加为执行上下文的属性 var定义的局部变量==&gt;undefined, 添加为执行上下文的属性 function声明的函数 ==&gt;赋值(fun), 添加为执行上下文的方法 this==&gt;赋值(调用函数的对象) 开始执行函数体代码]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>高级</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js]]></title>
    <url>%2F2018%2F10%2F01%2Fnode-js%2F</url>
    <content type="text"><![CDATA[Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js 不是一个 JavaScript 框架，不同于CakePHP、Django、Rails。Node.js 更不是浏览器端的库，不能与 jQuery、ExtJS 相提并论。Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。 Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 模块化将程序分割成一个个小的模块，解耦和，提高代码复用效率。 123456//model.jsexports.x="这是一个变量";exports.fn = function () &#123; console.log("这是一个函数");&#125; 12345678//hello.jsconsole.log("Hello node!");var model = require("./module");//require引入模块model.fn();console.log(model); 在引用外部模块时，使用的字符串为模块的标识，模块分为核心模块和文件模块，核心模块由引擎提供的模块，文件模块为用户自己编写的模块。 12var fs =require("fs")//使用文件名就可以引入模块 node在执行编写的模块的时候进行包装到函数，变量都是局部变量。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//example.jsvar a = 10;console.log(arguments.callee + "");exports.x="这是一个变量";exports.fn = function () &#123; console.log("这是一个函数");&#125;/*function (exports, require, module, __filename, __dirname) &#123; var a = 10;console.log(arguments.callee + "");exports.x="这是一个变量";exports.fn = function () &#123; console.log("这是一个函数");&#125;&#125; *///传递的五个参数/*[Arguments] &#123; '0': &#123;&#125;, '1': &#123; [Function: require] resolve: &#123; [Function: resolve] paths: [Function: paths] &#125;, main: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'C:\\Users\\Leo\\WebstormProjects\\Node-hello\\module.js', loaded: false, children: [], paths: [Array] &#125;, extensions: &#123; '.js': [Function], '.json': [Function], '.node': [Function] &#125;, cache: &#123; 'C:\\Users\\Leo\\WebstormProjects\\Node-hello\\module.js': [Module] &#125; &#125;, '2': Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'C:\\Users\\Leo\\WebstormProjects\\Node-hello\\module.js', loaded: false, children: [], paths: [ 'C:\\Users\\Leo\\WebstormProjects\\Node-hello\\node_modules', 'C:\\Users\\Leo\\WebstormProjects\\node_modules', 'C:\\Users\\Leo\\node_modules', 'C:\\Users\\node_modules', 'C:\\node_modules' ] &#125;, '3': 'C:\\Users\\Leo\\WebstormProjects\\Node-hello\\module.js', '4': 'C:\\Users\\Leo\\WebstormProjects\\Node-hello' &#125;*/ 模块导出 12345678910111213module.exports.name = 'name';module.exports.age = 18;module.exports.getName= function()&#123; console.log("This is my name");&#125;module.exports = &#123; name:"name", age:18, getName:function()&#123; console.log("This is my name!"); &#125;&#125; 包管理包括包结构和包描述,增强模块 12345678910package.json#描述文件bin#可执行二进制lib#js代码doc#文档test#单元测试 123456789101112131415161718192021&#123; "name": "react-server", "version": "1.0.0", "description": "an example of react.js in server", "main": "server.js", "scripts": &#123; "build": "babel -d . src/", "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "ruanyf", "license": "ISC", "dependencies": &#123; "browserify": "~9.0.3", "literalify": "~0.4.0", "react": "^0.14.0", "react-dom": "^0.14.0" &#125;, "devDependencies": &#123; "babel": "~5.8.21" &#125;&#125; 12#不带写注释的#name/description/version/keywords/maintainers/contributors/bugs/licenses/repositories/dependencies/homepage/os/cpu/engine/buildtin/directories/implements/scripts/author/bin/main/devDependencies npm（Node Package Manager）包管理器，第三方模块发布、安装和依赖，依赖及包管理工具。 1234567891011121314151617181920#初始化package.jsonnpm init#安装包npm install [包名]npm i [包名]#删除包npm remove [包名]#搜索包npm search [包名]#查看版本npm versionnpm -v#安装包并添加到依赖npm install [包名] --save #删除并移除依赖npm remove [包名] --sava#镜像来源安装npm install [包名] -registry=地址#设置源npm config set registry 地址 创建package.json文件 12345678910111213141516171819202122232425262728#初始化npm initpackage name: (node-hello) pkinitversion: (1.0.0)description: This is a packagejson init test.entry point: (module.js) index.jstest command:git repository:keywords:author:license: (ISC)About to write to C:\Users\Leo\WebstormProjects\Node-hello\package.json:&#123; "name": "pkinit", "version": "1.0.0", "description": "This is a packagejson init test.", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC"&#125;Is this OK? (yes) yes 123456789101112131415package.json&#123; "name": "pkinit", "version": "1.0.0", "description": "This is a packagejson init test.", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1" &#125;, "author": "", "license": "ISC", "dependencies": &#123; "math": "0.0.3" &#125;&#125; 缓存区结构和操作方法与数组类似，存储二进制数据，元素8位，一字节，00 - ff。（汉字三字节，英数一字节） 1234567891011121314151617181920var str = "This is a String ";var buf = Buffer.from(str);console.log(buf);/*&lt;Buffer 54 68 69 73 20 69 73 20 61 20 53 74 72 69 6e 67 20&gt;*///创建一个十字节缓冲区var buff = Buffer.alloc(10);//创建不清除内存中数据var buff = Buffer.allocUnsafe(10);//操作元素buf[0] = 255;console.log(buf.toString()); 同步写1234567891011var fs = require("fs")var fd =fs.openSync("test.txt","w");fs.writeSync(fd,"同步写入内容");fs.closeSync(fd);// fs.openSync(path,flags[,mode]) 参数为字符串 （路径，r|w）//fs.writeSync(fd,string[,position[,condiong]])]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>基础入门</tag>
        <tag>基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F09%2F19%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux 常用操作 用户管理用户Linux操作系统中实际登入操作系统的人员即用户，系统可以多个用户，用户都有一个家目录。 命令使用1234567891011121314151617181920212223242526#用户操作#当没有规定组信息时，将会创建一个和用户名同名的组并属于这个组useradd [选项] 用户名#指定家目录 将会创建指定家目录useradd -d 目录 用户名#指定或修改密码（注意密码复杂设计）passwd 用户名#删除用户（家目录会保留）userdel 用户名#家目录也一并删除userdel -r 用户名#查看用户信息 uid：用户id |gid：组id |组名id 用户名#切换用户 高到低直接进入su 用户名#创建并添加到组useradd -g 组名 用户名#修改用户的组usermod -g 用户组 用户名 用户组用户组具备组的权限，每个用户至少属于一个用户组，使用组来管理用户及其权限。 命令使用12345678910111213#组操作#创建组groupadd 组名#删除组groupdel 组名#创建用户并添加到组useradd -g 组名 用户名#修改用户的组usermod -g 用户组 用户名 相关文件12345678910111213#/etc/passwd 用户配置文件 保存用户信息#用户名：口令：用户标识：组标识：描述：家目录：登录Shellroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologin 12345678#/etc/group 组配置文件 保存组信息#组名：口令：组标志号：组内用户列表root:x:0:bin:x:1:daemon:x:2:sys:x:3:adm:x:4:tty:x:5: 1234#/etc/shadow 密码和登录信息#登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：不活动时间：失效时间：标志root:$6$BeJFLJMZpFVSI9m4$18eX0WZN1sdOwkMBlhI3AtFR0yS5.RWvNMj5Vq/5dnIe2rFEgJoCaQiZDqPE23SEHxmVQqDT24o0sweqPDazJ.::0:99999:7:::leo:$6$DCIE21do$h3x9U9DYJx5aQymoISHMGG/nCwI0TSaDZCWCbQzsfuTysLK/BA9GYw6L4fkEQdH6BNKiZEm1c.HV8TtYvS./x.:17793:0:99999:7::: 运行级别 0：关机 1：单用户级别（找回密码） 2：多用户无网络服务（安全模式） 3：多用户提供网络服务（黑窗） 4：保留级别 5：图形化界面级别（图形版） 6：重启 1234567891011121314151617181920212223242526272829#/etc/inittab#我的centOS7 不带这个文件了# inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target## systemd uses &apos;targets&apos; instead of runlevels. By default, there are two main targets:## multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5## To view current default target, run:systemctl get-default## To set a default target, run:systemctl set-default TARGET.target#命令init 级别号码#进入单用户模式可以不用密码直接进入系统#用于密码遗忘时进行密码修改#然后根据提示按e键，进入编辑选项#在UTF-8行编辑修改两处，首相将ro改为rw，即只读改为可#读写权限，然后在尾部加入 init=/bin/sh#此时按住Ctrl+x快捷键进入拯救模式touch /.autorelabelexec /sbin/init 文件操作 pwd ：显示当前路径 ls：-i 列表显示 -a 全部显示 cd：进入目录 ~ 家 .. 上一层 mkdir：创建目录 -p 多级目录 rmdir：删除目录 建议使用 rm -rf 目录 touch：创建文件 cp ：cp 源 目标 | -r 递归子文件 rm：删除 -r 整个文件夹 -f 强制删除 mv：移动或重命名 文件或文件夹 cat：查看内容 -n 显示行号 more：按页显示 空格翻页 回车加一行 ctrl+F 向下一屏幕 ctrl+B 向上一屏幕 = 输出当前行号 :f 文件名和行号 less：分屏查看文件 空格翻一页 pageUp pageDown /查找 q退出 > &amp; &gt;&gt;:覆盖和追加 echo：echo $path head：看头几行 -n 行数 tail：查看文件尾部内容 -n 行数 ln：-s 软连接 [源文件或目录][软连接名] history：查看历史 时间日期 date：时间 %Y %m %d YmdHMS date “+%Y” |-s 设置时间 cal：日历 查找指令 find：查找搜索 find /etc/ -name pass* -user root -size 20M grep：cat a.text|grep -in 不区分大小写并返回行号 压缩与解压123456789101112131415161718192021222324#gzip/gunzip 指令 压缩解压 .gz 文件gzip UserController.java#生成压缩并且源文件不保存 可以同时压缩多个文件gzip UserController.java.gz#解压#zip/unzip 压缩解压 .zip 文件# -r 递归压缩，压缩一个目录# # -d 指定解压文件存放目录#zip -r home.zip /homeunzip -d /home/zip home.zip#tar 压缩解压 .tar.gz 文件# -c 打包产生 tar# -v 显示详细信息# -f 指定压缩文件名# -z 打包并压缩# -x 解压.tar文件tar -zcvf a.tar.gz a.java b.javatar -zcvf a.tar.gz /hometar -zxvf a.tar.gztar -zxvf a.tar.gz -C /home 权限管理一个文件将具有三个组权限，所有组，所在组，其他组。 所有者默认是文件的创建者。 1234#修改所有者chown root a.javachown 所有者：所有组 文件名chowm -R 所有者：所有组 文件名 拥有文件的组，默认为创建者的组。 12#修改所有组chgrp root b.java 123#用户组修改usermod -g 组名 用户名usermod -d 目录 用户名 新目录 读写权限，文件类型。 1234567-rwxrwxrwx 1 100 普通文件 所有者权限 组权限 其他权限 硬链接数目drwxtwxrwx 5 4096 目录 ... 子目录数l--------- 软链接b--------- 字符设备c--------- 块文件-rw-r--r-- 1 root root 902 Sep 19 19:38 sources.list普通文件 硬链接 所有者 组 字节 最后一次修改 12345678#u 所有者，g 所有组，o 其他人，a 所有人chmod u=rwx,g=rw,o=r 文件名chmod o-wx 文件名chmod a+r 文件名#数字修改chmod 777 文件名|r w x |r w x |r w x||1 1 1 |1 1 1 |1 1 1| 定时任务定时执行命令或脚本。 12345678910111213141516#crontab#-e 编辑任务#-l 查询任务#-r 删除用户所有任务cron -e* * * * * 分时号月周* 全部，列举- 范围*/n 间隔#hello.shcal&gt;&gt;/home/leo/time.txt#完成corntab -e*/1**** /home/hello.sh 磁盘操作1234567891011121314# 磁盘情况查询# 查询磁盘整体使用情况df -lhdu -ach --max-depth=1 /opt# -s 指定目录占用汇总# -h 带计量单位# -a 包含文件# -max-depth=1 子目录深度# -c 列出明细并汇总# 文件或目录个数ls [路径] -l | grep "^-" |wc -lls [路径] -lR | grep "^d"|wc -l 网络配置12345678910111213#/etc/sysconfig/network-scripts...ONBOOT=yesBOOTPROTO= static|dhcpIPADDR=19..GATEWAY=...DNS1=... 进程管理12345678910111213#查看进程ps -aux | more#|USER|PID|%CPU|%MEM|VSZ|RSS|TTY|STAT|START|TIME|COMMAND|#|用户名|进程号|占用cpu|占用内存|使用虚拟内存|使用物理内存|终端|状态|启动时间|占用cpu时长|进程执行的命令|#状态：S 休眠 R运行 Z僵尸 N-低优先级 T-被跟踪或停止 s- 会话先导进程ps -ef| more#|UID|PID|PPID|C|STIME|TTY|TIME|CMD|#用户 进程号 父进程 优先级 启动时间 终端名 占用cpu时长 启动命令及参数ps -ef| grep javakill pid 服务管理后台运行进程，监听端口，登台其他程序的请求。 1234567891011# 服务指令service [服务名] start | stop | restart | reload | statussystemctl [... CentOS 7# 可视化界面命令 setup# 启动级别自启动chkconfing# 启动项目录/etc/init.d/ 进程监控top 动态监控进程信息 1234567891011top# -d 秒 间隔描述更新# -i 不显示闲置或僵死的进程# -p 通过指定监控进程ID来监视某个进程状态交互指令P：以cpu使用率排序M：以内存使用率排序N：与PID排序q：退出u: 输入用户名 123456netstat- an 按一定顺序排列输出- p 显示哪个进程在调用netstat -anp | grep java 包管理123456789101112131415161718192021rpm -qa | grep xxxrpm -qa | morerpm -q [包名]rpm -qi [包名]rpm -qi `rpm -qa|grep net-tools`#包明细rpm -ql [包名]#安装包包含文件rpm -qf [文件名]#文件属于哪个包mysql-community-server-5.7.23.-1.e17.x86_64#名称 版本号 适用系统rpm -e RPM [包名称]#删除包rpm -e --nodeps [包名]#强制删除 如被依赖 使用者将可能服务运行yum list|grep [包名]yum insatll [包名]yum search [包名] Shell编程12#!/bin/bashecho 'hello' 变量基本变量变量名称可以由字母、数字和下划线组成，不可以数字开头，等号两侧不能有空格，习惯变量名大写。 Shell编程中，可以将命令执行的结果赋值给变量。 123A=`ls -la`A=$(ls -la) 系统变量 $HOME：家目录 $PWD：当前路径 $SHELL：当前shell $USER：当前用户 $PATH：环境变量 用户自定义变量 定义：A=100 使用：$A 撤销：unset A 静态：readonly A=100 全局变量： 环境变量语法 export 变量名 source 配置文件 echo $变量名 123#/etc/profileTOMCAT_HOME=/opt/usr/tomcat/export TOMCAT_HOME 12source /etc/profileecho $TOMCAT_HOME 位置参数变量12345#!/bin/bashecho "$0 $1 $2"echo "$*"echo "$@"echo "$#" 123456./pos.sh 111 222 333 444#输出结果如下#./pos.sh 111 222#111 222 333 444#111 222 333 444#5 预定义变量1234#!/bin/bash$$:当前进程的进程号$!:后台运行的最后一个进程的进程号$?:最后一次执行的命令的状态，0为正确执行命令 1234#!/bin/bashecho "当前进程：$$"./hello.sh &amp;echo "最后执行进程：$!" 基本语法运算123&quot;$((运算式))&quot;&quot;$[运算式]”expr m + n 12#!/bin/bashecho "$(((2+3)*4))" 123456789101112#!/bin/bashRESULT=$(((2+3)*4))echo "计算方式1：$RESULT"RESULT2=$[(2+3)*4]echo "计算方式2：$RESULT2"RESULT3=`expr 2 + 3`RESULT3=`expr $RESULT \*4`echo "计算方式3：$RESULT3" 判断条件1[ 条件 ] 123456789101112131415字符串比较：=小于:-lt小于等于:-le等于:-eq大于:-gt大于等于:-ge不等于:-ne#读写具备读:-r具备写:-w具备执行:-x#文件类型文件存在并为常规类型:-f文件存在:-e目录存在:-d 123456789101112131415#!/bin/bashif [ "ok" = "ok" ]thenecho "相等"fiif [ 23 -gt 22 ]then echo "23大于22"fiif[ -e /root/sh/hello.sh ]then echo "文件存在"fi IF语句12345678#!/bin/bashif [ $1 -gt 60 ]then echo "成绩及格"elif [ $1 -le 60 ]then echo "成绩不及格"fi CASE语句12345678910111213#!/bin/bashcase $1 in"1")echo "you choose 1";;"2")echo "you choose 2";;*)echo "you choose other"esac FOR循环123456789101112131415161718192021222324#!/bin/bashfor i in "$*"doecho "num is $i"done#输出#num is 11 22 33#!/bin/bashfor i in "$@"doecho "num is $i"done#输出#num is 11#num is 22#num is 33SUM=0for((i=0;i&lt;+100;i++))do SUM=$[$SUM+$i]doneecho "总和为：$SUM" WHILE循环12345678SUM=0i=0while [ $i -le $1 ]do SUM=$[$SUM+$i] i=$[$i+1]doneecho "总和为：$SUM" 控制台输入read [选项] [参数] -p：指定读取值时的提示符 -d：指定读取值时的等待时间 123456789#!/bin/bashread -p "请输入数字：" NUMecho "输入数字为：$NUM"read -t 10 -p "请输入数字：" NUM2echo "输入的数字为" NUM2 系统函数basename常用于获取文件名，获取完整路径最后一个/后面的内容。 1234basename /root/sh/hello.sh#输出 hello.shbasename /root/sh/hello.sh .sh#输出 hello dirname常用语获取文件目录名，获取完整路径最后一个/前面的内容。 12dirname /root/sh/hello.sh#输出 /root/sh 自定义函数12345678910111213#!/bin/bashfunction count()&#123; SUM=$[$n1+$n2] echo "Sum:$SUM" &#125;read -p "Pls Input A Number:" n1read -p "Pls Input Other Number:" n2count $n1 $n2 实例1234567891011121314151617181920212223242526272829#!/bin/bashBACKUP=/root/sh/abcDATATIME=$(date +%Y_%m_%d_%H%M%S)echo $DATATIMEecho "=================开始执行操作==============="echo "路径为：$BACKUP/$DATATIME.tar.gz"HOST=localhostUSERNAME=rootPASSWORD=rootDATABASE=test[ ! -d "$BACKUP/$DATATIME" ] &amp;&amp; mkdir -p "$BACKUP/$DATATIME"mysqldump -u$&#123;USERNAME&#125; -p$&#123;PASSWORD&#125; --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATATIME/$DATATIME.sql.gzcd $BACKUPtar -zcvf $DATATIME.tar.gz $DATETIMEfind $BACKUP -mtime +10 -name "*.tar.gz" -exec rm -rf &#123;&#125; \; 12345crontab -e10 2 * * * /usr/sbin/backup_database.sh#每天两点十分执行备份操作]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>使用操作</tag>
        <tag>命令演示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud]]></title>
    <url>%2F2018%2F09%2F16%2FSpring-Cloud%2F</url>
    <content type="text"><![CDATA[入门问题 微服务概念 微服务之间如何通信 SpringCloud与Dubbo的区别 SpringBoot与SpringCloud的关系 服务熔断和服务降级概念 微服务的优缺点 微服务技术栈 eureka和zookeeper的区别 ##简介 微服务概述微服务起源：微服务 微服务将单一应用程序划分为一组小服务，每个服务独立在及自己的进程中，通过Restful方式互相沟通、调用。每个服务提供单个业务功能，去耦合。 微服务与微服务架构微服务：指系统中的一个服务应用。 微服务架构：架构风格，即包括微服务及微服务之间的通信。 微服务的优缺点优点 服务高内聚，完成一个细微化的业务或功能 单个服务的开发更便捷，开发简单、开发效率高 微服务可由独立团队开发 松耦合，开发及部署都独立 可以由不同语言开发，易于集成 前后端分离、灵活分配数据库 缺点 分布式系统的复杂性 运维难度增加，系统部署依赖问题 服务间通信额外花费 数据一致性、系统集成测试难度 性能监控难 微服务技术栈 微服务 技术 开发 Spring、SpringBoot、SpringMVC 配置管理 Archaius（Netflix）、Diamond（Ali） 注册与实现 Eureka、Consul、Zookeeper 调用 Rest、RPC、gRPC 熔断器 Hystrix、Envoy 负载均衡 Ribbon、Nginx 接口调用工具 Feign 消息队列 Kaflka、RabbitMQ、ActiveMQ 配置中心管理 SpringCloudConfig、Chef 路由(API网关) Zuul 监控 Zabbix、Nagios、Metrics、Spectator 全链路追踪 ZipKin、Brave、Dapper 部署 Docker、OpenStack、Kubernates 数据流操作 SpringCloud Steam（Redis、Rabbit…） 事件消息总线 Spring Cloud Bus SpringCloud 架构主流选用 厂商 技术选用 阿里 Dubbo/HSF 京东 JSF 新浪微博 Motan 当当 Dubbo 框架对比 功能 Spring Cloud Motan gRPC Thrift Dubbo/DubboX 定位 完整微服务 RPC+ZK/Consul RPC RPC RPC Rest 支持 否 否 否 否 RPC 否 是 是 是 是 多语言 是 否 是 是 否 注册/发现 （Eurka） Zookeeper/Consul 否 否 是 负载均衡 Zuul+Ribbon 是 否 否 是 配置服务 Archaius/sp config servier 调用链监控 Zuul API 高可用/容错 Hystrix Ribbon 其他 SpringCloud简介 SpringCloud微服务架构，涵盖了服务注册/发现、配置中心、全链路监控、服务网管、负载均衡、熔断器等，使用SpringBooot简化开发，提供快速构建分布式系统的工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策精选、分布式会话等，都可以使用SpringBoot开发进行快速启动和部署。 SpringCloud：一站式分布式微服务解决方案 Dubbo 对比 SpringCloud 对比 Dubbo SpringCloud 注册中心 Zookeeper Eureka 调用方式 RPC REST API 监控 Dubbo-minitor spring boot admin 断路器 不完善 SC Netfilx Hystrix 网管 无 SC Netfilx Zull 分布式配置 无 SC config 跟踪 无 SC Sleuth 消息总线 无 SC Bus 数据流 无 SC Stream 批量任务 无 SC Task … 文档官方文档 API 文档 中国社区 Spring中文网 示例版本 Cloud: Dalston.SR1 Boot: 1.5.9 创建工程创建父工程Maven配置打包类型为Pom 在父工程中创建子工程模块 创建子工程 Eureka 服务注册与发现，注册订阅后可以依据服务标识符访问服务，不需要修改配置文件，功能和Zookeeper类似，遵循AP原则。 功能对比 Eurka Zookeeper 架构 CS架构 Server端注册服务器 RPC 稳定性 冗余备份，所有集群均可独立工作 主从备份，选举费时 Eureka简介服务端：提供服务注册服务，存储所有可用服务节点的信息。 客户端：Java客户端，简化同服务端的交互，包含负载均衡器，启动后会向服务端周期发送心跳（默认30s），当服务器在多个周期中未受到某节点心跳（默认90s），节点将会移除。 注册中心1234567891011server: port: 7001eureka: instance: hostname: localhost client: register-with-eureka: false #不注册自身 fetch-registry: false #服务端 service-url: defalutZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;s 12345678@SpringBootApplication@EnableEurekaServerpublic class EurekaServer7001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServer7001_App.class,args); &#125;&#125; 服务提供者12345678eureka: client: #客户端注册进eureka服务列表内 service-url: defaultZone: http://localhost:7001/eureka #defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/ instance: instance-id: microservicecloud-dept-8001 prefer-ip-address: true #访问路径可以显示IP地址 12345678@EnableEurekaClient@SpringBootApplicationpublic class DeptProvider8001_App &#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProvider8001_App.class,args); &#125;&#125; 服务消费者12server: port: 80 12345678910@Configurationpublic class ConfigBean&#123; @Bean @LoadBalanced//Spring Cloud Ribbon 负载均衡的工具。 public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132 private static final String REST_URL_PREFIX = "http://localhost:8001";//private static final String REST_URL_PREFIX = "http://MICROSERVICECLOUD-DEPT"; @Autowired private RestTemplate restTemplate; @RequestMapping(value = "/consumer/dept/add") public boolean add(Dept dept) &#123; return restTemplate.postForObject(REST_URL_PREFIX + "/dept/add", dept, Boolean.class); &#125; @RequestMapping(value = "/consumer/dept/get/&#123;id&#125;") public Dept get(@PathVariable("id") Long id) &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/get/" + id, Dept.class); &#125; @SuppressWarnings("unchecked") @RequestMapping(value = "/consumer/dept/list") public List&lt;Dept&gt; list() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/list", List.class); &#125; // 测试@EnableDiscoveryClient,消费端可以调用服务发现 @RequestMapping(value = "/consumer/dept/discovery") public Object discovery() &#123; return restTemplate.getForObject(REST_URL_PREFIX + "/dept/discovery", Object.class); &#125; 负载均衡Ribbon客户端负载均衡工具 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; 12345678910@Configurationpublic class ConfigBean&#123; @Bean @LoadBalanced//Spring Cloud Ribbon 负载均衡的工具。 public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 1234567@Beanpublic IRule myRule()&#123; //return new RoundRobinRule(); //return new RandomRule();//达到的目的，用我们重新选择的随机算法替代默认的轮询。 return new RetryRule();&#125; 算法 RoundRobinRule 轮询 RandomRule 随机 AvaliabilityFilteringRule 过滤访问导致故障处于断路器跳闸的服务、超并发阈值服务，剩余轮询 WeightedResponseTimeRule 根据平均响应时间分配权重，权重大的被选中几率大，服务启动使用轮询，后切换为WeightedResponseTimeRule。 RetryRule 按照轮询获取服务，失败时，在指定时间内重试。 BestAvaliableRule 过滤故障跳闸服务，选择并发量小的服务。 ZoneAvoidanceRule 默认规则，复合判断服务性能和选择可用服务。 自定义负载均衡策略1234567891011import com.wang.myrule.MySelfRule;/////////////////@RibbonClient（name="microservicecloud-dept",configration=MySelfRule.class)/////////////////@EnableEurekaClient@SpringBootApplicationpublic class ConsumerDept80 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerDept80.class,args); &#125;&#125; 123456789101112131415161718192021//自动配置类 不能载SpringBoot的自动扫描范围//如果被扫描 所有的客户端将共享这个配置package com.wang.myrule;//与主配置并列包import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.RoundRobinRule;@Configurationpublic class MySelfRule&#123; @Bean public IRule myRule() &#123; //return new RandomRule();// Ribbon默认是轮询，我自定义为随机 //return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机 return new RandomRule_ZY();// 我自定义为每台机器5次 &#125;&#125; 自定义规则编写在自定义策略类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.atguigu.myrule;import java.util.List;import com.netflix.client.config.IClientConfig;import com.netflix.loadbalancer.AbstractLoadBalancerRule;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.Server;public class RandomRuleUserDefined extends AbstractLoadBalancerRule&#123; // total = 0 // 当total==5以后，我们指针才能往下走， // index = 0 // 当前对外提供服务的服务器地址， // total需要重新置为零，但是已经达到过一个5次，我们的index = 1 // 分析：我们5次，但是微服务只有8001 8002 8003 三台，OK？ // private int total = 0; // 总共被调用的次数，目前要求每台被调用5次 private int currentIndex = 0; // 当前提供服务的机器号 public Server choose(ILoadBalancer lb, Object key) &#123; if (lb == null) &#123; return null; &#125; Server server = null; while (server == null) &#123; if (Thread.interrupted()) &#123; return null; &#125; List&lt;Server&gt; upList = lb.getReachableServers(); List&lt;Server&gt; allList = lb.getAllServers(); int serverCount = allList.size(); if (serverCount == 0) &#123; /* * No servers. End regardless of pass, because subsequent passes only get more * restrictive. */ return null; &#125;// int index = rand.nextInt(serverCount);// java.util.Random().nextInt(3);// server = upList.get(index); // private int total = 0; // 总共被调用的次数，目前要求每台被调用5次// private int currentIndex = 0; // 当前提供服务的机器号 if(total &lt; 5) &#123; server = upList.get(currentIndex); total++; &#125;else &#123; total = 0; currentIndex++; if(currentIndex &gt;= upList.size()) &#123; currentIndex = 0; &#125; &#125; if (server == null) &#123; /* * The only time this should happen is if the server list were somehow trimmed. * This is a transient condition. Retry after yielding. */ Thread.yield(); continue; &#125; if (server.isAlive()) &#123; return (server); &#125; // Shouldn't actually happen.. but must be transient or a bug. server = null; Thread.yield(); &#125; return server; &#125; @Override public Server choose(Object key) &#123; return choose(getLoadBalancer(), key); &#125; @Override public void initWithNiwsConfig(IClientConfig clientConfig) &#123; // TODO Auto-generated method stub &#125;&#125; 策略类继承关系 Feign声明式Rest客户端，使得编写Web服务客户端更简单，可以与Eurek、Rebbon组合使用。 定义一个接口添加注解，即可使用。 Ribbon+RestTemplate：调用 依赖1234&lt;dependency&gt; &lt;groupId&gt;cn.springcloud.feign&lt;/groupId&gt; &lt;artifactId&gt;venus-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 接口+注解1234567891011121314//@FeignClient(value = "MICROSERVICECLOUD-DEPT",fallbackFactory=DeptClientServiceFallbackFactory.class) //熔断器类@FeignClient(value = "MICROSERVICECLOUD-DEPT")public interface DeptClientService&#123; @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) public Dept get(@PathVariable("id") long id); @RequestMapping(value = "/dept/list", method = RequestMethod.GET) public List&lt;Dept&gt; list(); @RequestMapping(value = "/dept/add", method = RequestMethod.POST) public boolean add(Dept dept);&#125; Controller123456789101112131415161718192021222324@RestControllerpublic class DeptController_Consumer&#123; @Autowired private DeptClientService service; @RequestMapping(value = "/consumer/dept/get/&#123;id&#125;") public Dept get(@PathVariable("id") Long id) &#123; return this.service.get(id); &#125; @RequestMapping(value = "/consumer/dept/list") public List&lt;Dept&gt; list() &#123; return this.service.list(); &#125; @RequestMapping(value = "/consumer/dept/add") public Object add(Dept dept) &#123; return this.service.add(dept); &#125;&#125; 集成了Rabbon，Ribbon+RestTemplate调用微服务 ==》接口+注解,调用接口的方式调用服务，即是在调用某个微服务的方式从使用RestTemplate的方式转为使用接口方式调用，Fegin还是可以使用Rabbon的负载均衡。 Hystrix处理分布式系统的延迟和容错的开源库，分布式系统中，服务调用不可避免会有调用失败、超时、异常出现，Hystrix保证在服务出现为题时，不会导致整体服务失败，避免级联故障，提高分布式系统的弹性。当某个服务出现故障，通关断路器的故障监控，向调用方法返回一个符合预期的、可处理的备选响应，而不是进行等待或抛出异常，保证调用线程不会长时间等待、返回无用信息，避免故障蔓延。 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 启用123456789101112@SpringBootApplication@EnableEurekaClient @EnableDiscoveryClient @EnableCircuitBreaker //对hystrix熔断机制的支持public class DeptProviderHystrix&#123; public static void main(String[] args) &#123; SpringApplication.run(DeptProviderHystrixp.class, args); &#125;&#125; Controller12345678910111213141516171819202122232425262728@RestControllerpublic class DeptController&#123; @Autowired private DeptService service = null; //调用服务方法失败并抛出了错误信息 //自动调用@HystrixCommand标注好的fallbackMethod调用类中的指定方法 @HystrixCommand(fallbackMethod = "processHystrix_Get") @RequestMapping(value = "/dept/get/&#123;id&#125;", method = RequestMethod.GET) public Dept get(@PathVariable("id") Long id) &#123; Dept dept = this.service.get(id); if (null == dept) &#123; throw new RuntimeException("该ID：" + id + "没有没有对应的信息"); &#125; return dept; &#125; //类似异常通知 public Dept processHystrix_Get(@PathVariable("id") Long id) &#123; return new Dept().setDeptno(id).setDname("该ID：" +id + "没有没有对应的信息,null--@HystrixCommand") .setDb_source("no this database in MySQL"); &#125;&#125; 熔断机制，当微服务在某个服务处发生了超时、异常时，由Hystrix返回一个结果，结果符合调用服务者的要求。举例实际使用，需要重写FallbackFactory接口并在Feign注解中配置fallbackFactory，即可实现异常处理与业务模块分离，解耦和。 服务降级服务降级在客户端完成，暂时关闭服务，为其他服务节省资源，当服务关闭后，Hystrix依旧会为接口调用时返回一个信息。 123456789101112131415161718192021222324252627282930//实现FallbackFactory接口@Component public class DeptClientServiceFallbackFactory implements FallbackFactory&lt;DeptClientService&gt;&#123; @Override public DeptClientService create(Throwable throwable) &#123; return new DeptClientService() &#123; @Override public Dept get(long id) &#123; return new Dept().setDeptno(id).setDname("该ID：" + id + "没有没有对应的信息") .setDb_source("no this database in MySQL"); //,Consumer客户端提供的降级信息,此刻服务Provider已经关闭 &#125; @Override public List&lt;Dept&gt; list() &#123; return null; &#125; @Override public boolean add(Dept dept) &#123; return false; &#125; &#125;; &#125;&#125; HystrixDashboard服务监控，持续记录通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展现给用户，即微服务的图形化监控。 ####依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; 主类123456789@SpringBootApplication@EnableHystrixDashboardpublic class DeptConsumerDashBoard&#123; public static void main(String[] args) &#123; SpringApplication.run(DeptConsumerDashBoard.class, args); &#125;&#125; 服务1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 监控指标 Delay：轮询监控信息的延迟事件，默认2000毫秒 Title：监控标题 失败 超时 成功 错误请求 拒绝 短路 错误 Zuul路由网关路由功能，对外部请求进行转发，即外部访问与服务的路由网关，提供过滤、路由功能，将以一个服务注册到Eureka中，同时实现网关功能，可以配置其他服务的路由访问规则。 依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; 配置1234567891011121314151617181920212223242526server: port: 9527 //server_port //服务将通过路由进行访问 spring: application: name: microservicecloud-zuul-gateway eureka: client: service-url: defaultZone: eureka-ip instance: instance-id: intance_id prefer-ip-address: true zuul: //服务地址映射定义 #ignored-services: microservicecloud-dept //过滤服务地址访问 prefix: /prefix //公共前缀 ignored-services: "*" //过滤全部服务地址 routes: mydept.serviceId: microservicecloud-dept mydept.path: /myurl/** info: 分布式配置中心针对当出现大量的微服务时，提供一个配置中心，对微服务的配置进行集中管理。 服务端 在github中创建一个库并保存地址 在本地创建库并克隆创建的库 创建文件配置文件application.yml（UTF-8） 提交文件 1234567891011server: port: 3344 spring: application: name: microservicecloud-config cloud: config: server: git: uri: *:*.git #GitHub上面的git仓库名字 客户端#####bootstrap.xml 123456789spring: cloud: config: name: microservicecloud-config-client #需要从github上读取的资源名称， #注意没有yml后缀名 profile: test #本次访问的配置项 label: master uri: ip/url:3344 #本微服务启动后先去找3344号服务， #通过SpringCloudConfig获取GitHub的服务地址 依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring 教程</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>微服务</tag>
        <tag>框架整合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8]]></title>
    <url>%2F2018%2F08%2F17%2FJava-8%2F</url>
    <content type="text"><![CDATA[Java8具有更快的运行速度，对底层的数据结构进行了修改，编程书写代码更少，提供了更加便利的Stream API，使用并行更简单，减少了空指针异常的产生，提供了一个容器类减少空指针异常。 Lambda 表达式简介一种匿名函数，类似一段可以传递的代码，将代码像传递数据一样在程序中进行传递。Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。 示例123456789101112131415161718192021public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println("This is a inner class"); &#125; &#125;; //匿名内部类 Thread thread = new Thread(runnable); thread.start(); Runnable runnable_new = () -&gt; System.out.println("This is a Lambda!"); Thread thread_new = new Thread(runnable_new); thread_new.start(); System.out.println("------------------"); &#125;&#125; 语法Lambda表达式中引入了 -&gt; 操作符，箭头操作符的左侧对应参数列表，箭头右侧为需要执行的功能，需要“函数式接口”支持，即接口中只有一个抽象方法，可以使用@FuctionalInterface修饰，加强检查。 12345678910111213141516171819202122232425262728293031323334int i = 8；Runnable runnable = () -&gt; System.out.println("This is implement" + i);@FunctionalInterfacepublic interface Test&lt;T,R&gt;&#123; public void method(); public void method(int i); public int method(int i,int j); public boolean method(int i,float j); public R method(T t1,T T2);&#125;//仅作为举例 以下对每种情况具体进行了实现。Test test;//无参无返回值test = () -&gt; System.out.println("This is implement");//单个参数无返回值test = (i) -&gt; System.out.prinln("This is i" + i);test = x -&gt; System.out.println("This is i" + i);//两个参数返回值Test test = (i,j) -&gt; &#123; System.out.prinln("This is i" + i); System.out.prinln("This is i" + j); return i+j;&#125;//多个参数单条语句返回值Test test = (i,j) -&gt; i+j;Teat test =(int i,float j) -&gt; !(i+j);//泛型(i,j) -&gt; i+j; 函数式接口Lambda表达式需要依赖函数式接口，因此，Java8中内置了多种接口，简介四种核心函数式接口。 消费型接口12Consumer&lt;T&gt; void accept(T t); 提供型接口12Supplier&lt;T&gt; T get(); 函数式接口12Function&lt;T,R&gt; R apply(T t); 判断型接口12Predicate&lt;T&gt; boolean test(T t); 其他接口123456789101112131415161718BiFunction&lt;T,U,R&gt; R apply(T t,U u);UnaryOperator&lt;T&gt; T apply(T t);BinaryOperator&lt;T&gt; T apply(T t1,T t2);ToIntFunction&lt;T&gt;ToLongFunction&lt;T&gt;ToDubleFunction&lt;T&gt;//返回int、long、doubleIntFunction&lt;R&gt;LongFunction&lt;R&gt;DoubleFunction&lt;R&gt;//返回R 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void hello(String name,Consumer&lt;String&gt; consumer)&#123; consumer.accept(name); &#125; public String getDate(String data, Supplier&lt;String&gt; supplier)&#123; return data +": "+ supplier.get(); &#125; public String resoleString(String string, Function&lt;String,String &gt; function) &#123; return function.apply(string); &#125; public List&lt;String&gt; filterString(List&lt;String&gt; list,Predicate&lt;String&gt; predicate)&#123; List&lt;String&gt; stringList= new ArrayList&lt;&gt;(); for (String string : list)&#123; if(predicate.test(string))&#123; stringList.add(string); &#125; &#125; return stringList; &#125; @Test public void test()&#123; hello("Wang",(name) -&gt; System.out.println("Hello ! I am " + name)); ///////////////////////////////////////////////////////////////////////////////////////////////////////////// String now = getDate("Now",() -&gt; &#123; Date d = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return sdf.format(d); &#125;); System.out.println(now); ///////////////////////////////////////////////////////////////////////////////////////////////////////////// System.out.println("\tThis is a String with blank! "); String result = resoleString("\t\t\tThis is a String with blank! ", (string) -&gt; string.trim()); result = resoleString(result, (string) -&gt; string.substring(5,20)); System.out.println(result); ///////////////////////////////////////////////////////////////////////////////////////////////////////////// List&lt;String&gt; list = Arrays.asList("1234","abcd","http","a","Java and Oracle"); list = filterString(list,(s) -&gt; s.length() &gt; 5); for (String string : list) System.out.println(string); &#125; 方法引用与构造器引用Lambda 体中已经实现了的方法，可以进行使用，使用中只要遵循接口参数列表与构造或方法的参数返回值对应即可，带给你全新的体验。 对象 :: 实例方法名 类 :: 静态方法名 类 :: 实例方法名 1234567891011121314Consumer&lt;String&gt; consumer = (x) -&gt; System.out.println(x);Consumer&lt;String&gt; consumer = System.out::println;//实现方法的参数列表和引用方法必须保持一致Integer integer = new Integer(10);Supplier&lt;Integer&gt; supplier = integer::toString; Supplier&lt;ExecutorService&gt; serviceSupplier= Executors::newCachedThreadPool;BiPredicate&lt;String,String&gt; predicate = String::equals; //等效于（x,y） -&gt; x.equals(y);/* 哈哈哈 这还是Java吗？ 哈哈哈*/// a.method(b) 才可使用 类名 :: new 123456Supplier&lt;Integer&gt; integer = Integer::new;//无参构造器Function&lt;int,Integer&gt; integer = Integer::new;//一个参数构造器//构造器的选择取决于Function中的方法参数，参数列表与构造器必须对应！ 类型 :: new 123Function&lt;Integer,String[]&gt; function = (10) -&gt; new String[x];Function&lt;Integer,String[]&gt; function = String[]::new; Stream APIStream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本Iterator。原始版本的Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换，数据源本身可以是无限的。 获取方式 从 Collection 和数组 Collection.stream() Collection.parallelStream() 并行流！在执行迭代时是多线程完成的！ Arrays.stream(T array) or Stream.of() 从 BufferedReader java.io.BufferedReader.lines() 静态工厂 java.util.stream.IntStream.range() java.nio.file.Files.walk() 自己构建 java.util.Spliterator 其他方式 Random.ints() BitSet.stream() Pattern.splitAsStream(java.lang.CharSequence) JarFile.stream() 示例123456789101112131415//使用方法 List&lt;String&gt; list = Arrays.asList("1234","abcd","http","a","Java and Oracle"); Stream&lt;String&gt; stream = list.stream(); int[] ints = new int[20]; IntStream intStream = Arrays.stream(ints); final Stream&lt;int[]&gt; intsStream = Stream.of(ints); Stream&lt;Integer&gt; integerStream = Stream.iterate(0, (seed) -&gt; seed+2); integerStream.limit(10).forEach(System.out::println); Stream.generate(() -&gt; Math.random()).limit(10).forEach(System.out::println); 中间操作 123456789101112131415161718192021222324252627282930313233343536373839404142/*过滤、切片*/filter从流中排除指定元素limit截断流，限定流中元素个数skip(n)跳过n各元素，超过流元素个数，这返回空流distinct()去除重复元素//链式调用中未执行终止操作时（forEach（...）），不会执行任何操作。//当结果已经满足条件，则不继续执行后方筛选条件，即具备短路特点。/*映射*/map(Function&lt;T t,R r&gt;)将函数应用到每个元素中，并将结果映射为一个新的参数flatmap经函数作为参数应用到每个元素上，返回流连接形成的新流。/*排序*/sorted()sorted((a,b) -&gt; a&gt;b?a:b) /* 想到前段时间阿里的面试题 * 一个巨大的数组统计每个数字的出现次数 */@Testpublic void testMap()&#123; int a[]=new int[1000]; for(int i=0;i&lt;10000;i++)&#123; a[i]=(int) ( Math.random() *100 ); &#125;//模拟数组 final IntStream stream = Arrays.stream(a); stream.distinct().sorted().forEach((i) -&gt;&#123; System.out.print("This is "+i+ " count : "); long count = Arrays.stream(a).filter((num) -&gt; num == i).count(); System.out.print(count +"\n"); &#125;); &#125; 终止操作1234567891011121314151617181920212223242526272829303132333435##查找匹配allMach#是否匹配所有元素anyMatch#至少匹配一个元素noneMatch#是否没有匹配所有元素findFirst#返回匹配的第一个元素findAny#随机返回一个元素count#统计元素个数max#返回最大元素min#返回最小元素##归约reduce(初始值，（下一次执行初始值，流中的元素))Optional&lt;Double&gt; option = employees.stream().map(Employee::getSalary).reduce(Double::sum);#####map-reduce模式######将流中的元素反复匹配执行操作##收集collect#按照一定方式，进行结果收集，即将结果收集起来，可以使用一个工具类Collectorsemployee.stream().map(Employee::getNmae).collect(Collectors.toList());#最终返回值一个List&lt;String&gt; 列表,存储姓名属性Collectors.groupby#分组Collectors.summarizingDoutble#数据处理方式Collectors.joining#字符串 Fork/Join框架将任务分拆成多个小任务，细分到无法再继续分，执行后将所有的结果进行合并得到结果，在并发包的文章里，有写到过，也举了一个计算的例子，这个框架的特点就是，当任务进行拆分后，采用工作窃取模式，可以提高计算时对CPU的利用率。工作窃取模式即当前队列无法获取任务时，将去一个其他拆分队列的任务进行执行。 并行流12List.stream().parallelStream()//执行处理时底层使用Fork/Join框架 接口默认方法与静态方法原接口中只能有全局静态常量和抽象方法，在java8中可以给接口添加添加默认方法。默认方法冲突时继承大于实现，多实现必须重写冲突默认方法。接口可以书写静态方法，使用时，直接使用接口对象调用。 12345678public interface NewInterface&#123; default String getDefaultMethod()&#123; return "This is a default Method"; &#125; public static void getStaticMethod()&#123; System.out.println("This is a static method from a interface !"); &#125;//NewInterface.getStaticMethod()&#125; 时间API原时间相关api存在线程安全问题，使用起来较为复杂，java8中添加全新的时间api，多线程可以直接使用，线程安全。 12345678910java.time#日期java.time.chrono#特殊时间记录方式java.time.format#日期格式化java.time.temporal#运算推算日期java.time.zone#时区相关设置 操作123456789101112131415161718192021222324252627282930313233//使用时间@Testpublic void testNewDate()&#123; //LocalDate LocalTime LocalDateTime LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDateTime); ----------------------------------- localDateTime = LocalDateTime.of(2018,9,13,23,44); System.out.println(localDateTime); ----------------------------------- localDateTime = localDateTime.plusYears(2); System.out.println(localDateTime); ----------------------------------- localDateTime = localDateTime.minusYears(2); System.out.println(localDateTime);&#125;//时间戳@Testpublic void testTimeInstant()&#123; //Unix 1970.1.1 0.0.0 到现在毫秒 协调世界时 Instant instant = Instant.now(); //设置时间偏移量 instant.atOffset(ZoneOffset.offHours(8)); //获取毫秒 System.out.println(instant.toEpochMilli()); //运算 Instant.ofEpochSecond(60)；//1971.1.1 0.1.0 //计算间隔 Duration duration = Duration.between(instant_end , instant_begin); Period period = Period.between(localDate_end , localDate_begin); &#125; 其他注解java8中可以对方法进行重复注解。 12345678910111213@Repeatable(MoreAnnotations.class)public @interface MoreAnnotation&#123; String value9() default "注解"；&#125;public @interface MoreAnnotations&#123; MoreAnnotation[] values();&#125;@MoreAnnotation@MoreAnnotation@MoreAnnotationpublic void method()&#123;&#125; 类型注解12private @NonNull Object obj = null//不支持 HashMap碰撞产生的链表在长度大于8时将会产生红黑树 ConcurrentHashMap原16段并发锁改为CAS算法，同时也具备红黑树。 内存模型]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 8</tag>
        <tag>函数式编程</tag>
        <tag>Lambda</tag>
        <tag>流式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2018%2F07%2F30%2FRedis%2F</url>
    <content type="text"><![CDATA[RedisRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 基本命令12redis-server redis.conf 启动命令 后跟配置文件位置redis-cli -p 6379 默认端口为6379 数据库基本操作1234567redis-cli -p 6379 进入数据库select [num] 选择库DBSIZE 查看key数量FLUSHDB 清空当前库FLUSHALL 清空所有库默认端口6379 默认16个库 五大数数据类型String 基本数据类型，一个key对应一个value 二进制安全，可以包含任何数据（图片或序列化对象） 最大值为512M Hash 键值对集合 String类型的field和value的映射表，适合存储对象 类似Java中的 Map&lt;String,Object&gt; List 简单的字符串列表，按照插入顺序排序。 可以添加元素到头部或尾部 底层为链表 Set 无序无重复集合 通过底层为HashTable Zset sorted set 每个元素关联一个double类型的分数排序 常用命令​ key 123456789101112keys *#查看所有keyexists [key_name]#判断key是否存在move [key_name] [db_num]#移动key到某个库expire [key_name] [时间s]#设置key过期时间 单位秒ttl [key_name]#查看过期时间type [key_name]#查看key类型 ​ String 123456789101112set/get/del/append/strlen#数据操作Incr/decr/incrby/decrby#自增自减 自增自减某值 数字getrange/setrange#设置/获取子串setex &lt;setex k1 10 v4&gt;#设置过期时间sentnx#避免覆盖添加值mset/mget/msetnx#批量设置获取（重复失效） ​ List 123456789101112131415161718Lpush/Rpush/Lrange#左右进入\查看 左栈右队Lpop/rpop#出栈\出队Lindex#按照索引获取Llen#获取长度Lren key [n] [value]#删除多个值Ltrim key#截取子串Rpoplpush [list_org] [list_dist]#出队压栈Lset key index value#给某位置赋值Linsert key befor/after ""#在某字符前/后插值 ​ Set 123456789101112131415161718sadd #不重复/重复自动去除smemebers #查看集合所有元素sismember #检测是否为成员scard #获取集合元素个数srem key value #删除元素srandmember key int #随机出N个整数spop key #随机出栈smove key1 key2 #随机出一个值给集合sdiff/sinter/sunion #差集/交集/并集 ​ Hash 12345678910111213141516hset/hget/hmset/hmget/hgetall/hdel #获取添加移除单个/多个customer： id: 11 name: Lee age: 20hmset customer id 11 name Lee age 20hle #获取长度hexists key #获取某个keyhkeys/hvals #获取键\值hincrby/hincrbyfloat #自增某个值hstnx #避免覆盖插值 ​ Zset 123456789101112131415161718zadd/zrange #添加/查看zdd zset 1 v1 2 v2 3 v3zrangbyscore [begin_s] [end_s] #区域查看（不包含 limitzrem key #删除某个值zcard/zcount #统计个数zrank #取值的下表zscore #取值的分数zrevrank #取下标zrevrangezrevrangebyscore #结束分数到开始分数 配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#守护进程方式daemonize yes#默认写入pidpidfile /var/run/redis_6379.pid#默认端口port 6379# include /path/to/other.confbind 127.0.0.1#超时关闭连接timeout 0#日志级别# Specify the server verbosity level.# This can be one of:# debug (a lot of information, useful for # development/testing)# verbose (many rarely useful info, but not a mess like the # debug level)# notice (moderately verbose, what you want in production # probably)# warning (only very important / critical messages are # logged)loglevel notice# output for logging but daemonize, logs will be sent to # /dev/nulllogfile &quot;&quot;#默认数据库数量databases 16#同步数据文件save &lt;seconds&gt; &lt;changes&gt;#默认提供三个条件 1 in 900s 10 in 300 1000 in 60save 900 1save 300 10save 60 10000#缓存级别# volatile-lru -&gt; Evict using approximated LRU among the # keys with an expire set.# allkeys-lru -&gt; Evict any key using approximated LRU.# volatile-lfu -&gt; Evict using approximated LFU among the # keys with an expire set.# allkeys-lfu -&gt; Evict any key using approximated LFU.# volatile-random -&gt; Remove a random key among the ones with# an expire set.# allkeys-random -&gt; Remove a random key, any key.# volatile-ttl -&gt; Remove the key with the nearest expire# time (minor TTL)# noeviction -&gt; Don&apos;t evict anything, just return an error# on write operations.# maxmemory-policy noeviction#数据库路径dir ./#默认密码# requirepass foobared#默认最大连接数# maxclients 10000#最大内存# maxmemory &lt;bytes&gt; 持久化RDB（Redis Database）在指定时间间隔内将内存中的数据集快照写入磁盘中即Snapshot快照，恢复时直接将快照导入内存。 持久化由Fork进程进行，主进程不进行IO擦破做，对数据完整性不敏感，最后一次持久化的数据可能丢失。 Fork为原进程的复制，所有数据与原进程完全一致，并作为原进程的子进程。 保存形式为 dump.rdb 配置 1234567891011121314151617181920212223242526272829303132333435363738############### SNAPSHOTTING ############################ Save the DB on disk:## save &lt;seconds&gt; &lt;changes&gt;# In the example below the behaviour will be to save:# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changed## Note: you can disable saving completely by commenting# out all &quot;save&quot; lines.## It is also possible to remove all the previously # configured save# points by adding a save directive with a single empty # string argument like in the following example:# save &quot;&quot; #save 命令可手动保存（阻塞式） bgsave 异步不阻塞# 在设置时间内改动后自动分片存储，触发快照，备份文件自动恢复save 900 1save 300 10save 60 10000#恢复文件位置dir ./#默认恢复文件# The filename where to dump the DBdbfilename dump.rdb#数据一致性stop-writes-on-bgsave-error yes#压缩算法使用rdbcompression yes#数据校验（为增加性能可关闭 不推荐关闭）rdbchecksum yes 优点：适合大规模的数据恢复，对数据完整性和一致性要求不高 缺点：意外宕机只有最后一次快照，fork进程导致两倍程序消耗 AOF（Append Only File）通过日志的形式记录每个写操作。 12345678910111213141516171819202122#默认关闭appendonly no#默认文件名appendfilename &quot;appendonly.aof&quot;# Redis supports three different modes:## no: don&apos;t fsync, just let the OS flush the data when it # wants. Faster. #不设置# always: fsync after every write to the append only log.# Slow, Safest. #总是使用# everysec: fsync only one time every second. Compromise.# The default is &quot;everysec&quot; #默认。appendfsync everysec#重写时运用appendsyncno-appendfsync-on-rewrite no#重写比例和重写日志大小auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb #通常3GB+ 优点：每秒同步 修改同步 不同步 缺点：恢复速度慢 存储空间大 推荐使用两种共用，启动时优先载入AOF备份，AOF数据丢失不超过2秒的数据 事务串行执行一组命令，命令会被序列化，不许阻塞，即一个事务。没有隔离级别的概念，不保证原子性，没有回滚，部分支持事务。 基本命令12345DISCARD 放弃事务EXEC 执行事务块MULTI 标记开始UNWATCH 取消监视所有键WATCH KEY [key ...] 开启监视 事务使用步骤MULTI //开启事务，返回OK Operationes //入队不操作，返回QUEUE，出现错误直接取消 EXEC/MULTI //执行或取消执行，单个语句出错，其他可以执行 WATCH监控 1234567悲观锁：如表级锁，当修改时加锁，其他修改无法执行（高一致，低并发）乐观锁：不锁+版本号 在修改时读取版本号，执行修改时版本号&gt;=读取时版本CAS：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。 WATCH使用步骤WATCH balance MULTL Operations EXEC //乐观锁已经被修改的版本将无法执行事务 //执行后锁已被清除 已被修改 --&gt; UNWATCH取消监控 --&gt; WATCH --&gt; 发布与订阅进程间的一种消息通信模式：发送者（pub）与订阅者（sub） 主题模式 使用命令123456PSBUSCRIBE pattern[pattern ...] 订阅PUBSUB subcommand[arg [arg]] 查看订阅状态PUBLISH channel message 发布消息到主题PUNSUBSCRIBE pattern 取消订阅SUBSCRIBE channel[channel ...] 订阅多个UNSUBSCRIBE[channel[channel]] 退订多个 使用步骤订阅消息即进入消息监听状态，消息发布时自动接收消息 发布者发布消息到对应频道，消息监听处即受到消息 主从复制配置方法12info replication 查看数据库信息SLAVEOF IP Port 隶属于主机 info replication12345678910111213#从机role:slavemaster_host:127.0.0.1master_port:6379#主机role:masterconnected_slaves:2slave0:ip=127.0.0.1,port=6381,state=online,offset=1321,lag=0slave1:ip=127.0.0.1,port=6380,state=online,offset=1321,lag=1#主机可读可写、从机可读不可写#只需要在从机上使用命令SLAVEOF IP port 命令即可#从机可以访问所有缓存中数据 主机宕机后可重开 从机依旧 反之不行 中心化配置，主机宕机系统瘫痪，从机宕机需要重新配置，一主二从。 SLAVEOF no one将从机转换为主机，从机需要重新配置 复制原理首次全量复制，而后增量复制，重连全量复制。 哨兵模式创建`sentinel.conf`配置文件，加入哨兵监视器 12sentinel monitor host-main 127.0.0.1 6379 1 监视名 IP 端口 票数 命令启动:`redis-sentinel sentinel.conf` 自动监视，当主机宕机自动选举主机，原主机恢复后自动设置为从机待机 缺点： 有延迟，当系统使用高时，延迟现象比较严重 Java中使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Jedis jedis = new Jedis(url,port);//事务Transaction transaction = jedis.multi();transaction.set(); ...transaction.discard(); //取消执行//开启watchint now;jedis.watch("key");int value = Integer.paraseInt(jedis.get("key"));if(value &lt; now)&#123; jedis.unwatch(); soutp("redo"); return false&#125;else&#123; Transaction tr = jedis.multi(); transaction.method("",""); transaction.exex()&#125;jedis.unwatch();//主从复制Jedis jedis_master = new Jedis(url,port);Jedis jedis_salve = new Jedis(url,port);//主从复制 读写分离jedis_salve.slaveof(url,port);jedis_master.set(...);String result = jedis_salve.get(...);//JedisPoolpublic class JedisPoolUtil&#123; private static volatile JedisPool jedisPool = null; private JedisPoolUtrl()&#123;&#125; public static JedisPool getJedisPoolInstance() &#123; if(null == jedisPool) &#123; synchronized (JedisPoolUtil.class) &#123; if(null == jedisPool) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.set(...); jedisPool = new JedisPool(poolConfig,url,port); return JedisPool; &#125; &#125; &#125; &#125; public static voie relase(JedisPool jedisPool,Jedis jedis) &#123; if(null != jedis) &#123; jedisPool.returnResourceObject(jedis); &#125; &#125;&#125; ​]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>搭建服务器</tag>
        <tag>服务器操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 使用详解]]></title>
    <url>%2F2018%2F06%2F27%2FMybatis-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MyBatis 本是apache的一个开源项目iBatis 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 官方地址 简介使用123456789101112131415161718192021&lt;!--全局配置文件 mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;!-- 对应配置文件路径 * --&gt;&lt;/mappers&gt; &lt;/configuration&gt; 12345678910&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 对应接口全类名位置 ## --&gt; &lt;!-- 对应接口方法 ### --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; 12345//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlog(Integer id);&#125; Mybatis底层与数据库交互是使用SqlSession完成的，SqlSession非线程安全，每次使用应当获取新对象，mapper接口的实现由mybatis生成一个代理对象。 123456789public void test()&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();SqlSession session = sqlSessionFactory.openSession(); try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(1); &#125; finally &#123; session.close(); &#125; &#125; 全局配置文件properties标签1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;properties resource="db.properties" url="网络路径/本地路径"&gt;&lt;/properties&gt; &lt;!--resource:类路径 url：网络路径/本地路径 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 12345#db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mydql://localhost:3306/dbjdbc.username=usernamejdbc.password=password settings标签12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCaseEnables " value="true" /&gt; &lt;!-- 驼峰命名适配 --&gt; &lt;setting name="jdbcTypeForNull" value="null"/&gt; &lt;!-- 空值映射为null --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 懒加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;!-- 按需加载 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!--开启二级缓存 --&gt; &lt;/settings&gt;&lt;/configuration&gt; typeAliases标签12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="org.mybatis.example.bean.Blog" alias="blog"&gt;&lt;/typeAlias&gt; &lt;!-- mapper中就不用写全类名了，不写alias即默认为类名--&gt; &lt;package name="org.mybatis.example.bean"/&gt; &lt;!--当前包及其子包自动别名--&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 123456&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- blog 别名使用--&gt; &lt;select id="selectBlog" resultType="blog"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; 1234567//通过@Alias注解使用别名//批量扫描注解优先@Alias("blog")public class Blog&#123; private Integer id; ...&#125; Alias(默认别名) Mapped Type _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map plugins插件在四大对象执行前后进行拦截，原理为动态代理。 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments标签123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;!--指定默认使用环境来快速切换环境--&gt; &lt;environment id="env"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 事务管理器 type: JDBC|MANAGED 自定义 --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 数据源配置 type：UNPOOLED|POOLED|JNDI 自定义--&gt; &lt;property name="driver" value="$&#123;oracle.driver&#125;"/&gt; &lt;property name="url" value="$&#123;oracle.url&#125;"/&gt; &lt;property name="username" value="$&#123;oracle.username&#125;"/&gt; &lt;property name="password" value="$&#123;oracle.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; databaseIdProvider标签12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="env"&gt; &lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt;&lt;/configuration&gt; 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 发送带oracle的查询语句 --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" databsesId="oracle"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" databsesId="mysql"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; mapper标签12345678910111213141516&lt;!--全局配置文件 mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;mappers&gt; &lt;mapper url=""&gt;&lt;/mapper&gt; &lt;!-- 磁盘路径 --&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;!-- 类路径 --&gt; &lt;mapper class="org.mybatis.example.dao.BlogMapperAnnotation"/&gt; &lt;!--1. mapper和接口 同名同路径--&gt; &lt;!--2. 添加注解方法的接口--&gt; &lt;package name="org.mybatis.example.dao"/&gt; &lt;!-- 批量扫描 xml 接口 同包 --&gt; &lt;/mappers&gt; &lt;/configuration&gt; 123456//org.mybatis.example.dao.BlogMapperAnnotationpublic interface BlogMapperAnnotation&#123; // 对应mapper中方法 ### @Select("select * from Blog where id = #&#123;id&#125;") public Blog selectBlog(Integer id);&#125; 映射文件CRUD123456789//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlog(Integer id); public boolean insertdBlog(Blog blog); public Integer updateBlog(Blog blog); public boolean deleteBlog(Integer id); //自动返回 Integer 、Long、Boolean 类型&#125; 12345678910111213141516171819202122&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog set ... 字段 = #&#123;属性名&#125; where 字段 = #&#123;属性名&#125; &lt;/update&gt; &lt;delete id="deleteBlog"&gt; delete from Blog where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 自增主键123456789101112131415161718192021222324252627282930313233&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- mysql 等支持 自增主键 数据库--&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" useGeneratedKeys="true" keyProperty="#&#123;id&#125;" databaseId="mysql"&gt; &lt;!-- 使用自增主键策略 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;!-- Oracle 从序列中获取 111--&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" databaseId="oracle"&gt; &lt;selectKey KeyProperty="#&#123;id&#125;" order="BEFORE" resultTyoe"Integer"&gt; &lt;!-- 使用查询序列 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; select Blog_sql.nextval from dual &lt;/selectKey&gt; insert into Blog...values(#&#123;id&#125;,#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;!-- Oracle 从序列中获取 222 多条问题 --&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" databaseId="oracle"&gt; &lt;selectKey KeyProperty="#&#123;id&#125;" order="AFTER" resultTyoe"Integer"&gt; &lt;!-- 使用查询序列 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; select Blog_sql.currval from dual &lt;/selectKey&gt; insert into Blog...values(Blog_sql.nextval,#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;/mapper&gt; 参数处理多参数时，参数会封装成map，可以使用注解指定参数的关键字(key)。 123456789101112131415//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlogById(Integer id); public Blog selectBlogByIdAndName(@Param("id")Integer id,@Param("name")String name); public Blog selectBlogByPojo(Blog blog); public Blog selectBlogByMap(Map&lt;String,Object&gt; map); public Blog selectBlogByCollection(List&lt;Integer&gt; list);&#125;Page&#123; int index； int size; List&lt;Blog&gt; list;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 单个参数 --&gt; &lt;!-- 当只有单个参数时，不会有任何处理 #&#123;任意填写&#125; 都可以取出参数--&gt; &lt;select id="selectBlogById" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 多个参数 --&gt; &lt;!-- 未指定参数名 --&gt; &lt;!-- 使用多个参数时，入参会被处理，参数会被封装为一个map--&gt; &lt;!-- 取值所用的key为 [ param1 ... paramN 0... n ]--&gt; &lt;select id="selectBlogByIdAndName" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;param1&#125; and name = #&#123;param2&#125; &lt;/select&gt; &lt;!-- 使用@Param（""） 注解指明接口中的参数后可以直接取用--&gt; &lt;!-- 原取参数规则仍旧适用 --&gt; &lt;select id="selectBlogByIdAndName" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入pojo --&gt; &lt;!-- 直接取用即可 --&gt; &lt;!-- 多参数包含对象时 param2.id 或注解后 blog.id --&gt; &lt;select id="selectBlogByPojo" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入 map --&gt; &lt;!-- 直接取用 按照存入map时的key 即取用的 key 和 存入map时 key 相同 --&gt; &lt;select id="selectBlogByMap" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入集合类型 --&gt; &lt;!-- 取出第一个参数 集合类型取参数使用 collection[0] 数组类型取参数使用 list[0] --&gt; &lt;select id="selectBlogByMap" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;list[0]&#125; &lt;/select&gt; &lt;/mapper&gt; $与#区别1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = $&#123;name&#125;&lt;/select&gt; &lt;!-- 执行Sql：select * from Blog where id = ? and name = blog_01 --&gt; &lt;!-- #&#123;&#125; 采用预编译形式 可以防止sql注入发生 $&#123;&#125; 采用字符串拼串方式 可能被注入 --&gt; select * from $&#123;year&#125;_Blog where id =#&#123;id&#125; //分表 select * from Blog order by $&#123;name&#125; $&#123;order&#125; where id = #&#123;id&#125; //排序&lt;/mapper&gt; #{} 取值时可以对参数进行限定javaType、jdbcType、mode、numbericScale、resultMap、typeHandler、jdbcTypeName 12345&lt;!-- 部分数据库在字段为null 可能无法识别mybatis传入的null值 --&gt;&lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog values(#&#123;id&#125;，#&#123;name,jdbcType=Null&#125;) &lt;!-- name 为空 Oracle 数据库正常 默认映射为 jdbcType.OTHER --&gt;&lt;/insert&gt; 返回值处理123456public interface BlogMapper&#123; public List&lt;Blog&gt; selectBlogByName(String name); public Map&lt;Stirng,Object&gt; selectBlogMap(Integer id); @MapKey("id") public Map&lt;Stirng,Blog&gt; selectBlogMaps(String name);&#125; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlogByName" resultType="org.mybatis.example.bean.Blog"&gt; &lt;!-- 返回为列表 返回类型为集合元素类型 Blog--&gt; select * from Blog where name like #&#123;name&#125; &lt;/select&gt; &lt;select id="selectBlogMap" resultType="map"&gt; &lt;!-- 返回值为map 返回类型为 map --&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectBlogByName" resultType="org.mybatis.example.bean.Blog"&gt; &lt;!-- 返回为map&lt;String,Blog&gt; 返回类型为集合元素类型 Blog--&gt; &lt;!-- 接口使用注解修饰 @MapKey("id") 标注map的key使用哪个字段 --&gt; select * from Blog where name like #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; resultMap自定义结果集 12345678910111213141516&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--自定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result colume="regist_time" property="reistTime"/&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 级联查询 1234567891011121314151617&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--级联查 属性 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="group_id" property="group.id"&gt; &lt;result column="group_name" property="group.name"&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog b,Group g where b.id = g.id and b.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; association12345678910111213141516171819&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--级联查 联合 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;association property="org.mybatis.example.bean.Group"&gt; &lt;id column "group_id" property="id"/&gt; &lt;result column="group_name" property="name"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select (distinct)* from Blog b,Group g where b.id = g.id and b.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 分步查询 12345678910111213141516171819&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 联合 分步查询 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;association property="group" select="org.mybatis.example.dao.GroupMapper.getGroupById" column="group_id"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog &lt;/select&gt; &lt;/mapper&gt; 懒加载 12345&lt;!-- 分步查询的条件下 在全局配置文件中开启懒加载 按需加载等功能 即可--&gt;&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;!-- 懒加载 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;!-- 按需加载 --&gt; collection1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.GroupMapper"&gt; &lt;resultMap type="org.mybatis.example.bean.Group" id="CustomizeGroup"&gt; &lt;id column="group_id" property="id"/&gt; &lt;result column="group_name" property="name"/&gt; &lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 一个组中包含多个Blog --&gt; &lt;select id="selectBlog" resultMap="CustomizeGroup"&gt; select * from Group g left join Blog b on g.id = b.id where g.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 分步查询 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.GroupMapper"&gt; &lt;resultMap type="org.mybatis.example.bean.Group" id="CustomizeGroup"&gt; &lt;id column="group_id" property="id"/&gt; &lt;result column="group_name" property="name"/&gt; &lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog" select="org.mybatis.example.dao.GroupMapper.selectBlogByGroupId" column="id"&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 一个组中包含多个Blog --&gt; &lt;select id="selectBlog" resultMap="CustomizeGroup"&gt; select * from Group &lt;/select&gt; &lt;/mapper&gt; 懒加载 123456&lt;!-- 同上一个示例 --&gt;&lt;!-- 分步查询的条件下 在全局配置文件中开启懒加载 按需加载等功能 即可--&gt;&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;!-- 懒加载 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;!-- 按需加载 --&gt; 传递多参 手动懒加载 12345&lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog" select="org.mybatis.example.dao.GroupMapper.selectBlogByGroupId" column="&#123;group_id = id&#125;" fetchType="lazy"&gt; &lt;!-- column="&#123;key1=column1,key2=column2&#125; fetchType="lazy|eager"--&gt;&lt;/collection&gt; discriminator1234567891011121314151617181920212223242526272829&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 联合 分步查询 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;discriminator javaType="sex" column="string"&gt; &lt;case value="0" resultType=""&gt; &lt;association property="group" select="org.mybatis.example.dao.GroupMapper.getGroupById" column="group_id"&gt; &lt;/association&gt; &lt;/case&gt; &lt;case value="1" resultType="org.mybatis.example.bean.Blog"&gt; &lt;result column="sex" property="name"/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog &lt;/select&gt; &lt;/mapper&gt; 动态SQLIF标签1234567public class User&#123; private int id; private String name; private String sex; private String email; private Dept dept;&#125; 123public class UserMapper&#123; public List&lt;User&gt; getUsersbyIf(User user);&#125; 1234567891011121314&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user where&lt;!-- 1=1 --&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125;&lt;!-- and id=#&#123;id&#125; --&gt; &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;/select&gt; &lt;/mapper&gt;&lt;!-- 当没有id时 sql语句会出现问题 --&gt; WHERE标签12345678910111213141516&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;where&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;!-- id=#&#123;id&#125; and --&gt; &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; and sex=#&#123;sex&#125; &lt;!-- id=#&#123;id&#125; and--&gt; &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; and email=#&#123;email&#125; &lt;!-- email=#&#123;email&#125; --&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; &lt;!-- and后置不好使 --&gt; TRIM标签123456789101112131415&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;trim prefix="where" prefixOverrides="xxx" suffix="" suffixOverrides="and"&gt; &lt;!-- 添加 where 前缀 覆盖xxx 添加后缀 覆盖and --&gt; &lt;if test="id!=null"&gt; xxx id=#&#123;id&#125; and &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; sex=#&#123;sex&#125; and &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; email=#&#123;email&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; CHOOSE标签12345678910111213&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;where&gt; &lt;choose&gt; &lt;when test="id!=null"&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;when test="sex!=null"&gt;sex=#&#123;sex&#125;&lt;/when&gt; &lt;when test"emall!=null and emall!=''"&gt; email=#&#123;email&#125;&lt;/when&gt; &lt;otherwith&gt;1 = 1&lt;/otherwith&gt; &lt;/choose&gt; &lt;!-- 只会进入第一个配置成功的条件 如传入id和sex 只会查询 id --&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; SET标签12345678910&lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog &lt;set&gt; &lt;if test="属性！=null and 属性！='' "&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;/set&gt;&lt;!-- 作用就是可以在插入的时候正确去掉最后一个逗号 --&gt; where 字段 = #&#123;属性名&#125;&lt;/update&gt; FOREACH标签12345678&lt;!-- 传入一个包含多个id的List --&gt;&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user where id in( &lt;foreach collection="users_id" item="user_id" separator="," open"(" close=")"&gt; &lt;!--还可以添加index属性 遍历List时 index为索引 遍历map时index为键值--&gt; #&#123;user_id&#125; &lt;/foreach&gt;&lt;/select&gt; Bind标签123456&lt;!-- 例如：模糊查询拼串 --&gt;&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; &lt;bind name="_name" value="'%'+name+'%'"&gt; select * from user where name like #&#123;_name&#125; &lt;!-- 不安全 select * from user where name like '%$&#123;name&#125;%' --&gt;&lt;/select&gt; 内置参数_parameter 单个参数：_parameter为这个参数多个参数：_parameter为封装map _databaseId 当全局配置中配置了DatabaseIdProvider标签时，_databaseId代表当前数据库的别名。 1public List&lt;User&gt; getUser(User user); 12345678910111213141516&lt;select id="getUser" resultMap="com.wang.test.bean.User"&gt; &lt;if test="_databaseId=='oracle' "&gt; select * from oracle_user &lt;if test="_parameter!=null"&gt; where sex = #&#123;_parameter.sex&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test="_databaseId=='mysql'"&gt; select * from user &lt;if test="_parameter!=null"&gt; where sex = #&#123;_parameter.sex&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; SQL标签123456789&lt;!-- 抽取常用的相同的sql片段，使用时引入即可 --&gt;&lt;sql id="insColm"&gt; id,name,sex,dept_id&lt;/sql&gt;&lt;insert&gt; insert into user( &lt;include refid="insColm"/&gt;) values ...&lt;/insert&gt; 批量保存Mysql 批量方式一 1public void saveUsers(@Param("users")List&lt;User&gt;); 123456789&lt;!-- 批量保存 --&gt;&lt;!-- Mysql 方式 --&gt;&lt;!-- insert into user values (),(),() --&gt;&lt;insert id="saveUsers"&gt; insert into user values &lt;foreach collection="users" item="user" separator=","&gt; (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方式二 1234567&lt;insert id="saveUsers"&gt;&lt;!-- insert into user values ();insert into user values ();insert into user values (); --&gt; &lt;foreach collection="users" item="user" separator=";"&gt; insert into user values (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; &lt;!-- 开启数据库的连接属性 jdbc:mysql//lo....?allowMultiQueries=true--&gt; Oracle 批量保存方式一 1234567891011121314&lt;!-- 批量保存 --&gt;&lt;!-- Oracle 方式 --&gt;&lt;!-- 代码块 begin insert into user values (),(),()； insert into user values (),(),()； insert into user values (),(),()； end； --&gt;&lt;insert id="saveUsers" databaseId="oracle"&gt; &lt;foreach collection="users" item="user" separator=";" open="begin" close="end;"&gt; insert into user values (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方式二 12345678910111213141516171819&lt;!-- 批量保存 --&gt;&lt;!-- Oracle 方式 --&gt;&lt;!-- 中间表方式 insert into user(id,name,email,dept_id) select user_seq.nextval,name,email,dept_id from( select 'value1' name,'value2' email,'value3' dept_id from dual union select 'value1' name,'value2' email,'value3' dept_id from dual union select 'value1' name,'value2' email,'value3' dept_id from dual ) --&gt;&lt;insert id="saveUsers" databaseId="oracle"&gt; insert into user(id,name,email,dept_id) select user_seq.nextval,name,email,dept_id from &lt;foreach collection="users" item="user" separator="union" open="(" close=")" &gt; select #&#123;user.id&#125; name,#&#123;user.email&#125; email,#&#123;user.dept.id&#125; dept_id from dual &lt;/foreach&gt;&lt;/insert&gt; 缓存一级缓存默认只开启一级缓存，一级缓存时SqlSession级别的缓存，这也就是说处在数据库相同会话中的操作，数据会被缓存，查询可以取到缓存值，减少查询次数。当然缓存会有他的存在时间和区域。缓存失效情况： 不同的SqlSession对象 相同SqlSession查询条件不同 相同SqlSession查询间隔数据操作 相同SqlSession查询前清空缓存 二级缓存全局缓存，基于命名空间级别的缓存，一个命名空间对应一个二级缓存。当会话关闭时，一级缓存中的数据会被保存到二级缓存中。12345678#redis.propertiesredis.host=127.0.0.1redis.port=6379redis.pass=123456redis.maxIdle=200redis.maxActive=1024redis.maxWait=10000redis.testOnBorrow=true 12345678910111213141516171819202122232425262728293031&lt;!-- applicationContext-redis.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd "&gt;&lt;!-- 连接池基本参数配置，类似数据库连接池 --&gt; &lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true"/&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;redis.maxActive&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;"/&gt; &lt;/bean&gt; &lt;!-- 连接池配置，类似数据库连接池 --&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="hostName" value="$&#123;redis.host&#125;"&gt;&lt;/property&gt; &lt;property name="port" value="$&#123;redis.port&#125;"&gt;&lt;/property&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.pass&#125;"&gt;&lt;/property&gt; --&gt; &lt;property name="poolConfig" ref="poolConfig"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="redisCacheTransfer" class="cn.qlq.jedis.RedisCacheTransfer"&gt; &lt;property name="jedisConnectionFactory" ref="jedisConnectionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class RedisCache implements Cache &#123; // 初始化Jedis private Jedis jedis = new Jedis("127.0.0.1", 6379); private String cacheId; /* * MyBatis会把映射文件的命名空间作为 * 唯一标识cacheId，标识这个缓存策略属于哪个namespace * 这里定义好，并提供一个构造器，初始化这个cacheId即可 */ public RedisCache (String cacheId)&#123; this.cacheId = cacheId; &#125; /** * 清空缓存 */ @Override public void clear() &#123; // 但这方法不建议实现 &#125; @Override public String getId() &#123; return cacheId; &#125; /** * MyBatis会自动调用这个方法检测缓存 * 中是否存在该对象。既然是自己实现的缓存 * ，那么当然是到Redis中找了。 */ @Override public Object getObject(Object arg0) &#123; // arg0 在这里是键 try &#123; byte [] bt = jedis.get(SerializableTools.ObjToByteArray(arg0)); if (bt == null) &#123; // 如果没有这个对象，直接返回null return null; &#125; return SerializableTools.byteArrayToObj(bt); &#125; catch (Exception e) &#123;e.printStackTrace();&#125; return null; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return new ReentrantReadWriteLock(); &#125; @Override public int getSize() &#123; return Integer.parseInt(Long.toString(jedis.dbSize())); &#125; /** * MyBatis在读取数据时，会自动调用此方法 * 将数据设置到缓存中。这里就写入Redis */ @Override public void putObject(Object arg0, Object arg1) &#123; /* * arg0是key , arg1是值 * MyBatis会把查询条件当做键，查询结果当做值。 */ try &#123; jedis.set(SerializableTools.ObjToByteArray(arg0), SerializableTools.ObjToByteArray(arg1)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * MyBatis缓存策略会自动检测内存的大小，由此 * 决定是否删除缓存中的某些数据 */ @Override public Object removeObject(Object arg0) &#123; Object object = getObject(arg0); try &#123; jedis.del(SerializableTools.ObjToByteArray(arg0)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class SerializableTools &#123; /** * 反序列化 * * @param bt * @return * @throws IOException * @throws Exception */ public static Object byteArrayToObj(byte[] bt) throws Exception &#123; ByteArrayInputStream bais = new ByteArrayInputStream(bt); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; /** * 对象序列化 * * @param obj * @return * @throws IOException */ public static byte[] ObjToByteArray(Object obj) throws IOException &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(obj); return bos.toByteArray(); &#125;&#125; 整合Redis，配置好Redis与Spring的集成后，重写Cache接口，在mapper的缓存标签中使用自定义的实现即可，即在type中写自己的实现，在Springboot中整合更容易，使用系统提供的注解并重写缓存序列化方法即可。 12345678910111213141516&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024" type="自定义缓存实现"&gt; &lt;!-- 对应接口方法 ### --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" useCache="true"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 增删改默认缓存清空--&gt; &lt;insert flushCache="true" /&gt;&lt;/mapper&gt;&lt;!-- 全局配置开启 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt; eviction:缓存回收策略 LRU(默认) 最近最少使用的将缓存，移除长时间不使用的对象 FIFO 先进先出，按照队列方式处理缓存 SOFT 软引用，基于垃圾回收器状态和软引用规则来移除对象缓存 WEAK 弱引用，积极移除基于垃圾收集器状态和弱引用规则的对象缓存 flushInterval: 缓存刷新间隔 默认不清空缓存，单位为毫秒。 readOnly 读写性，为真只读，直接传递引用，为假可改，使用序列化反序列化，默认为假，POJO对象必须实现序列化接口。 size 缓存存放元素个数 type 指定自定义缓存的全类名，当引入第三方缓存框架时，通过实现提供的接口，即可接管缓存工作。 框架整合123456&lt;!-- mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 进行一些个性化配置 --&gt;&lt;/configuration&gt; 1234567891011121314151617181920212223&lt;!-- mapper 存放位置无要求 --&gt;&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog set ... 字段 = #&#123;属性名&#125; where 字段 = #&#123;属性名&#125; &lt;/update&gt; &lt;delete id="deleteBlog"&gt; delete from Blog where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- applicationContext.xml --&gt;&lt;beans ...&gt; &lt;context:component-scan base-package="org.mybatis.example" use-default-filters="false"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!--数据源 --&gt; &lt;context:property-placeholder location="classpath:db.properties"&gt; &lt;bean id="datasource" class="com....."&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt; &lt;property name="..." value=""&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注解事务 声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="datasource"&gt;&lt;/property&gt; &lt;!-- 配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt; &lt;!-- 别名 --&gt; &lt;property name="typeAliasesPackage" value="org.mybatis.example.bean"&gt;&lt;/property&gt; &lt;!-- sql映射文件路径 --&gt; &lt;property name="mapperLocations" value="classpath*:mybatis/mapper/*Mapper.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mybatis-spring:scan base-package="org.mybatis.example.dao"&gt; &lt;/beans&gt; 12345678910111213141516&lt;!-- spring-servlet.xml--&gt;...&lt;beans ...&gt; &lt;!-- 只扫描Controller --&gt; &lt;context:component-scan base-package="org.mybatis.example" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.Controller"/&gt; &lt;/context:component-scan&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt; &lt;/beans&gt; 逆向工程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- generator.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime="MyBatis3Simple":生成简单版的CRUD MyBatis3:豪华版 --&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage="test.model"：目标包名 targetProject="\MBGTestProject\src"：目标工程 --&gt; &lt;javaModelGenerator targetPackage="com.test.mybatis.bean" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：sql映射生成策略： --&gt; &lt;sqlMapGenerator targetPackage="com.test.mybatis.dao" targetProject=".\conf"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.test.mybatis.dao" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt; &lt;table tableName="tbl_dept" domainObjectName="Department"&gt;&lt;/table&gt; &lt;table tableName="tbl_employee" domainObjectName="Employee"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 1234567891011public void testMbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("generator.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 存储过程1234567public class Page&#123; private int start; private int end; private int count; private List&lt;User&gt; users; ...&#125; 1234567create or replace procedure page_select(p_start in int,p_end in int,p_count out int,p_emps out sys_refcursor)begin select count(*) into p_count from user; open p_emps for select * from (select rownnum rn,e.* from user where rownum &lt;= p_end) where rn&gt;p_start;end 1public void pageSelect(Page page); 123456&lt;resultMap type="org.mybatis.example.bean.User" id="PageUser"&gt; ...&lt;/resultMap&gt;&lt;select id="pageSelect" resultType="org.mybatis.example.bean.Page" statementType="CALLABLE"&gt; &#123;call page_select(#&#123;start,mode=IN,jdbcType=INTEGER&#125;,#&#123;end,mode=IN,jdbcType=INTETER&#125;,#&#123;count,mode=OUT,jdbcType=INTEGER&#125;,#&#123;emps,mode=OUT,jdbcType=CURSOR,javaType=ResultSet,resultMap=PageUser&#125;)&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>XMl配置</tag>
        <tag>整合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 使用方法]]></title>
    <url>%2F2017%2F10%2F19%2FSpring-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。轻量级非入侵式框架，简化企业级应用开发，IOC(DI)、AOP容器框架。 使用方法 1234567891011121314151617&lt;!-- server.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 12345678910111213141516171819&lt;!-- dao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; 12345678/ create and configure beansApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");// retrieve configured instancePetStoreService service = context.getBean("petStore", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); Bean概述Spring 的Loc容器管理一个或多个bean，这些bean使用容器给定的配置，在容器中，这些bean会被定义为BeanDefinition对象将包含： Bean实现的类全类名 Bean的行为元素，作用域，生命周期回调等 引用bean执行其工作所需的其他bean，这些引用也称为协作者或依赖关系。 在新创建的对象中要设置的其他配置设置，例如，管理连接池的bean中要使用的连接数，或池的大小限制。 Bean定义属性 Property Explained in… class Instantiating beans name Naming beans scope Bean scopes constructor arguments Dependency Injection properties Dependency Injection autowiring mode Autowiring collaborators lazy-initialization mode Lazy-initialized beans initialization method Initialization callbacks destruction method Destruction callbacks 构造实例化123&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt; 静态工厂实例化123&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 工厂实例化123456789&lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 12345678public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂多个工厂方法 1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 依赖注入依赖注入(Dependency injection)是一个对象定义其依赖关系的过程，也就是说，与之协作的其他对象，如通过构造参数、工厂参数、属性等，将在本对象构造后或从工厂方法返回后进行注入。这个过程从根本上说就是bean本身的逆过程，bean本身通过类的构造或服务定位控制其他依赖对象的实例化或位置。 构造器注入下面的例子说明，通过构造器注入了一个依赖，这个依赖中的逻辑部分被注入方式隐藏，即这个只需注入依赖即可完成对应功能实现。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; xml编写方式 构造器注入的参数是已知类型的bean时，在构造参数上不需要指定参数的类型，直接进行引用即可。 12345678package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ...两个构造参数 &#125;&#125; 123456789101112&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;!-- 声明这个bean --&gt; &lt;!-- --&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 当注入的参数是简单类型，即无法确定类型的时候，可以进行类型指定或者参数的索引位置指定或参数名称指定。 123456789101112131415package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg name="years" value="7500000"/&gt; &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;&lt;/bean&gt; 属性注入下面示例中，依赖使用了一个属性，而这个属性的注入方式是使用的类中的set方法完成的。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on the MovieFinder private MovieFinder movieFinder; // a setter method so that the Spring container can inject a MovieFinder public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 属性注入示例,可以书写引用属性也可以使用字引用标签的方式。 12345678910111213&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- setter injection using the nested ref element --&gt; &lt;property name="beanOne"&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/property&gt; &lt;!-- setter injection using the neater ref attribute --&gt; &lt;property name="beanTwo" ref="yetAnotherBean"/&gt; &lt;property name="integerProperty" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 1234567891011121314151617181920public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) &#123; this.beanOne = beanOne; &#125; public void setBeanTwo(YetAnotherBean beanTwo) &#123; this.beanTwo = beanTwo; &#125; public void setIntegerProperty(int i) &#123; this.i = i; &#125;&#125; 此示例使用构造器方式实现上面的属性注入方式，用于对比两种注入方式。 123456789101112131415public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public ExampleBean( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123; this.beanOne = anotherBean; this.beanTwo = yetAnotherBean; this.i = i; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- constructor injection using the nested ref element --&gt; &lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/constructor-arg&gt; &lt;!-- constructor injection using the neater ref attribute --&gt; &lt;constructor-arg ref="yetAnotherBean"/&gt; &lt;constructor-arg type="int" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 详细依赖及配置直接给定值直接给定的如初始值、字符串等。 1234567891011121314151617181920212223&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="masterkaoli"/&gt;&lt;/bean&gt;&lt;!-- 还可以引入P命名空间来简化&lt;property&gt;标签的编写 这有那么一点点秀 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="masterkaoli"/&gt;&lt;/beans&gt; ###引用其他 在需要注入的位置直接添加引用属性或引用标签既可以 123456&lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;&lt;!-- constructor injection using the neater ref attribute --&gt;&lt;constructor-arg ref="yetAnotherBean"/&gt; 父子容器，用子容器中的bean代理父容器中的bean 12345678910111213&lt;!-- in the parent context --&gt;&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt; &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;&lt;!-- in the child (descendant) context --&gt;&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt; class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt; &lt;/property&gt; &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt; 内部创建可以在bean的property标签内继续创建新的bean，内部bean可以没有id属性 123456789&lt;bean id="outer" class="..."&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 集合类型赋值12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 属性值合并为集合 12345678910111213141516171819&lt;beans&gt; &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="child" parent="parent"&gt; &lt;property name="adminEmails"&gt; &lt;!-- the merge is specified on the child collection definition --&gt; &lt;props merge="true"&gt;&lt;!-- 这里将会合并 例如 setAdminEmils 传入一个map --&gt; &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;beans&gt; 强类型集合，当集合中的数据需要进行类型转换时，spring将自动完成类型转换工作 12345678public class Foo &#123; private Map&lt;String, Float&gt; accounts; public void setAccounts(Map&lt;String, Float&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 1234567891011&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="accounts"&gt; &lt;map&gt; &lt;entry key="one" value="9.99"/&gt; &lt;entry key="two" value="2.75"/&gt; &lt;entry key="six" value="3.99"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 空值规定空参数视为空字符串，null标签处理null值 123456789&lt;bean class="ExampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt;&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; C&amp;P属性标签12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt; &lt;!-- traditional declaration --&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;constructor-arg value="foo@bar.com"/&gt; &lt;property name="email" value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;!-- c-namespace declaration --&gt; &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com" p:email="foo@bar.com"/&gt;&lt;/beans&gt; 提前加载意思就是说，我这个bean在实例化前，你还得给我准备好我依赖的bean 12&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;&lt;bean id="manager" class="ManagerBean" /&gt; 懒加载1234567&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true"/&gt;&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;&lt;!-- 容器级别的懒加载 --&gt;&lt;beans default-lazy-init="true"&gt; &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt; 方法注入查找方式，使用cglib动态代理方式，生成代理子类 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager &#123; public Object process(Object commandState) &#123; // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); &#125; // okay... but where is the implementation of this method? protected abstract Command createCommand();&#125; 12345678910&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt; &lt;lookup-method name="createCommand" bean="myCommand"/&gt; &lt;!-- 还可以使用@Lookup（"myCommand"） 注解标注上面类中的方法 --&gt;&lt;/bean&gt; 任意方法替换方式 123456789101112131415161718192021public class MyValueCalculator &#123; public String computeValue(String input) &#123; // some real code... &#125; // some other methods...&#125;/** * meant to be used to override the existing computeValue(String) * implementation in MyValueCalculator */public class ReplacementComputeValue implements MethodReplacer &#123; public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123; // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; &#125;&#125; 12345678&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt; &lt;!-- arbitrary method replacement --&gt; &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt; 作用域 模式 描述 singleton 单例模式 prototype 原型模式、多例模式 request 每一个http请求都会创建一个单例的bean，仅web应用 session 在session的生命周期中存在，仅web应用 application ServletContext生命周期中存在，仅web应用 websocket WebSocket生命周期存在，仅web应用 单例模式 原型模式 Request 域HTTP 请求级别的bean，根据请求创建任意数量的bean，而且他们完全相同，互不影响，请求完成即销毁。 1&lt;bean id="loginAction" class="com.foo.LoginAction" scope="request"/&gt; 12345@RequestScope@Componentpublic class LoginAction &#123; // ...&#125; Session 域HTTP Session 级别，根据Session创建任意数量的bean，完全相同，互不影响，Session 关闭即销毁。 1&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt; 12345@SessionScope@Componentpublic class UserPreferences &#123; // ...&#125; Application 域ServletContext 级别，bean 服务整个web应用，bean作为ServletContext的一个普通的属性。 1&lt;bean id="appPreferences" class="com.foo.AppPreferences" scope="application"/&gt; 12345@ApplicationScope@Componentpublic class AppPreferences &#123; // ...&#125; 域对象注入域对象代理方式注入，对象既可以完成域对象本身的工作，也被注入了更长生命周期的bean中。 1234567891011121314&lt;beans ...&gt; &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt; &lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"&gt; &lt;!-- instructs the container to proxy the surrounding bean --&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt; &lt;bean id="userService" class="com.foo.SimpleUserService"&gt; &lt;!-- a reference to the proxied userPreferences bean --&gt; &lt;property name="userPreferences" ref="userPreferences"/&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义域重写接口或使用其个性化配置配置方法。 1234567//实现接口并注入到容器中org.springframework.beans.factory.config.ScopeObject get(String name, ObjectFactory objectFactory)Object remove(String name)void registerDestructionCallback(String name, Runnable destructionCallback)String getConversationId()void registerScope(String scopeName, Scope scope); 配置 12Scope threadScope = new SimpleThreadScope();beanFactory.registerScope("thread", threadScope); 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt; &lt;property name="scopes"&gt; &lt;map&gt; &lt;entry key="thread"&gt; &lt;bean class="org.springframework.context.support.SimpleThreadScope"/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="bar" class="x.y.Bar" scope="thread"&gt; &lt;property name="name" value="Rick"/&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="bar" ref="bar"/&gt; &lt;/bean&gt;&lt;/beans&gt; 生命周期调用初始化调用在bean完成各种在容器中的属性设置后，允许执行一个初始化的方法。 1&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt; 上面的定义与下面完全相同。123456public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; 同时，可以采用实现InitializingBean接口的方式，重写方法调用初始化方法，择一实用1&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt; 123456public class AnotherExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 销毁调用1&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt; 123456public class ExampleBean &#123; public void cleanup() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 1&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt; 123456public class AnotherExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 默认全局使用方法可以在bean的配置标签上配置好需要使用的生命周期方法，在编写类时，只需要实现了对应的方法，就会自动执行生命周期方法。 123456789101112131415public class DefaultBlogService implements BlogService &#123; private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) &#123; this.blogDao = blogDao; &#125; // this is (unsurprisingly) the initialization callback method public void init() &#123; if (this.blogDao == null) &#123; throw new IllegalStateException("The [blogDao] property must be set."); &#125; &#125;&#125; 1234567&lt;beans default-init-method="init"&gt; &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt; &lt;property name="blogDao" ref="blogDao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 混合使用当然可以混合使用，混合接口实现，混合方法实现，混合注解，都阔以的，总结方法有三。 InitializingBean DisposableBean callback interfaces init() and destroy() methods @PostConstruct and @PreDestroy annotations 启动和关闭123456789public interface Lifecycle &#123; void start(); void stop(); boolean isRunning();&#125;//生命周期接口 Aware Name Injected Dependency Explained in… ApplicationContextAware Declaring ApplicationContext ApplicationContextAware and BeanNameAware ApplicationEventPublisherAware Event publisher of the enclosing ApplicationContext Additional capabilities of the ApplicationContext BeanClassLoaderAware Class loader used to load the bean classes. Instantiating beans BeanFactoryAware Declaring BeanFactory ApplicationContextAware and BeanNameAware BeanNameAware Name of the declaring bean ApplicationContextAware and BeanNameAware BootstrapContextAware Resource adapter BootstrapContext the container runs in. Typically available only in JCA aware ApplicationContexts JCA CCI LoadTimeWeaverAware Defined weaver for processing class definition at load time Load-time weaving with AspectJ in the Spring Framework MessageSourceAware Configured strategy for resolving messages (with support for parametrization and internationalization) Additional capabilities of the ApplicationContext NotificationPublisherAware Spring JMX notification publisher Notifications ResourceLoaderAware Configured loader for low-level access to resources Resources ServletConfigAware Current ServletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext Spring MVC ServletContextAware Current ServletContext the container runs in. Valid only in a web-aware Spring ApplicationContext Spring MVC 继承父子bean12345678910111213&lt;bean id="inheritedTestBean" abstract="true" class="org.springframework.beans.TestBean"&gt; &lt;property name="name" value="parent"/&gt; &lt;property name="age" value="1"/&gt;&lt;/bean&gt;&lt;!-- 模板模式 --&gt;&lt;bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean" parent="inheritedTestBean" init-method="initialize"&gt; &lt;property name="name" value="override"/&gt; &lt;!-- the age property value of 1 will be inherited from parent --&gt;&lt;/bean&gt; 注解@Required用于bean属性的setter方法，标注后在使用bean时必须给对应属性赋值，避免空指针异常。 @Autowired可以标注在构造器上，也可以标注在setter方法上，甚至是任意的包含多个入参的方法。 1234567891011public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125; //标注构造&#125; 123456789101112131415public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // 任意方法及任意参数&#125; 1234567public class MovieRecommender &#123; @Autowired private MovieCatalog[] movieCatalogs; // 你将获得一个自动注入的 MovieCatalog[] 数组 集合同&#125; 12345678910public class MovieRecommender &#123; @Autowired private ApplicationContext context; public MovieRecommender() &#123; &#125; // 已经存在在容器中的Bean 当然可以自动注入啦 这是用到最多的情况了&#125; @Primary按类型自动装载时出现多个候选值时，可以使用这个注解来标注需要使用的bean。 12345678910111213@Configurationpublic class MovieConfiguration &#123; @Bean @Primary public MovieCatalog firstMovieCatalog() &#123; ... &#125; //装载 primary 的Bean @Bean public MovieCatalog secondMovieCatalog() &#123; ... &#125; &#125; 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:annotation-config/&gt; &lt;bean class="example.SimpleMovieCatalog" primary="true"&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;&lt;/beans&gt; @Qualifier当有多个相同类型的Bean时，可以通过这个注解进行区分，即可获得对应正确的Bean。 123456789101112131415161718192021222324public class MovieRecommender &#123; @Autowired @Qualifier("main") private MovieCatalog movieCatalog; // 当然有多实现的时候 就很美&#125;public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(@Qualifier("action")MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // 根据标记装载对应的类&#125; 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:annotation-config/&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier value="main"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier value="action"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;&lt;/beans&gt; 下面不是重点 1234567@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Genre &#123; //自己搞个注解用 String value();&#125; 1234567891011121314151617&lt;beans ...&gt; &lt;context:annotation-config/&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier type="Genre" value="Action"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier type="example.Genre" value="Comedy"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;&lt;/beans&gt; @Resource根据需要注入的类的名称进行查找然后进行类型查找最后注入 123456789public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 123456789public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource(name="myMovieFinder") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; // 这里自动装载的时名为 myMovieFinder 的实例 12345678910111213public class MovieRecommender &#123; @Resource private CustomerPreferenceDao customerPreferenceDao; @Resource private ApplicationContext context; public MovieRecommender() &#123; &#125; // context 查找的已知的 可使用的依赖进行注入 因为只有一个 ApplicationContext&#125; @PostConstruct 和 @PreDestroy注解后，这个类的实例化后，销毁前都会执行的对应的方法。 123456789101112public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; @Component标记一个组件类，当然被扫描了会被容器管理起来，开发里的@Repository、@Service、@Controller专门的@Component。 元注解 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Component // Spring will see this and treat @Service in the same way as @Componentpublic @interface Service &#123; // 这个就是Service注解&#125; @Bean12345678910111213@Componentpublic class FactoryMethodComponent &#123; @Bean @Qualifier("public") public TestBean publicInstance() &#123; return new TestBean("publicInstance"); &#125; public void doWork() &#123; // Component method implementation omitted &#125;&#125; 这里很重要 划重点！ 123456789101112131415161718192021222324252627282930313233@Componentpublic class FactoryMethodComponent &#123; private static int i; @Bean @Qualifier("public") public TestBean publicInstance() &#123; return new TestBean("publicInstance"); &#125; // use of a custom qualifier and autowiring of method parameters @Bean protected TestBean protectedInstance( @Qualifier("public") TestBean spouse, @Value("#&#123;privateInstance.age&#125;") String country) &#123; TestBean tb = new TestBean("protectedInstance", 1); tb.setSpouse(spouse); tb.setCountry(country); return tb; &#125; @Bean private TestBean privateInstance() &#123; return new TestBean("privateInstance", i++); &#125; @Bean @RequestScope public TestBean requestScopedInstance() &#123; return new TestBean("requestScopedInstance", 3); &#125;&#125; 扫描注解1234567@Configuration@ComponentScan(basePackages = "org.example", includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"), excludeFilters = @Filter(Repository.class))public class AppConfig &#123; ...&#125; 12345678&lt;beans&gt; &lt;context:component-scan base-package="org.example"&gt; &lt;context:include-filter type="regex" expression=".*Stub.*Repository"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 组件起名123456789@Service("myMovieLister")public class SimpleMovieLister &#123; // 它就叫 myMovieLister&#125;@Repositorypublic class MovieFinderImpl implements MovieFinder &#123; // ... 他就叫 movieFinderImpl&#125; 这里下面就了解一下 我是不会用的我保证 12345@Configuration@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)public class AppConfig &#123; ...&#125; 1234&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyNameGenerator" /&gt;&lt;/beans&gt; 作用域还记得那些作用域吗？ 他们是加到bean上的，那么这些组件是不是bean，什么是bean？ 哈哈 自动忽略这段话吧 12345@Scope("prototype")@Repositorypublic class MovieFinderImpl implements MovieFinder &#123; // ...&#125; 自定义我就不写了。 带别名的！12345678910111213141516@Component@Qualifier("Action")public class ActionMovieCatalog implements MovieCatalog &#123; // ...&#125;@Component@Genre("Action")public class ActionMovieCatalog implements MovieCatalog &#123; // ...&#125;@Component@Offlinepublic class CachingMovieCatalog implements MovieCatalog &#123; // ...&#125;//这仨也在前面写过了 生成候选组件索引就是它会给你生成一个组件的索引，在用到的时候不会去扫描了，自动拿，我有索引，我要第B168号组件，谢谢。 123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt; &lt;version&gt;5.0.9.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 对 加个依赖完事了 --&gt; AspectJ基本概念基本概念先来了解一下吧。 Aspect：切面，跨越多个类的横切关注点，如事务管理器。 Join point：切点，程序执行过程中的一个点，如方法的执行或异常的处理，在Spring AOP中，连接点表示一个执行的方法 Advice：通知，在切面的一个切点上执行的方法。包括有”around”, “before” and “after” ，常被定义为一个拦截器 Introduction：声明方法或字段为一个类型。 Target object：目标对象，需要进行切面处理对象，当然它将是一个代理对象。 AOP proxy：代理处理对象，即完成切面编程的，我叫它AOP 代理，一般有两种，JDK 动态代理和CGLIB 代理 Waving：编织，也就是将声明的切面和原目标对象混合在一起，可以在任意时期完成（编、运）,spring时在运行时完成的。 通知类型： Before advice：连接点之前执行，但是不能阻止执行到达连接点，抛异常当然就过不去了。 After returing advice：切点方法正常结束的执行切点任务后执行。 After throwing advice：跑异常将会被执行。 After(finally) advice：切点方法结束后总是执行的方法 Around advice：环绕通知，方法前后都阔以，还可以通过返回值或跑异常来提前结束切面任务。 AOP 代理Spring AOP默认为AOP代理使用标准JDK动态代理。这允许代理任何接口(或一组接口)。Spring AOP还可以使用CGLIB代理。这对于代理类而不是接口是必要的。如果业务对象没有实现接口，则默认使用CGLIB。因为编写接口而不是类是很好的实践;业务类通常会实现一个或多个业务接口。有可能强制使用CGLIB，在那些(希望是罕见的)情况下，您需要通知没有在接口上声明的方法，或者需要将代理对象作为具体类型传递给方法。 开启功能很容易你就开启了aop面向切面编程 12345@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125; 1&lt;aop:aspectj-autoproxy/&gt; 声明切面123&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 1234567package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125; 声明切点来了解一些切点的表达式吧。 execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP) this - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type target - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type args - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types @target - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type @args - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s) @within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP) @annotation - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation 当然不是这个。 execution ：方法匹配 within：将匹配限制在这些类型里 this：这个this内我加连接点 target：将会连接一个目标对象 args：参数是给定类型被连接 @args、@target、@within、@annotation 面向注解版本的匹配 12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature 组合表达式，就是模糊匹配，通配符匹配。 1234567891011@Pointcut("execution(public * *(..))")private void anyPublicOperation() &#123;&#125;@Pointcut("within(com.xyz.someapp.trading..*)")private void inTrading() &#123;&#125;@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")private void tradingOperation() &#123;&#125;//anyPublicOperation //inTrading//tradingOperation 来看一个例子吧，只有五个方法，淡定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xyz.someapp;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class SystemArchitecture &#123; /** * A join point is in the web layer if the method is defined * in a type in the com.xyz.someapp.web package or any sub-package * under that. */ @Pointcut("within(com.xyz.someapp.web..*)") public void inWebLayer() &#123;&#125; /** * A join point is in the service layer if the method is defined * in a type in the com.xyz.someapp.service package or any sub-package * under that. */ @Pointcut("within(com.xyz.someapp.service..*)") public void inServiceLayer() &#123;&#125; /** * A join point is in the data access layer if the method is defined * in a type in the com.xyz.someapp.dao package or any sub-package * under that. */ @Pointcut("within(com.xyz.someapp.dao..*)") public void inDataAccessLayer() &#123;&#125; /** * A business service is the execution of any method defined on a service * interface. This definition assumes that interfaces are placed in the * "service" package, and that implementation types are in sub-packages. * * If you group service interfaces by functional area (for example, * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))" * could be used instead. * * Alternatively, you can write the expression using the 'bean' * PCD, like so "bean(*Service)". (This assumes that you have * named your Spring service beans in a consistent fashion.) */ @Pointcut("execution(* com.xyz.someapp..service.*.*(..))") public void businessService() &#123;&#125; /** * A data access operation is the execution of any method defined on a * dao interface. This definition assumes that interfaces are placed in the * "dao" package, and that implementation types are in sub-packages. */ @Pointcut("execution(* com.xyz.someapp.dao.*.*(..))") public void dataAccessOperation() &#123;&#125;&#125; 1234567891011&lt;aop:config&gt; &lt;aop:advisor pointcut="com.xyz.someapp.SystemArchitecture.businessService()" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 声明通知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Aspectpublic class AdviceExample &#123; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @Before("execution(* com.xyz.myapp.dao.*.*(..))") public void doAccessCheck() &#123; // ... &#125; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @AfterReturning( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal") public void doAccessCheck(Object retVal) &#123; // ... &#125; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doRecoveryActions() &#123; // ... &#125; @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex") public void doRecoveryActions(DataAccessException ex) &#123; // ... &#125; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doReleaseLock() &#123; // ... &#125; @Around("com.xyz.myapp.SystemArchitecture.businessService()") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; &#125; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)") public void validateAccount(Account account) &#123; // ... &#125;&#125; 是不是蒙圈了，我也蒙圈了，我特地找了个图，看图，是不是一下子又明白了！ 我们继续。 1234567@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")private void accountDataAccessOperation(Account account) &#123;&#125;@Before("accountDataAccessOperation(account)")public void validateAccount(Account account) &#123; // ...&#125; 通知运行顺序 当有相同通知的时候，优先级高的先运行，方法都在用切面了，通知还有一万种类型，还要重的话，那它也没有说怎么用优先级，我也不会……不，优先级是通过向支持方面的bean添加Order注释或让bean实现有序接口来确定的。 引入方法这个例子是说，这个类将被作为一个接口被service下的类实现，所有service下的类都会实现我，被当做接口实现的。 1234567891011@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 编程使用12345678910111213// create a factory that can generate a proxy for the given target objectAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);// add an aspect, the class must be an @AspectJ aspect// you can call this as many times as you need with different aspectsfactory.addAspect(SecurityManager.class);// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspectfactory.addAspect(usageTracker);// now get the proxy object...MyInterfaceType proxy = factory.getProxy();// 说的很详细了... AOP还原理还是和上面AspectJ一样，但是我们可以在xml里面来完成切面编程这个事情。 声明切面123456789&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aBean" class="..."&gt; ...&lt;/bean&gt; 声明切点1234567891011121314151617181920212223242526272829303132333435363738394041&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;&lt;/aop:config&gt;&lt;!-- aspectJ 书写方式 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;&lt;/aop:config&gt;&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!-- 子标签 --&gt;&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt; &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!-- 顺带把通知也写了 --&gt;&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service..(..)) and this(service)"/&gt; &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!-- and or not --&gt; 声明通知说来说去通知建议，建议通知，这个就是，你在画了一个切点之后，这个切点到底要干什么，什么时候执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" throwing="dataAccessEx" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt; &lt;aop:after pointcut-ref="dataAccessOperation" method="doReleaseLock"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="aroundExample" ref="aBean"&gt; &lt;aop:around pointcut-ref="businessService" method="doBasicProfiling"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:before pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)" method="audit" arg-names="auditable"/&gt; 引入方法还记得上次那个类吗？ 对 被它拿去当借口给别人实现的。 12345678910111213&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt; &lt;aop:declare-parents types-matching="com.xzy.myapp.service.*+" implement-interface="com.xyz.myapp.service.tracking.UsageTracked" default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt; &lt;aop:before pointcut="com.xyz.myapp.SystemArchitecture.businessService() and this(usageTracked)" method="recordUsage"/&gt;&lt;/aop:aspect&gt; 顾问12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; &lt;aop:advisor pointcut-ref="businessService" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 结束吧到这里为止吧，省略了一些没有写出来，整篇基本上是基于官方文档的翻译，在写的时候翻阅资料，发现官方的是最好的，后面还写了切面编程的原理部分，以及spring自己对于目录数据等的处理，这里也就不写了，有兴趣或者需要的话，回去翻文档，完整看过一次不至于找不到在哪了。 [官方文档]：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html]]></content>
      <categories>
        <category>Spring 教程</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React]]></title>
    <url>%2F2017%2F09%2F16%2FReact%2F</url>
    <content type="text"><![CDATA[简介用于构建用户界面的JavaScript库，声明式、组件化、一次学习，随处编写，高效，单向数据流，使用虚拟dom及Dom Diff算法最小化页面重绘。 依赖react.js: React的核心库 react-dom.js: 提供操作DOM的react扩展库 babel.min.js: 解析JSX语法代码转为纯JS语法代码的库 hello12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id ="main"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt;//jsx ---&gt; js //1.创建虚拟dom var vdom = &lt;h1&gt;Hello React!&lt;/h1&gt; //2.渲染虚拟dom到页面 ReactDOM.render(vdom,document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JSXjavascript xml, react定义了一种类似于xml的js扩展语法，xml+js，用来创建react虚拟dom对象，语法规则，当遇见尖括号时，解析为标签，当遇见大括号时，解析为js，浏览器不能直接解析jsx代码，需要babel转换为js代码才可以运行，使用jsx需要给脚本标签加上type=”text/babel”，声明需要babel进行处理。 语法ReactDOM.rander(virtualDOM,containerDOM) 将虚拟的DOM渲染成真实DOM 示例12345678910111213141516171819202122232425&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = "dom1"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; const names = ['jQuery','Zepto','Angular','React','Vue'] const ul =( &lt;ul&gt; &#123;names.map((name,index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt;) ReactDOM.render(ul,document.getElementById('dom1')) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模块化向外提供特定功能的js程序，一般为一个js文件，用于复用js，简化js的编写，提高js运行的效率。 组件化用来实现特定功能效果的代码集合，即一个页面的版块，包含组件的html、css、js、所有资源。 面向组件编程组件1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id ="main"&gt;&lt;/div&gt; &lt;div id ="main2"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; //1.定义组件 var vdom = &lt;h1&gt;Hello React!&lt;/h1&gt; function Component() &#123; return &lt;h2&gt;这个标签来自一个组件&lt;/h2&gt; &#125; //无状态组件使用函数方式创建、效率更高 //类的方式具备状态 class Component2 extends React.Component&#123; render()&#123; return &lt;h2&gt;这个标签来自一个组件类&lt;/h2&gt; &#125; &#125; //2.渲染组件标签 ReactDOM.render(&lt;Component /&gt;,document.getElementById('main')) ReactDOM.render(&lt;Component2 /&gt;,document.getElementById('main2'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件属性stateState属性是组件的状态属性，页面中组件的重新渲染由此属性控制，其值是一个对象，可以包含多个数据。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id ="main"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; //1.定义组件 class News extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; isState:false &#125;//初始化状态 //绑定新方法this this.handleClick = this.handleClick.bind(this) //必须赋值 否则 函数中的state是空值 &#125;//调用父类构造 //新增方法 this 为空 handleClick()&#123; console.log(this) const isState = !this.state.isState this.setState(&#123;isState&#125;) &#125; //重写方法 render()&#123; const &#123;isState&#125; = this.state return &lt;h2 onClick=&#123;this.handleClick&#125;&gt;&#123;isState?'发布新闻':'没有新闻'&#125;&lt;/h2&gt; &#125; &#125; //2.渲染组件标签 ReactDOM.render(&lt;News /&gt;,document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 构造器初始化状态、绑定状态 render方法读取状态 事件函数中修改状态 props12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id ="man"&gt;&lt;/div&gt; &lt;div id ="woman"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/prop-types.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; //1.创建虚拟dom function Persion(props) &#123; return( &lt;ul&gt; &lt;li&gt;姓名：&#123;props.name&#125;&lt;/li&gt; &lt;li&gt;年龄：&#123;props.age&#125;&lt;/li&gt; &lt;li&gt;性别：&#123;props.sex&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125; Persion.defaultProps = &#123; sex: 'man', age: 18 &#125;//默认值 Persion.propTypes=&#123; name: PropTypes.string.isRequired, age: PropTypes.number &#125;//数据校验及数据是否为空 const p1 = &#123; name: 'Wang', age: 18, sex: 'girl' &#125; const p2 = &#123; name: 'Lee', age: 'cdef', sex: 'girl' &#125; class Persion2 extends React.Component&#123; render()&#123; return(&lt;ul&gt; &lt;li&gt;姓名：&#123;this.props.name&#125;&lt;/li&gt; &lt;li&gt;年龄：&#123;this.props.age&#125;&lt;/li&gt; &lt;li&gt;性别：&#123;this.props.sex&#125;&lt;/li&gt; &lt;/ul&gt;) &#125; &#125; //2.渲染虚拟dom到页面 //ReactDOM.render(&lt;Persion name=&#123;p1.name&#125; age=&#123;p1.age&#125; sex=&#123;p1.sex&#125; /&gt;,document.getElementById('man')) ReactDOM.render(&lt;Persion2 &#123;...p1&#125; /&gt;,document.getElementById('man')) //三点运算符 ReactDOM.render(&lt;Persion name=&#123;p2.name&#125; age=&#123;p2.age&#125;/&gt;,document.getElementById('woman'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打包运算 ...p1即可将p1中的值全部对应赋值给Persion组件/function fn(...list)调用fn(1,2,3) 此时为打包 refs和事件处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id ="main"&gt;&lt;/div&gt; &lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; //1.创建虚拟dom class Com extends React.Component&#123; constructor(props)&#123; super(props) this.showInput = this.showInput.bind(this) this.handleBlur = this.handleBlur.bind(this) //将组件绑定到函数 &#125; handleBlur(event)&#123; alert(event.target.value) &#125; showInput()&#123; const input = this.input alert(input.value) &#125; render()&#123; return( &lt;div&gt; &lt;input type="text" ref="content"/&gt;&amp;nbsp;&amp;nbsp; &lt;input type="text" ref=&#123;(input) =&gt; this.input = input&#125;/&gt;&amp;nbsp;&amp;nbsp; //dom绑定到组件 &lt;button onClick=&#123;this.showInput&#125;&gt;提示输入&lt;/button&gt; &lt;input placeholder="失去焦点提示内容" onBlur=&#123;this.handleBlur&#125;/&gt; //事件绑定 &lt;/div&gt; ) &#125; &#125; //2.渲染虚拟dom到页面 ReactDOM.render(&lt;Com/&gt;,document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件界面开发流程 拆分组件：拆分界面，抽取组件， 实现静态组件：使用组件实现静态页面效果 实现动态组件 动态显示初始化数据 实现交互功能 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//第一阶段&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id ="main"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; class App extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;h1&gt;This is To Do List&lt;/h1&gt; &lt;Add /&gt; &lt;List /&gt; &lt;/div&gt; ) &#125; &#125; class Add extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;input type="text"/&gt; &lt; button&gt; Add #4&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; class List extends React.Component&#123; render()&#123; return( &lt;ul&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;/ul&gt; ) &#125; &#125; ReactDOM.render(&lt;App/&gt;,document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="main"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/prop-types.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; class App extends React.Component &#123; /** * 数据需要放在哪个组件，独占数据放到组件，共享数据放到父组件 * @returns &#123;*&#125; */ constructor(props) &#123; super(props) this.state = &#123; todos: ['eat', 'sleep', 'coding'] &#125; this.addTodo = this.addTodo.bind(this) &#125; addTodo(todo) &#123; const &#123;todos&#125; = this.state todos.unshift(todo) this.setState(&#123;todos&#125;) &#125; render() &#123; const &#123;todos&#125; = this.state return ( &lt;div&gt; &lt;h1&gt;This is To Do List&lt;/h1&gt; &lt;Add count=&#123;todos.length&#125; addTodo=&#123;this.addTodo&#125;/&gt; &lt;List todos=&#123;todos&#125;/&gt; &lt;/div&gt; ) &#125; &#125; class Add extends React.Component &#123; constructor(props) &#123; super(props) this.add = this.add.bind(this) &#125; add() &#123; const todo = this.todoInput.value.trim() if (!todo) &#123; alert("不能为空！") return &#125; this.props.addTodo(todo) this.todoInput.value //读取数据 //校验数据 //添加 &#125; render() &#123; return ( &lt;div&gt; &lt;input type="text" ref=&#123;input =&gt; this.todoInput = input&#125;/&gt; &lt; button onClick=&#123;this.add&#125;&gt; Add #&#123;this.props.count + 1&#125;&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; Add.propTypes = &#123; count: PropTypes.number.isRequired, addTodo: PropTypes.func.isRequired &#125; class List extends React.Component &#123; render() &#123; return ( &lt;ul&gt; &#123;this.props.todos.map((todo, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;todo&#125;&lt;/li&gt;)&#125; &lt;/ul&gt; ) &#125; &#125; List.propTypes = &#123; todos: PropTypes.array.isRequired, &#125; ReactDOM.render(&lt;App/&gt;, document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//示例 阻止默认行为 组件取值&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="main"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; //1.创建虚拟dom class LoginForm extends React.Component &#123; constructor(props) &#123; super(props) this.handleSubmint = this.handleSubmit.bind(this) this.handleChange = this.handleChange.bind(this) &#125; handleChange(event) &#123; const pwd = event.target.value this.setState(&#123;pwd&#125;) &#125; handleSubmit(event) &#123; const name = this.nameInput.value const &#123;pwd&#125; = this.state event.preventDefault() alert(`用户名：$&#123;name&#125; 密码：$&#123;pwd&#125;`) &#125; render() &#123; return ( &lt;form action="/test" onSubmit=&#123;this.handleSubmint&#125;&gt; 用户名：&lt;input type="text" ref=&#123;input =&gt; this.nameInput = input&#125;/&gt; 密码：&lt;input type="password" onChange=&#123;this.handleChange&#125;/&gt; &lt;input type="submit" value="登录"/&gt; &lt;/form&gt; ) &#125; &#125; ReactDOM.render(&lt;LoginForm/&gt;, document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 组件生命周期 组件的三个生命周期状态: Mount：插入真实 DOM Update：被重新渲染 Unmount：被移出真实 DOM 生命周期流程: 第一次初始化显示: ReactDOM.render(, containDom) constructor() componentWillMount() : 将要插入回调 render() : 用于插入虚拟DOM回调 componentDidMount() : 已经插入回调 每次更新state: this.setState({}) componentWillReceiveProps(): 接收父组件新的属性 componentWillUpdate() : 将要更新回调 render() : 更新(重新渲染) componentDidUpdate() : 已经更新回调 删除组件: ReactDOM.unmountComponentAtNode(div): 移除组件 componentWillUnmount() : 组件将要被移除回调 常用的方法 render(): 必须重写, 返回一个自定义的虚拟DOM constructor(): 初始化状态, 绑定this(可以箭头函数代替) componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="main"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="../js/react.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/react-dom.development.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../js/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt; class Life extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; opacity: 1 &#125; this.distroyComponent = this.distroyComponent.bind(this) &#125; distroyComponent() &#123; ReactDOM.unmountComponentAtNode(document.getElementById('main')) &#125; componentWillUnmount() &#123; clearInterval(this.intervalId) &#125; componentDidMount() &#123; this.intervalId = setInterval(function () &#123; let &#123;opacity&#125; = this.state console.log("running") opacity -= 0.1 if (opacity &lt;= 0) &#123; opacity = 1 &#125; this.setState(&#123;opacity&#125;) &#125;.bind(this), 200) &#125; //render为渲染 render() &#123; const &#123;opacity&#125; = this.state return ( &lt;div&gt; &lt;h2 style=&#123;&#123;opacity&#125;&#125;&gt;&#123;this.props.msg&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.distroyComponent&#125;&gt;结束&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Life msg="This is Msg"/&gt;, document.getElementById('main'))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 虚拟DOM与DOM Diff算法虚拟DOM一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应如果只是更新虚拟DOM, 页面是不会重绘的 Virtual DOM 算法的基本步骤用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把差异应用到真实DOM树上，视图就更新了 进一步理解Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 脚手架创建项目模板，模板中包含了所有需要的配置，预先设置了依赖，可以直接安装、编译、运行。 官方提供一个create-react-app脚手架库，技术栈为react+webpack+es6+eslint。 脚手架开发方式创建项目具有模块化、组件化、工程化等特点。 1234567npm install create-react-appcreate-react-app [project_name]cd [project_name]npm (run) start 入口1234567//index.jsimport React from 'react'import ReactDOM from 'react-dom'import App from './components/app'import './index.css'ReactDOM.render(&lt;App /&gt; ,document.getElementById('root')) 1234567891011121314151617181920212223242526272829303132333435363738394041//index.html&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="theme-color" content="#000000"&gt; &lt;!-- manifest.json provides metadata used when your web app is added to the homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/ --&gt; &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json"&gt; &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico"&gt; &lt;!-- Notice the use of %PUBLIC_URL% in the tags above. It will be replaced with the URL of the `public` folder during the build. Only files inside the `public` folder can be referenced from the HTML. Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will work correctly both with client-side routing and a non-root public URL. Learn how to configure a non-root public URL by running `npm run build`. --&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;noscript&gt; You need to enable JavaScript to run this app. &lt;/noscript&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the &lt;body&gt; tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --&gt; &lt;/body&gt;&lt;/html&gt; 组件123456789101112131415import React,&#123;Component&#125; from 'react'import log from '../logo.svg'export default class App extends Component&#123; render()&#123; return( &lt;div&gt; &lt;img className="logo" src=&#123;log&#125; alt="This is image"/&gt; &lt;p className="title"&gt;这是一个组件&lt;/p&gt; &lt;/div&gt; ) &#125;&#125;//export default App 使用 拆分组件 实现静态页面、静态数据展示 完成数据交互、动态数据显示 https://github.com/wan9huan/practice_react/tree/master/react_app Ajax请求React是一款专注前端的框架，本身不支持ajax，使用ajax功能，需要引入第三方库。 常用工具 Jquery：大型的js库，不建议使用 axios：轻量级，使用xmr封装对象的ajx，promis风格，前后端均可使用 fetch：原生函数，不兼容低版本浏览器，不适用xmr方式，也可引入fetch.js使之兼容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type="text/javascript" src="https://cdn.bootcss.com/axios/0.18.0/axios.js"&gt;&lt;/script&gt; &lt;script type="text/babel"&gt; class Ajax extends React.Component&#123; state =&#123; repoName:'', repoUrl:'' &#125; componentDidMount()&#123; const url = `https://api.github.com/search/repositories?q=r&amp;sort=stars&amp;order=desc` //发送axios的ajax请求 axios.get(url).then(response =&gt;&#123; const result = response.data console.log(result) const&#123;name,html_url&#125; = result.items[0] this.setState(&#123;repoName: name,repoUrl: html_url&#125;) &#125;) //fetch fetch(url) .then(response =&gt;&#123; return reposponse.json() &#125;) .then(data =&gt; &#123; const&#123;name,html_url&#125; = data.items[0] this.setState(&#123;repoName: name,repoUrl: html_url&#125;) &#125;) &#125; render()&#123; const &#123;repoName,repoUrl&#125; = this.state if(!repoName)&#123; return &lt;h2&gt;Loading ......&lt;/h2&gt; &#125; else&#123; return &lt;h2&gt;最受欢迎的项目是&lt;a href=&#123;repoUrl&#125; &gt;&#123;repoName&#125;&lt;/a&gt;&lt;/h2&gt; &#125; &#125; &#125; ReactDOM.render(&lt;Ajax /&gt;,document.getElementById('dom1')) &lt;/script&gt; 123456789101112131415161718192021 axios.get(url) .then(response =&gt;&#123; const result = response.data console.log(result) const&#123;name,html_url&#125; = result.items[0] this.setState(&#123;repoName: name,repoUrl: html_url&#125;) &#125;) .catch((error) =&gt; &#123; console.log(error.message) &#125;)//fetch// fetch(url)// .then(response =&gt;&#123;// return response.json()// &#125;)// .then(data =&gt; &#123; // const&#123;name,html_url&#125; = data.items[0] // this.setState(&#123;repoName: name,repoUrl: html_url&#125;)// &#125;) 示例123456789101112131415161718192021222324//app.jsimport React,&#123;Component&#125; from 'react'import Search from './search'import Main from './main'export default class App extends Component&#123; state=&#123; searchName: '' &#125; setSearchName = (searchName) =&gt;&#123; this.setState(&#123;searchName&#125;) &#125; render()&#123; return( &lt;div className="container"&gt; &lt;Search setSearchName=&#123;this.setSearchName&#125;/&gt; &lt;Main searchName=&#123;this.state.searchName&#125;/&gt; &lt;/div&gt;) &#125;&#125;//export default App 1234567891011121314151617181920212223242526272829//search.jsimport React,&#123;Component&#125; from 'react'import PropTypes from 'prop-types'export default class Search extends Component&#123; static propTypes = &#123; setSearchName: PropTypes.func.isRequired &#125; search = () =&gt;&#123; //获取关键字 const searchName = this.input.value.trim() if(searchName)&#123; this.props.setSearchName(searchName) &#125; //搜索 &#125; render()&#123; return( &lt;section className="jumbotron"&gt; &lt;h3 className="jumbotron-heading"&gt;Search Github Users&lt;/h3&gt; &lt;div&gt; &lt;input type="text" placeholder="enter the name you search" ref=&#123;input =&gt; this.input=input&#125;/&gt; &lt;button onClick=&#123;this.search&#125;&gt;Search&lt;/button&gt; &lt;/div&gt; &lt;/section&gt;) &#125;&#125;//export default Search 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//mian.jsimport React, &#123;Component&#125; from 'react'import PropTypes from 'prop-types'import axios from 'axios'export default class Main extends Component &#123; static propTypes = &#123; searchName: PropTypes.string.isRequired &#125; state= &#123; initView: true, loading: false, users: null, errorMsg: null, items:'', &#125; //接收新属性调用 componentWillReceiveProps(newProps)&#123; //发送请求 const &#123;searchName&#125; = newProps //更新状态 this.setState(&#123; initView:false, loading:true &#125;) const url = `https://api.github.com/search/users?q=$&#123;searchName&#125;` axios.get(url) .then(response =&gt;&#123; //取数据 const result = response.data const users = result.items.map(item =&gt; (&#123;name:item.login,url:item.html_url,avatarUrl:item.avatar_url&#125;)) this.setState(&#123;loading:false,users&#125;) console.log(result) //更新状态 &#125;) .catch(error =&gt;&#123; &#125;) &#125; render() &#123; const&#123;initView,loading,users,errorMsg&#125; = this.state if(initView)&#123; return &lt;h2&gt; 请进行搜索 &lt;/h2&gt; &#125; else if(loading)&#123; return &lt;h2&gt;正在加载中...&lt;/h2&gt; &#125; else if(errorMsg)&#123; return &lt;h2&gt;&#123;errorMsg&#125;&lt;/h2&gt; &#125;else return ( &lt;div className="row"&gt; &#123; users.map((user,index) =&gt; ( &lt;div className="card" key=&#123;index&#125;&gt; &lt;a href=&#123;user.url&#125; target="_blank"&gt; &lt;img src=&#123;user.avatarUrl&#125; style=&#123;&#123;width: 100&#125;&#125; alt="img"/&gt; &lt;/a&gt; &lt;p className="card-text"&gt;&#123;user.name&#125;&lt;/p&gt; &lt;/div&gt; )) &#125; &lt;/div&gt;) &#125;&#125;//export default Main 1234567//index.jsimport React from 'react'import ReactDOM from 'react-dom'import App from './components/app'import './index.css'ReactDOM.render(&lt;App /&gt; ,document.getElementById('root')) 12345678910111213141516171819202122232425#index.css.album &#123; min-height: 50rem; /* Can be removed; just added for demo purposes */ padding-top: 3rem; padding-bottom: 3rem; background-color: #f7f7f7;&#125;.card &#123; float: left; width: 33.333%; padding: .75rem; margin-bottom: 2rem; border: 1px solid #efefef; text-align: center;&#125;.card &gt; img &#123; margin-bottom: .75rem; border-radius: 100px;&#125;.card-text &#123; font-size: 85%;&#125; 组件数据传递props 需要共同使用的数据，存放在父组件中，当前组件特有的数据放在组件state中 可以传递普通数据和函数数据，只能按层传递 数据 –》 父到子 –》 子读取 函数 –》 子函数传递参数到父 –》 子调用函数 兄弟组件的参数传递必须借助父组件进行传递 订阅与发布PubSubJs 将数据进行发布，在使用的地方订阅即可使用数据。 1234PubSub.publish('search',searchName)PubSub.subscribe('search',(msg,searchName) =&gt;&#123; console.log(`使用数据$&#123;searchName&#125;`)&#125; redux这个也是比较常用的数据传递方式，整合redux使用是很便捷的，后面继续详解。 react-router一个react的插件库，创建基于react的单页web应用。 SPA Sigle page web application,SPA 麻萨吉 整个应用只有一个完整的页面 点击页面中的链接不会刷新页面，也不会发送请求页面的请求 点击链接（链接都是路由链接）之后对当前页面进行局部刷新 数据都是通过ajax请求获取的，并在前端异步展现（异步展现？） 路由映射关系，kv值，(path: func/component),例如（path,fun(req,res)）。 后台路由 node服务端路由，value是function，用来处理客户端提交的请求并返回一个响应数据。 注册方式：router.get(path,function(req,res)) 当服务器端接收到请求时，调用路由中的函数，处理请求并返回数据。 前台路由 浏览器端路由，value是component，当请求是路由path时，浏览器端不会发送http请求，但界面会进行更新展示为对应的组件。 注册方式： 当浏览器的hash变为#info时，当前的页面组件就会变成Info组件 组件12345678910111213&lt;BrowerRouter&gt;&lt;HashRouter&gt;&lt;Route&gt;&lt;Redirect&gt;&lt;Link&gt;&lt;NavLink&gt;&lt;Switch&gt; 示例]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>示例演示</tag>
        <tag>组件编写</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2017%2F08%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式是人们面对同类型软件工程设计问题所总结的经验，是一种通用设计解决方案。 优化软件的维护性、扩展性、变化性、复杂度，基于面向对象。 Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides 《设计模式》 23入门工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一，在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 123public interface Shape &#123; void draw();&#125; 12345678public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125; 1234567public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125; 1234567public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; 1234567891011121314151617public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125;&#125; 12345678910111213141516171819202122232425public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 抽象工厂抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类，每个生成的工厂都能按照工厂模式提供对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178public interface Shape &#123; void draw();&#125;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125;public interface Color &#123; void fill();&#125;public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Red::fill() method."); &#125;&#125;public class Green implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Green::fill() method."); &#125;&#125;public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println("Inside Blue::fill() method."); &#125;&#125;//抽象工厂public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape) ;&#125;//形状工厂public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("CIRCLE"))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase("RECTANGLE"))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase("SQUARE"))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125;//颜色工厂public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase("RED"))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase("GREEN"))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase("BLUE"))&#123; return new Blue(); &#125; return null; &#125;&#125;//工厂public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase("SHAPE"))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase("COLOR"))&#123; return new ColorFactory(); &#125; return null; &#125;&#125;public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE"); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape("CIRCLE"); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape("RECTANGLE"); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape("SQUARE"); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR"); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor("RED"); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor("Green"); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor("BLUE"); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 单例模式单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 123456789101112131415161718public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println("Hello World!"); &#125;&#125; 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158public interface Item &#123; public String name(); public Packing packing(); public float price(); &#125;public interface Packing &#123; public String pack();&#125;public class Wrapper implements Packing &#123; @Override public String pack() &#123; return "Wrapper"; &#125;&#125;public class Bottle implements Packing &#123; @Override public String pack() &#123; return "Bottle"; &#125;&#125;public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125;public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125;public class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return "Veg Burger"; &#125;&#125;public class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return "Chicken Burger"; &#125;&#125;public class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return "Coke"; &#125;&#125;public class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return "Pepsi"; &#125;&#125; public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print("Item : "+item.name()); System.out.print(", Packing : "+item.packing().pack()); System.out.println(", Price : "+item.price()); &#125; &#125; &#125;public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125;public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println("Veg Meal"); vegMeal.showItems(); System.out.println("Total Cost: " +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println("\n\nNon-Veg Meal"); nonVegMeal.showItems(); System.out.println("Total Cost: " +nonVegMeal.getCost()); &#125;&#125; 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public abstract class Shape implements Cloneable &#123; private String id; protected String type; abstract void draw(); public String getType()&#123; return type; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125;public class Rectangle extends Shape &#123; public Rectangle()&#123; type = "Rectangle"; &#125; @Override public void draw() &#123; System.out.println("Inside Rectangle::draw() method."); &#125;&#125;public class Square extends Shape &#123; public Square()&#123; type = "Square"; &#125; @Override public void draw() &#123; System.out.println("Inside Square::draw() method."); &#125;&#125;public class Circle extends Shape &#123; public Circle()&#123; type = "Circle"; &#125; @Override public void draw() &#123; System.out.println("Inside Circle::draw() method."); &#125;&#125; public class ShapeCache &#123; private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;(); public static Shape getShape(String shapeId) &#123; Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); &#125; // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() &#123; Circle circle = new Circle(); circle.setId("1"); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId("2"); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId("3"); shapeMap.put(rectangle.getId(),rectangle); &#125;&#125;public class PrototypePatternDemo &#123; public static void main(String[] args) &#123; ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape("1"); System.out.println("Shape : " + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape("2"); System.out.println("Shape : " + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape("3"); System.out.println("Shape : " + clonedShape3.getType()); &#125;&#125; 适配器模式适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public interface MediaPlayer &#123; public void play(String audioType, String fileName);&#125;public interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125;public class VlcPlayer implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; System.out.println("Playing vlc file. Name: "+ fileName); &#125; @Override public void playMp4(String fileName) &#123; //什么也不做 &#125;&#125;public class Mp4Player implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; //什么也不做 &#125; @Override public void playMp4(String fileName) &#123; System.out.println("Playing mp4 file. Name: "+ fileName); &#125;&#125;//适配器将两种播放插件整合成一个适配播放插件public class MediaAdapter implements MediaPlayer &#123; AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType)&#123; if(audioType.equalsIgnoreCase("vlc") )&#123; advancedMusicPlayer = new VlcPlayer(); &#125; else if (audioType.equalsIgnoreCase("mp4"))&#123; advancedMusicPlayer = new Mp4Player(); &#125; &#125; @Override public void play(String audioType, String fileName) &#123; if(audioType.equalsIgnoreCase("vlc"))&#123; advancedMusicPlayer.playVlc(fileName); &#125;else if(audioType.equalsIgnoreCase("mp4"))&#123; advancedMusicPlayer.playMp4(fileName); &#125; &#125;&#125;public class AudioPlayer implements MediaPlayer &#123; MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) &#123; //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase("mp3"))&#123; System.out.println("Playing mp3 file. Name: "+ fileName); &#125; //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4"))&#123; mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); &#125; else&#123; System.out.println("Invalid media. "+ audioType + " format not supported"); &#125; &#125; &#125;public class AdapterPatternDemo &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play("mp3", "beyond the horizon.mp3"); audioPlayer.play("mp4", "alone.mp4"); audioPlayer.play("vlc", "far far away.vlc"); audioPlayer.play("avi", "mind me.avi"); &#125;&#125; 桥接模式桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125;public class RedCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: red, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125;public class GreenCircle implements DrawAPI &#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: green, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125;public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw(); &#125;public class Circle extends Shape &#123; private int x, y, radius; public Circle(int x, int y, int radius, DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;public class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125; 过滤模式过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class Person &#123; private String name; private String gender; private String maritalStatus; public Person(String name,String gender,String maritalStatus)&#123; this.name = name; this.gender = gender; this.maritalStatus = maritalStatus; &#125; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender; &#125; public String getMaritalStatus() &#123; return maritalStatus; &#125; &#125; public interface Criteria &#123; public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);&#125;public class CriteriaMale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getGender().equalsIgnoreCase("MALE"))&#123; malePersons.add(person); &#125; &#125; return malePersons; &#125;&#125;public class CriteriaFemale implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getGender().equalsIgnoreCase("FEMALE"))&#123; femalePersons.add(person); &#125; &#125; return femalePersons; &#125;&#125;public class CriteriaSingle implements Criteria &#123; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); for (Person person : persons) &#123; if(person.getMaritalStatus().equalsIgnoreCase("SINGLE"))&#123; singlePersons.add(person); &#125; &#125; return singlePersons; &#125;&#125;public class AndCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public AndCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons); return otherCriteria.meetCriteria(firstCriteriaPersons); &#125;&#125;public class OrCriteria implements Criteria &#123; private Criteria criteria; private Criteria otherCriteria; public OrCriteria(Criteria criteria, Criteria otherCriteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; @Override public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) &#123; List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons); List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons); for (Person person : otherCriteriaItems) &#123; if(!firstCriteriaItems.contains(person))&#123; firstCriteriaItems.add(person); &#125; &#125; return firstCriteriaItems; &#125;&#125;public class CriteriaPatternDemo &#123; public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;(); persons.add(new Person("Robert","Male", "Single")); persons.add(new Person("John","Male", "Married")); persons.add(new Person("Laura","Female", "Married")); persons.add(new Person("Diana","Female", "Single")); persons.add(new Person("Mike","Male", "Single")); persons.add(new Person("Bobby","Male", "Single")); Criteria male = new CriteriaMale(); Criteria female = new CriteriaFemale(); Criteria single = new CriteriaSingle(); Criteria singleMale = new AndCriteria(single, male); Criteria singleOrFemale = new OrCriteria(single, female); System.out.println("Males: "); printPersons(male.meetCriteria(persons)); System.out.println("\nFemales: "); printPersons(female.meetCriteria(persons)); System.out.println("\nSingle Males: "); printPersons(singleMale.meetCriteria(persons)); System.out.println("\nSingle Or Females: "); printPersons(singleOrFemale.meetCriteria(persons)); &#125; public static void printPersons(List&lt;Person&gt; persons)&#123; for (Person person : persons) &#123; System.out.println("Person : [ Name : " + person.getName() +", Gender : " + person.getGender() +", Marital Status : " + person.getMaritalStatus() +" ]"); &#125; &#125; &#125; 组合模式组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Employee &#123; private String name; private String dept; private int salary; private List&lt;Employee&gt; subordinates; //构造函数 public Employee(String name,String dept, int sal) &#123; this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList&lt;Employee&gt;(); &#125; public void add(Employee e) &#123; subordinates.add(e); &#125; public void remove(Employee e) &#123; subordinates.remove(e); &#125; public List&lt;Employee&gt; getSubordinates()&#123; return subordinates; &#125; public String toString()&#123; return ("Employee :[ Name : "+ name +", dept : "+ dept + ", salary :" + salary+" ]"); &#125; &#125;public class CompositePatternDemo &#123; public static void main(String[] args) &#123; Employee CEO = new Employee("John","CEO", 30000); Employee headSales = new Employee("Robert","Head Sales", 20000); Employee headMarketing = new Employee("Michel","Head Marketing", 20000); Employee clerk1 = new Employee("Laura","Marketing", 10000); Employee clerk2 = new Employee("Bob","Marketing", 10000); Employee salesExecutive1 = new Employee("Richard","Sales", 10000); Employee salesExecutive2 = new Employee("Rob","Sales", 10000); CEO.add(headSales); CEO.add(headMarketing); headSales.add(salesExecutive1); headSales.add(salesExecutive2); headMarketing.add(clerk1); headMarketing.add(clerk2); //打印该组织的所有员工 System.out.println(CEO); for (Employee headEmployee : CEO.getSubordinates()) &#123; System.out.println(headEmployee); for (Employee employee : headEmployee.getSubordinates()) &#123; System.out.println(employee); &#125; &#125; &#125;&#125; 装饰者模式装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface Shape &#123; void draw();&#125;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape: Rectangle"); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Shape: Circle"); &#125;&#125;//装饰者public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape)&#123; this.decoratedShape = decoratedShape; &#125; public void draw()&#123; decoratedShape.draw(); &#125; &#125;public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); &#125; @Override public void draw() &#123; decoratedShape.draw(); setRedBorder(decoratedShape); &#125; private void setRedBorder(Shape decoratedShape)&#123; System.out.println("Border Color: Red"); &#125;&#125;public class DecoratorPatternDemo &#123; public static void main(String[] args) &#123; Shape circle = new Circle(); Shape redCircle = new RedShapeDecorator(new Circle()); Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println("Circle with normal border"); circle.draw(); System.out.println("\nCircle of red border"); redCircle.draw(); System.out.println("\nRectangle of red border"); redRectangle.draw(); &#125;&#125; 外观模式外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public interface Shape &#123; void draw();&#125;public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println("Rectangle::draw()"); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println("Square::draw()"); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println("Circle::draw()"); &#125;&#125;//外观类public class ShapeMaker &#123; private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() &#123; circle = new Circle(); rectangle = new Rectangle(); square = new Square(); &#125; public void drawCircle()&#123; circle.draw(); &#125; public void drawRectangle()&#123; rectangle.draw(); &#125; public void drawSquare()&#123; square.draw(); &#125;&#125;public class FacadePatternDemo &#123; public static void main(String[] args) &#123; ShapeMaker shapeMaker = new ShapeMaker(); shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare(); &#125;&#125; 享元模式享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public interface Shape &#123; void draw();&#125;public class Circle implements Shape &#123; private String color; private int x; private int y; private int radius; public Circle(String color)&#123; this.color = color; &#125; public void setX(int x) &#123; this.x = x; &#125; public void setY(int y) &#123; this.y = y; &#125; public void setRadius(int radius) &#123; this.radius = radius; &#125; @Override public void draw() &#123; System.out.println("Circle: Draw() [Color : " + color +", x : " + x +", y :" + y +", radius :" + radius); &#125;&#125;public class ShapeFactory &#123; private static final HashMap&lt;String, Shape&gt; circleMap = new HashMap&lt;&gt;(); public static Shape getCircle(String color) &#123; //根据颜色创建对象并添加到circleMap中，已经创建过地颜色不再重复创建 Circle circle = (Circle)circleMap.get(color); if(circle == null) &#123; circle = new Circle(color); circleMap.put(color, circle); System.out.println("Creating circle of color : " + color); &#125; return circle; &#125;&#125;public class FlyweightPatternDemo &#123; private static final String colors[] = &#123; "Red","Green","Blue","White","Black" &#125;; private static String getRandomColor() &#123; return colors[(int)(Math.random()*colors.length)]; &#125; private static int getRandomX() &#123; return (int)(Math.random()*100 ); &#125; private static int getRandomY() &#123; return (int)(Math.random()*100); &#125; public static void main(String[] args) &#123; for(int i=0; i &lt; 20; ++i) &#123; Circle circle = (Circle)ShapeFactory.getCircle(getRandomColor()); circle.setX(getRandomX()); circle.setY(getRandomY()); circle.setRadius(100); circle.draw(); &#125; &#125; &#125; 代理模式在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface Image &#123; void display();&#125;public class RealImage implements Image &#123; private String fileName; private void loadFromDisk(String fileName)&#123; System.out.println("Loading " + fileName); &#125; public RealImage(String fileName)&#123; this.fileName = fileName; loadFromDisk(fileName); &#125; @Override public void display() &#123; System.out.println("Displaying " + fileName); &#125; &#125;//代理类，代理了RealImage地功能public class ProxyImage implements Image&#123; private RealImage realImage; private String fileName; public ProxyImage(String fileName)&#123; this.fileName = fileName; &#125; @Override public void display() &#123; if(realImage == null)&#123; realImage = new RealImage(fileName); &#125; realImage.display(); &#125;&#125;public class ProxyPatternDemo &#123; public static void main(String[] args) &#123; Image image = new ProxyImage("test_10mb.jpg"); // 图像将从磁盘加载 image.display(); System.out.println(""); // 图像不需要从磁盘加载 image.display(); &#125;&#125; 责任链模式顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger)&#123; this.nextLogger = nextLogger; &#125; public void logMessage(int level, String message)&#123; if(this.level &lt;= level)&#123; write(message); &#125; if(nextLogger !=null)&#123; nextLogger.logMessage(level, message); &#125; &#125; abstract protected void write(String message); &#125;//public class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Standard Console::Logger: " + message); &#125;&#125;//public class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Standard Console::Logger: " + message); &#125;&#125;//public class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println("Standard Console::Logger: " + message); &#125;&#125;public class ChainPatternDemo &#123; //创建责任链 private static AbstractLogger getChainOfLoggers()&#123; AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; &#125; public static void main(String[] args) &#123; AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, "This is an information."); loggerChain.logMessage(AbstractLogger.DEBUG, "This is an debug level information."); loggerChain.logMessage(AbstractLogger.ERROR, "This is an error information."); &#125;&#125; 命令模式命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public interface Order &#123; void execute();&#125;public class Stock &#123; private String name = "ABC"; private int quantity = 10; public void buy()&#123; System.out.println("Stock [ Name: "+name+", Quantity: " + quantity +" ] bought"); &#125; public void sell()&#123; System.out.println("Stock [ Name: "+name+", Quantity: " + quantity +" ] sold"); &#125;&#125;public class BuyStock implements Order &#123; private Stock abcStock; public BuyStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.buy(); &#125;&#125;public class SellStock implements Order &#123; private Stock abcStock; public SellStock(Stock abcStock)&#123; this.abcStock = abcStock; &#125; public void execute() &#123; abcStock.sell(); &#125;&#125; public class Broker &#123; private List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;(); public void takeOrder(Order order)&#123; orderList.add(order); &#125; public void placeOrders()&#123; for (Order order : orderList) &#123; order.execute(); &#125; orderList.clear(); &#125;&#125; public class CommandPatternDemo &#123; public static void main(String[] args) &#123; Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); &#125;&#125; 解释器模式解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public interface Expression &#123; public boolean interpret(String context);&#125;public class TerminalExpression implements Expression &#123; private String data; public TerminalExpression(String data)&#123; this.data = data; &#125; @Override public boolean interpret(String context) &#123; if(context.contains(data))&#123; return true; &#125; return false; &#125;&#125;public class OrExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public OrExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) || expr2.interpret(context); &#125;&#125;public class AndExpression implements Expression &#123; private Expression expr1 = null; private Expression expr2 = null; public AndExpression(Expression expr1, Expression expr2) &#123; this.expr1 = expr1; this.expr2 = expr2; &#125; @Override public boolean interpret(String context) &#123; return expr1.interpret(context) &amp;&amp; expr2.interpret(context); &#125;&#125;public class InterpreterPatternDemo &#123; //规则：Robert 和 John 是男性 public static Expression getMaleExpression()&#123; Expression robert = new TerminalExpression("Robert"); Expression john = new TerminalExpression("John"); return new OrExpression(robert, john); &#125; //规则：Julie 是一个已婚的女性 public static Expression getMarriedWomanExpression()&#123; Expression julie = new TerminalExpression("Julie"); Expression married = new TerminalExpression("Married"); return new AndExpression(julie, married); &#125; public static void main(String[] args) &#123; Expression isMale = getMaleExpression(); Expression isMarriedWoman = getMarriedWomanExpression(); System.out.println("John is male? " + isMale.interpret("John")); System.out.println("Julie is a married women? " + isMarriedWoman.interpret("Married Julie")); &#125;&#125; 迭代器模式 迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public interface Iterator &#123; public boolean hasNext(); public Object next();&#125;public interface Container &#123; public Iterator getIterator();&#125;public class NameRepository implements Container &#123; public String names[] = &#123;"Robert" , "John" ,"Julie" , "Lora"&#125;; private class NameIterator implements Iterator &#123; int index; @Override public boolean hasNext() &#123; if(index &lt; names.length)&#123; return true; &#125; return false; &#125; @Override public Object next() &#123; if(this.hasNext())&#123; return names[index++]; &#125; return null; &#125; &#125; @Override public Iterator getIterator() &#123; return new NameIterator(); &#125;&#125;public class IteratorPatternDemo &#123; public static void main(String[] args) &#123; NameRepository namesRepository = new NameRepository(); for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123; String name = (String)iter.next(); System.out.println("Name : " + name); &#125; &#125;&#125; 中介者模式中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。 12345678910111213141516171819202122232425262728293031323334353637//中介public class ChatRoom &#123; public static void showMessage(User user, String message)&#123; System.out.println(new Date().toString() + " [" + user.getName() +"] : " + message); &#125;&#125;public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User(String name)&#123; this.name = name; &#125; public void sendMessage(String message)&#123; ChatRoom.showMessage(this,message); &#125;&#125;public class MediatorPatternDemo &#123; public static void main(String[] args) &#123; User robert = new User("Robert"); User john = new User("John"); robert.sendMessage("Hi! John!"); john.sendMessage("Hello! Robert!"); &#125;&#125; 备忘录模式备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Memento &#123; private String state; public Memento(String state)&#123; this.state = state; &#125; public String getState()&#123; return state; &#125; &#125;public class Originator &#123; private String state; public void setState(String state)&#123; this.state = state; &#125; public String getState()&#123; return state; &#125; public Memento saveStateToMemento()&#123; return new Memento(state); &#125; public void getStateFromMemento(Memento Memento)&#123; state = Memento.getState(); &#125;&#125;public class CareTaker &#123; private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;(); public void add(Memento state)&#123; mementoList.add(state); &#125; public Memento get(int index)&#123; return mementoList.get(index); &#125;&#125;public class MementoPatternDemo &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); CareTaker careTaker = new CareTaker(); originator.setState("State #1"); originator.setState("State #2"); //将state以Memeto对象保存到List中 careTaker.add(originator.saveStateToMemento()); originator.setState("State #3"); careTaker.add(originator.saveStateToMemento()); originator.setState("State #4"); //取出 System.out.println("Current State: " + originator.getState()); originator.getStateFromMemento(careTaker.get(0)); System.out.println("First saved State: " + originator.getState()); originator.getStateFromMemento(careTaker.get(1)); System.out.println("Second saved State: " + originator.getState()); &#125;&#125; 观察者模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class Subject &#123; private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); private int state; public int getState() &#123; return state; &#125; public void setState(int state) &#123; this.state = state; notifyAllObservers(); &#125; public void attach(Observer observer)&#123; observers.add(observer); &#125; //通知注册的观察者 public void notifyAllObservers()&#123; for (Observer observer : observers) &#123; observer.update(); &#125; &#125; &#125;public abstract class Observer &#123; protected Subject subject; public abstract void update();&#125;public class BinaryObserver extends Observer&#123; public BinaryObserver(Subject subject)&#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println( "Binary String: " + Integer.toBinaryString( subject.getState() ) ); &#125;&#125;public class OctalObserver extends Observer&#123; public OctalObserver(Subject subject)&#123; this.subject = subject; this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println( "Octal String: " + Integer.toOctalString( subject.getState() ) ); &#125;&#125;public class HexaObserver extends Observer&#123; public HexaObserver(Subject subject)&#123; this.subject = subject; //这里就很秀了 this.subject.attach(this); &#125; @Override public void update() &#123; System.out.println( "Hex String: " + Integer.toHexString( subject.getState() ).toUpperCase() ); &#125;&#125;public class ObserverPatternDemo &#123; public static void main(String[] args) &#123; Subject subject = new Subject(); //秀 new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println("First state change: 15"); subject.setState(15); System.out.println("Second state change: 10"); subject.setState(10); &#125;&#125; 状态模式在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public interface State &#123; public void doAction(Context context);&#125;public class StartState implements State &#123; public void doAction(Context context) &#123; System.out.println("Player is in start state"); context.setState(this); &#125; public String toString()&#123; return "Start State"; &#125;&#125;public class StopState implements State &#123; public void doAction(Context context) &#123; System.out.println("Player is in stop state"); context.setState(this); &#125; public String toString()&#123; return "Stop State"; &#125;&#125;public class Context &#123; private State state; public Context()&#123; state = null; &#125; public void setState(State state)&#123; this.state = state; &#125; public State getState()&#123; return state; &#125;&#125;public class StatePatternDemo &#123; public static void main(String[] args) &#123; Context context = new Context(); StartState startState = new StartState(); startState.doAction(context); System.out.println(context.getState().toString()); StopState stopState = new StopState(); stopState.doAction(context); System.out.println(context.getState().toString()); &#125;&#125; 空对象模式在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractCustomer &#123; protected String name; public abstract boolean isNil(); public abstract String getName();&#125;public class RealCustomer extends AbstractCustomer &#123; public RealCustomer(String name) &#123; this.name = name; &#125; @Override public String getName() &#123; return name; &#125; @Override public boolean isNil() &#123; return false; &#125;&#125;public class NullCustomer extends AbstractCustomer &#123; @Override public String getName() &#123; return "Not Available in Customer Database"; &#125; @Override public boolean isNil() &#123; return true; &#125;&#125;public class CustomerFactory &#123; public static final String[] names = &#123;"Rob", "Joe", "Julie"&#125;; public static AbstractCustomer getCustomer(String name)&#123; for (int i = 0; i &lt; names.length; i++) &#123; if (names[i].equalsIgnoreCase(name))&#123; return new RealCustomer(name); &#125; &#125; return new NullCustomer(); &#125;&#125;public class NullPatternDemo &#123; public static void main(String[] args) &#123; AbstractCustomer customer1 = CustomerFactory.getCustomer("Rob"); AbstractCustomer customer2 = CustomerFactory.getCustomer("Bob"); AbstractCustomer customer3 = CustomerFactory.getCustomer("Julie"); AbstractCustomer customer4 = CustomerFactory.getCustomer("Laura"); System.out.println("Customers"); System.out.println(customer1.getName()); System.out.println(customer2.getName()); System.out.println(customer3.getName()); System.out.println(customer4.getName()); &#125;&#125; 策略模式在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface Strategy &#123; public int doOperation(int num1, int num2);&#125;public class OperationAdd implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 + num2; &#125;&#125;public class OperationSubstract implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 - num2; &#125;&#125;public class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125;public class OperationMultiply implements Strategy&#123; @Override public int doOperation(int num1, int num2) &#123; return num1 * num2; &#125;&#125;public class StrategyPatternDemo &#123; public static void main(String[] args) &#123; //多个实现，可以接口名指向自己的任意一个实现引用 Context context = new Context(new OperationAdd()); System.out.println("10 + 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println("10 - 5 = " + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println("10 * 5 = " + context.executeStrategy(10, 5)); &#125;&#125; 模板模式在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125;public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println("Cricket Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Cricket Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Cricket Game Started. Enjoy the game!"); &#125;&#125;public class Football extends Game &#123; @Override void endPlay() &#123; System.out.println("Football Game Finished!"); &#125; @Override void initialize() &#123; System.out.println("Football Game Initialized! Start playing."); &#125; @Override void startPlay() &#123; System.out.println("Football Game Started. Enjoy the game!"); &#125;&#125;public class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125; 访问者模式在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public interface ComputerPart &#123; public void accept(ComputerPartVisitor computerPartVisitor);&#125;public class Keyboard implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125;public class Monitor implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125;public class Mouse implements ComputerPart &#123; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; computerPartVisitor.visit(this); &#125;&#125;public class Computer implements ComputerPart &#123; ComputerPart[] parts; public Computer()&#123; parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;; &#125; @Override public void accept(ComputerPartVisitor computerPartVisitor) &#123; for (int i = 0; i &lt; parts.length; i++) &#123; parts[i].accept(computerPartVisitor); &#125; computerPartVisitor.visit(this); &#125;&#125;public interface ComputerPartVisitor &#123; public void visit(Computer computer); public void visit(Mouse mouse); public void visit(Keyboard keyboard); public void visit(Monitor monitor);&#125;//访问者模式public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123; @Override public void visit(Computer computer) &#123; System.out.println("Displaying Computer."); &#125; @Override public void visit(Mouse mouse) &#123; System.out.println("Displaying Mouse."); &#125; @Override public void visit(Keyboard keyboard) &#123; System.out.println("Displaying Keyboard."); &#125; @Override public void visit(Monitor monitor) &#123; System.out.println("Displaying Monitor."); &#125;&#125;public class VisitorPatternDemo &#123; public static void main(String[] args) &#123; ComputerPart computer = new Computer(); computer.accept(new ComputerPartDisplayVisitor()); &#125;&#125; 模式MVC模式MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。 Model（模型） - 一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器。 View（视图） - 视图代表模型包含的数据的可视化。 Controller（控制器） -作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。 业务代表模型业务代表模式（Business Delegate Pattern）用于对表示层和业务层解耦。它基本上是用来减少通信或对表示层代码中的业务层代码的远程查询功能。在业务层中我们有以下实体。 客户端（Client） - 表示层代码可以是 JSP、servlet 或 UI java 代码。 业务代表（Business Delegate） - 一个为客户端实体提供的入口类，它提供了对业务服务方法的访问。 查询服务（LookUp Service） - 查找服务对象负责获取相关的业务实现，并提供业务对象对业务代表对象的访问。 业务服务（Business Service） - 业务服务接口。实现了该业务服务的实体类，提供了实际的业务实现逻辑。 组合实体模式组合实体模式（Composite Entity Pattern）用在 EJB 持久化机制中。一个组合实体是一个 EJB 实体 bean，代表了对象的图解。当更新一个组合实体时，内部依赖对象 beans 会自动更新，因为它们是由 EJB 实体 bean 管理的。以下是组合实体 bean 的参与者。 组合实体（Composite Entity） - 它是主要的实体 bean。它可以是粗粒的，或者可以包含一个粗粒度对象，用于持续生命周期。 粗粒度对象（Coarse-Grained Object） - 该对象包含依赖对象。它有自己的生命周期，也能管理依赖对象的生命周期。 依赖对象（Dependent Object） - 依赖对象是一个持续生命周期依赖于粗粒度对象的对象。 策略（Strategies） - 策略表示如何实现组合实体。 数据访问对象模式数据访问对象模式（Data Access Object Pattern）或 DAO 模式用于把低级的数据访问 API 或操作从高级的业务服务中分离出来。以下是数据访问对象模式的参与者。 数据访问对象接口（Data Access Object Interface） - 该接口定义了在一个模型对象上要执行的标准操作。 数据访问对象实体类（Data Access Object concrete class） - 该类实现了上述的接口。该类负责从数据源获取数据，数据源可以是数据库，也可以是 xml，或者是其他的存储机制。 模型对象/数值对象（Model Object/Value Object） - 该对象是简单的 POJO，包含了 get/set 方法来存储通过使用 DAO 类检索到的数据。 前端控制器模式前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。 调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。 视图（View） - 视图是为请求而创建的对象。 拦截过滤器模式拦截过滤器模式（Intercepting Filter Pattern）用于对应用程序的请求或响应做一些预处理/后处理。定义过滤器，并在把请求传给实际目标应用程序之前应用在请求上。过滤器可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。 过滤器（Filter） - 过滤器在请求处理程序执行请求之前或之后，执行某些任务。 过滤器链（Filter Chain） - 过滤器链带有多个过滤器，并在 Target 上按照定义的顺序执行这些过滤器。 Target - Target 对象是请求处理程序。 过滤管理器（Filter Manager） - 过滤管理器管理过滤器和过滤器链。 客户端（Client） - Client 是向 Target 对象发送请求的对象。 服务定位器模式服务定位器模式（Service Locator Pattern）用在我们想使用 JNDI 查询定位各种服务的时候。考虑到为某个服务查找 JNDI 的代价很高，服务定位器模式充分利用了缓存技术。在首次请求某个服务时，服务定位器在 JNDI 中查找服务，并缓存该服务对象。当再次请求相同的服务时，服务定位器会在它的缓存中查找，这样可以在很大程度上提高应用程序的性能。以下是这种设计模式的实体。 服务（Service） - 实际处理请求的服务。对这种服务的引用可以在 JNDI 服务器中查找到。 Context / 初始的 Context - JNDI Context 带有对要查找的服务的引用。 服务定位器（Service Locator） - 服务定位器是通过 JNDI 查找和缓存服务来获取服务的单点接触。 缓存（Cache） - 缓存存储服务的引用，以便复用它们。 客户端（Client） - Client 是通过 ServiceLocator 调用服务的对象。 传输对象模式传输对象模式（Transfer Object Pattern）用于从客户端向服务器一次性传递带有多个属性的数据。传输对象也被称为数值对象。传输对象是一个具有 getter/setter 方法的简单的 POJO 类，它是可序列化的，所以它可以通过网络传输。它没有任何的行为。服务器端的业务类通常从数据库读取数据，然后填充 POJO，并把它发送到客户端或按值传递它。对于客户端，传输对象是只读的。客户端可以创建自己的传输对象，并把它传递给服务器，以便一次性更新数据库中的数值。以下是这种设计模式的实体。 业务对象（Business Object） - 为传输对象填充数据的业务服务。 传输对象（Transfer Object） - 简单的 POJO，只有设置/获取属性的方法。 客户端（Client） - 客户端可以发送请求或者发送传输对象到业务对象。 设计模式及代码截图均源自菜鸟教程]]></content>
      <categories>
        <category>原理协议</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>设计模式</tag>
        <tag>示例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 和 Github]]></title>
    <url>%2F2017%2F06%2F12%2FGit-%E5%92%8C-Github%2F</url>
    <content type="text"><![CDATA[版本控制个人版本控制在进行开发的时候，程序需要经常性的修改，那么修改的时候就存在备份问题，当代码量较大修改频繁时，备份的及时性和备份的困难度就增加了。 团队版本控制当团队中多人协同开发同一个功能时，可能存在开发人员之间的版本互相覆盖问题。 版本控制特点 协同修改 对人可以并行地修改同一个文件。 数据备份 不仅保存数据当前地实际状态，还能保存文件提交地历史状态，可以回滚操作。 版本管理 保存版本时不保存重复数据，节约存储，提高运行效率。 权限控制 对团队中参与开发的人员进行权限控制，对其他开发人员贡献的代码进行审核。 历史记录 查看提交修改历史，版本回滚 分支管理 允许开发团队在工作过程中多条生产线同时推进任务，提高效率。###工具简介 集中式：SVN、CVS、VSS。以服务器为核心，容易出现单点故障问题。 分布式：GIT、Mercurial、Bazaar、Darcs，避免了单点故障。 GIT 优势 版本控制可在本地完成 完整性保证 添加大于删除和修改 分支操作快捷流畅 bash融合 结构 Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。 WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间，除了.git之外的都属于工作区。 .git：存放Git管理信息的目录，初始化仓库的时候自动创建。 Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。 Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。 Stash：是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。 本地操作初始化本地库1git init //在目录中将创建一个.git目录 设置签名设置一个用户信息，用于唯一标示身份，仅用于区分开发人员，信息和远程仓库无关。 签名分为项目级别和系统级别，签名的作用域不同，项目/仓库级别在本仓库中有效，优先使用仓库级别。签名必须设置才能执行操作。 12345git config user.name xxxgit config user.email xxx@xxx.comgit config --global user.name xxxgit config user.email xxx@xxx.com 1234567$ cat ~/.gitconfig[user] email = 1958862281@qq.com name = Wan9huan //全局签名存储在全局配置文件中//仓库签名保存在.git/config中 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133git status #查看状态git add #添加文件到缓存区git remove --cached #移除已经add的文件git commit #提交git commit -a -m"This is Message" #提交附带注释git log #查看日志git log --oneline #简洁查看git relog #查看日志和回滚步数git reset --hard HEAD^ #后退一步git reset --hard HEAD~3 #后退三步git reset --hard 2fedc85 #回到指定版本------------------------------------------------------------------------$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track)------------------------------------------------------------------------$ git statusOn branch masterUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) ReactDemo/ 2017-09-07.pngnothing added to commit but untracked files present (use "git add" to track)------------------------------------------------------------------------$ git add 2017-09-07.png$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) #从缓存区移除 new file: 2017-09-07.pngUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed)------------------------------------------------------------------------$ git commit[master (root-commit) c40dd30] Changes to be committed: new file: 2017-09-07.png#版本号 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 2017-09-07.png ----------------------------------------------------------------------- $ git status On branch masterYour branch is ahead of 'origin/master' by 1 commit. (use "git push" to publish your local commits)nothing to commit, working tree clean------------------------------------------------------------------------$ git log --oneline8b6ba42 (HEAD -&gt; master) Create A Book Text37c34e8 deleted: Photoshop_Set-Up.exe4cfa483 (origin/master) lasta2858e8 new4b3e03e aadc03544 Merge branch 'master' of https://github.com/wan9huan/myfiles9b3d010 all9382437 Delete background.pngbb31bd9 Changes to be committed: new file: icon 2.pngb386c61 a4366632 afc86b6a png for background------------------------------------------------------------------------$ git reflog8b6ba42 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: Create A Book Text37c34e8 HEAD@&#123;1&#125;: commit: deleted: Photoshop_Set-Up.exe4cfa483 (origin/master) HEAD@&#123;2&#125;: commit: lasta2858e8 HEAD@&#123;3&#125;: commit: new4b3e03e HEAD@&#123;4&#125;: commit: aadc03544 HEAD@&#123;5&#125;: pull: Merge made by the 'recursive' strategy.9b3d010 HEAD@&#123;6&#125;: commit: allbb31bd9 HEAD@&#123;7&#125;: commit: Changes to be committed:b386c61 HEAD@&#123;8&#125;: commit: a4366632 HEAD@&#123;9&#125;: commit: afc86b6a HEAD@&#123;10&#125;: commit (initial): png for background------------------------------------------------------------------------$ git reflog book.txt5997266 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: 第四次修改2fedc85 HEAD@&#123;1&#125;: commit: 第三次修改af72196 HEAD@&#123;2&#125;: commit: add a string8b6ba42 HEAD@&#123;3&#125;: commit: Create A Book Text------------------------------------------------------------------------//回滚、回到指定版本$ git reflog book.txt5997266 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: 第四次修改2fedc85 HEAD@&#123;1&#125;: commit: 第三次修改af72196 HEAD@&#123;2&#125;: commit: add a string8b6ba42 HEAD@&#123;3&#125;: commit: Create A Book Text$ cat book.txtThis is a Book Text333333333333333444444444444444$ git reset --hard af72196HEAD is now at af72196 add a string$ cat book.txtThis is a Book Text$ git reset --hard 2fedc85HEAD is now at 2fedc85 第三次修改$ cat book.txtThis is a Book Text333333333333333------------------------------------------------------------------------$ git reset --hard HEAD^ 后退一步$ git reset --hard HEAD~3 后退三步 Rest指令123git rest --soft #移动本地库指针git rest --mixed #移动本地库、重置暂存区git rest --hard #移动本地库、重置暂存区、重置工作区 比较文件差异1234567891011121314151617git diff #暂存区比较git diff Head #比较某一版本------------------------------------------------------------------------$ git diff book.txtdiff --git a/book.txt b/book.txtindex 48d8508..f2259a8 100644--- a/book.txt+++ b/book.txt@@ -1,2 +1,4 @@ This is a Book Text-333333333333333\ No newline at end of file+333333333333333+444444444444444+555555555555555\ No newline at end of file 分支 并行推进多个开发 分支彼此独立 热修复 12345678910111213141516171819202122232425262728293031git status #查看当前分支git branch -v #查看所有分支git branch xxx #创建分支git checkout xxx #切换分支------------------------------------------------------------------------$ git status -vOn branch master //主分支Your branch is ahead of 'origin/master' by 5 commits. (use "git push" to publish your local commits)nothing to commit, working tree clean$ git branch -v* master 828b1ab [ahead 5] commit all$ git branch hot_fix$ git checkout hot_fixSwitched to branch 'hot_fix'------------------------------------------------------------------------#分支合并1.切换到主分支2.执行 git merge xxxx--------------------------------------------------------------------------------git checkout xxxxgit merge xxxx------------------------------------------------------------------------ 冲突解决 发生文件冲突，进入冲突解决状态 打开文件可以查看到冲突内容 删除冲突标记并修改文件 提交完成合并分支 远程操作基本操作12345678910111213141516171819202122232425262728293031323334353637git remote -v#查看远程仓库git remote add(remove) xxx ht..com/xxx.git#添加远程仓库git push xxx master(填写推送分支)#推送到分支git clone https://git....../xxx/git#克隆远程库git fetch xxx master#下载远程内容git checkout xxx/master#切换到某个远程分支git checkout master#切换到本地分支git merge xxx/maser#合并本地和远程git pull#直接合并远程到本地------------------------------------------------------------------------$ git remote -vorigin https://github.com/wan9huan/myfiles.git (fetch)origin https://github.com/wan9huan/myfiles.git (push)$ git push origin masterEnumerating objects: 15, done.Counting objects: 100% (15/15), done.Delta compression using up to 4 threads.Compressing objects: 100% (11/11), done.Writing objects: 100% (14/14), 1.22 KiB | 138.00 KiB/s, done.Total 14 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), completed with 1 local object.To https://github.com/wan9huan/myfiles.git 4cfa483..828b1ab master -&gt; master------------------------------------------------------------------------#必须是远程仓库的成员才可以进行推送 冲突解决123#当不是基于最新版做出的修改无法进行推送#拉去远程资源进入冲突解决状态，解决冲突#提交再推送即可成功完成推送操作 跨团队协作 Fork一个远程仓库 进行修改开发 发起Pull Request 原仓库所有人审核 审核完毕，合并代码 SSH1234567ssh-keygen -t rsa -C|github账号# 生成 .ssh/ 目录 生成 id_rsa id_rsa.pub# 将公钥添加到远程端git remote add xxxx ssh版本的.gitgit push xxxx master#使用 ssh push 忽略文件1234567891011.gitconfig[core] excludesfile = xxxxx\xx.gitignorexx.gitignore.classpath.settings.projecttarget ... github 原理Hash算法哈希加密算法，不管运算前的数据有多大，进行哈希运算后，能得到固定长度的加密结果，同样的数据经过相同的算法，都能输出同样的结果，不同的数据得到同一个哈希值的可能性极小，不可逆。 版本控制机制数据保存为小型文件系统的一组快照，创建分支时，新建一个指向当前版本的指针。 Linux搭建依赖安装1234yum -y install policycoreutils openssh-server openssh-clients postfix policycoreutils-python#启动项systemctl enable postfix &amp;&amp; systemctl start postfix 下载安装包1234567891011121314151617181920212223242526272829303132333435https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum #选择一个安装包wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-11.0.6-ce.0.el7.x86_64.rpm#选择自己的安装包 e16 centos6 e17 centos7rpm -i gitlab-ce-11.0.6-ce.0.el7.x86_64.rpm *. *. *** *** ***** ***** .****** ******* ******** ******** ,,,,,,,,,***********,,,,,,,,, ,,,,,,,,,,,*********,,,,,,,,,,, .,,,,,,,,,,,*******,,,,,,,,,,,, ,,,,,,,,,*****,,,,,,,,,. ,,,,,,,****,,,,,, .,,,***,,,, ,*,. _______ __ __ __ / ____(_) /_/ / ____ _/ /_ / / __/ / __/ / / __ `/ __ \ / /_/ / / /_/ /___/ /_/ / /_/ / \____/_/\__/_____/\__,_/_.___/Thank you for installing GitLab!gitlab-ctl reconfigure//需要等待较长时间gitlab-clt restart CentOS 官方指导]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>GIT</tag>
        <tag>版本控制</tag>
        <tag>GitLab</tag>
      </tags>
  </entry>
</search>
