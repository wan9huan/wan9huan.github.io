<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis 使用详解]]></title>
    <url>%2F2018%2F09%2F17%2FMybatis-%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MyBatis 本是apache的一个开源项目iBatis 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 官方地址 简介使用123456789101112131415161718192021&lt;!--全局配置文件 mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;!-- 对应配置文件路径 * --&gt;&lt;/mappers&gt; &lt;/configuration&gt; 12345678910&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 对应接口全类名位置 ## --&gt; &lt;!-- 对应接口方法 ### --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; 12345//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlog(Integer id);&#125; Mybatis底层与数据库交互是使用SqlSession完成的，SqlSession非线程安全，每次使用应当获取新对象，mapper接口的实现由mybatis生成一个代理对象。 123456789public void test()&#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();SqlSession session = sqlSessionFactory.openSession(); try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(1); &#125; finally &#123; session.close(); &#125; &#125; 全局配置文件properties标签1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;properties resource="db.properties" url="网络路径/本地路径"&gt;&lt;/properties&gt; &lt;!--resource:类路径 url：网络路径/本地路径 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 12345#db.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mydql://localhost:3306/dbjdbc.username=usernamejdbc.password=password settings标签12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;settings&gt; &lt;setting name="mapUnderscoreToCamelCaseEnables " value="true" /&gt; &lt;!-- 驼峰命名适配 --&gt; &lt;setting name="jdbcTypeForNull" value="null"/&gt; &lt;!-- 空值映射为null --&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!-- 懒加载 --&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;!-- 按需加载 --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!--开启二级缓存 --&gt; &lt;/settings&gt;&lt;/configuration&gt; typeAliases标签12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;typeAliases&gt; &lt;typeAlias type="org.mybatis.example.bean.Blog" alias="blog"&gt;&lt;/typeAlias&gt; &lt;!-- mapper中就不用写全类名了，不写alias即默认为类名--&gt; &lt;package name="org.mybatis.example.bean"/&gt; &lt;!--当前包及其子包自动别名--&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; 123456&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- blog 别名使用--&gt; &lt;select id="selectBlog" resultType="blog"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; 1234567//通过@Alias注解使用别名//批量扫描注解优先@Alias("blog")public class Blog&#123; private Integer id; ...&#125; Alias(默认别名) Mapped Type _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal map Map plugins插件在四大对象执行前后进行拦截，原理为动态代理。 Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) environments标签123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="development"&gt; &lt;!--指定默认使用环境来快速切换环境--&gt; &lt;environment id="env"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;!-- 事务管理器 type: JDBC|MANAGED 自定义 --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 数据源配置 type：UNPOOLED|POOLED|JNDI 自定义--&gt; &lt;property name="driver" value="$&#123;oracle.driver&#125;"/&gt; &lt;property name="url" value="$&#123;oracle.url&#125;"/&gt; &lt;property name="username" value="$&#123;oracle.username&#125;"/&gt; &lt;property name="password" value="$&#123;oracle.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; databaseIdProvider标签12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;environments default="env"&gt; &lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="MySQL" value="mysql"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;/databaseIdProvider&gt;&lt;/configuration&gt; 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 发送带oracle的查询语句 --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" databsesId="oracle"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" databsesId="mysql"&gt;select * from Blog where id = #&#123;id&#125;&lt;/select&gt; &lt;/mapper&gt; mapper标签12345678910111213141516&lt;!--全局配置文件 mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;mappers&gt; &lt;mapper url=""&gt;&lt;/mapper&gt; &lt;!-- 磁盘路径 --&gt; &lt;mapper resource="org/mybatis/example/BlogMapper.xml"/&gt; &lt;!-- 类路径 --&gt; &lt;mapper class="org.mybatis.example.dao.BlogMapperAnnotation"/&gt; &lt;!--1. mapper和接口 同名同路径--&gt; &lt;!--2. 添加注解方法的接口--&gt; &lt;package name="org.mybatis.example.dao"/&gt; &lt;!-- 批量扫描 xml 接口 同包 --&gt; &lt;/mappers&gt; &lt;/configuration&gt; 123456//org.mybatis.example.dao.BlogMapperAnnotationpublic interface BlogMapperAnnotation&#123; // 对应mapper中方法 ### @Select("select * from Blog where id = #&#123;id&#125;") public Blog selectBlog(Integer id);&#125; 映射文件CRUD123456789//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlog(Integer id); public boolean insertdBlog(Blog blog); public Integer updateBlog(Blog blog); public boolean deleteBlog(Integer id); //自动返回 Integer 、Long、Boolean 类型&#125; 12345678910111213141516171819202122&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog set ... 字段 = #&#123;属性名&#125; where 字段 = #&#123;属性名&#125; &lt;/update&gt; &lt;delete id="deleteBlog"&gt; delete from Blog where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 自增主键123456789101112131415161718192021222324252627282930313233&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- mysql 等支持 自增主键 数据库--&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" useGeneratedKeys="true" keyProperty="#&#123;id&#125;" databaseId="mysql"&gt; &lt;!-- 使用自增主键策略 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;!-- Oracle 从序列中获取 111--&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" databaseId="oracle"&gt; &lt;selectKey KeyProperty="#&#123;id&#125;" order="BEFORE" resultTyoe"Integer"&gt; &lt;!-- 使用查询序列 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; select Blog_sql.nextval from dual &lt;/selectKey&gt; insert into Blog...values(#&#123;id&#125;,#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;!-- Oracle 从序列中获取 222 多条问题 --&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog" databaseId="oracle"&gt; &lt;selectKey KeyProperty="#&#123;id&#125;" order="AFTER" resultTyoe"Integer"&gt; &lt;!-- 使用查询序列 插入数据库操作完成后原插入对象的id属性将被赋值--&gt; select Blog_sql.currval from dual &lt;/selectKey&gt; insert into Blog...values(Blog_sql.nextval,#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;/mapper&gt; 参数处理多参数时，参数会封装成map，可以使用注解指定参数的关键字(key)。 123456789101112131415//## org.mybatis.example.dao.BlogMapperpublic interface BlogMapper&#123; // 对应mapper中方法 ### public Blog selectBlogById(Integer id); public Blog selectBlogByIdAndName(@Param("id")Integer id,@Param("name")String name); public Blog selectBlogByPojo(Blog blog); public Blog selectBlogByMap(Map&lt;String,Object&gt; map); public Blog selectBlogByCollection(List&lt;Integer&gt; list);&#125;Page&#123; int index； int size; List&lt;Blog&gt; list;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 单个参数 --&gt; &lt;!-- 当只有单个参数时，不会有任何处理 #&#123;任意填写&#125; 都可以取出参数--&gt; &lt;select id="selectBlogById" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 多个参数 --&gt; &lt;!-- 未指定参数名 --&gt; &lt;!-- 使用多个参数时，入参会被处理，参数会被封装为一个map--&gt; &lt;!-- 取值所用的key为 [ param1 ... paramN 0... n ]--&gt; &lt;select id="selectBlogByIdAndName" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;param1&#125; and name = #&#123;param2&#125; &lt;/select&gt; &lt;!-- 使用@Param（""） 注解指明接口中的参数后可以直接取用--&gt; &lt;!-- 原取参数规则仍旧适用 --&gt; &lt;select id="selectBlogByIdAndName" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入pojo --&gt; &lt;!-- 直接取用即可 --&gt; &lt;!-- 多参数包含对象时 param2.id 或注解后 blog.id --&gt; &lt;select id="selectBlogByPojo" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入 map --&gt; &lt;!-- 直接取用 按照存入map时的key 即取用的 key 和 存入map时 key 相同 --&gt; &lt;select id="selectBlogByMap" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = #&#123;name&#125; &lt;/select&gt; &lt;!-- 传入集合类型 --&gt; &lt;!-- 取出第一个参数 集合类型取参数使用 collection[0] 数组类型取参数使用 list[0] --&gt; &lt;select id="selectBlogByMap" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;list[0]&#125; &lt;/select&gt; &lt;/mapper&gt; $与#区别1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; and name = $&#123;name&#125;&lt;/select&gt; &lt;!-- 执行Sql：select * from Blog where id = ? and name = blog_01 --&gt; &lt;!-- #&#123;&#125; 采用预编译形式 可以防止sql注入发生 $&#123;&#125; 采用字符串拼串方式 可能被注入 --&gt; select * from $&#123;year&#125;_Blog where id =#&#123;id&#125; //分表 select * from Blog order by $&#123;name&#125; $&#123;order&#125; where id = #&#123;id&#125; //排序&lt;/mapper&gt; #{} 取值时可以对参数进行限定javaType、jdbcType、mode、numbericScale、resultMap、typeHandler、jdbcTypeName 12345&lt;!-- 部分数据库在字段为null 可能无法识别mybatis传入的null值 --&gt;&lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog values(#&#123;id&#125;，#&#123;name,jdbcType=Null&#125;) &lt;!-- name 为空 Oracle 数据库正常 默认映射为 jdbcType.OTHER --&gt;&lt;/insert&gt; 返回值处理123456public interface BlogMapper&#123; public List&lt;Blog&gt; selectBlogByName(String name); public Map&lt;Stirng,Object&gt; selectBlogMap(Integer id); @MapKey("id") public Map&lt;Stirng,Blog&gt; selectBlogMaps(String name);&#125; 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlogByName" resultType="org.mybatis.example.bean.Blog"&gt; &lt;!-- 返回为列表 返回类型为集合元素类型 Blog--&gt; select * from Blog where name like #&#123;name&#125; &lt;/select&gt; &lt;select id="selectBlogMap" resultType="map"&gt; &lt;!-- 返回值为map 返回类型为 map --&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectBlogByName" resultType="org.mybatis.example.bean.Blog"&gt; &lt;!-- 返回为map&lt;String,Blog&gt; 返回类型为集合元素类型 Blog--&gt; &lt;!-- 接口使用注解修饰 @MapKey("id") 标注map的key使用哪个字段 --&gt; select * from Blog where name like #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; resultMap自定义结果集 12345678910111213141516&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--自定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result colume="regist_time" property="reistTime"/&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 级联查询 1234567891011121314151617&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--级联查 属性 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="group_id" property="group.id"&gt; &lt;result column="group_name" property="group.name"&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog b,Group g where b.id = g.id and b.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; association12345678910111213141516171819&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!--级联查 联合 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;association property="org.mybatis.example.bean.Group"&gt; &lt;id column "group_id" property="id"/&gt; &lt;result column="group_name" property="name"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select (distinct)* from Blog b,Group g where b.id = g.id and b.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 分步查询 12345678910111213141516171819&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 联合 分步查询 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;association property="group" select="org.mybatis.example.dao.GroupMapper.getGroupById" column="group_id"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog &lt;/select&gt; &lt;/mapper&gt; 懒加载 12345&lt;!-- 分步查询的条件下 在全局配置文件中开启懒加载 按需加载等功能 即可--&gt;&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;!-- 懒加载 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;!-- 按需加载 --&gt; collection1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.GroupMapper"&gt; &lt;resultMap type="org.mybatis.example.bean.Group" id="CustomizeGroup"&gt; &lt;id column="group_id" property="id"/&gt; &lt;result column="group_name" property="name"/&gt; &lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 一个组中包含多个Blog --&gt; &lt;select id="selectBlog" resultMap="CustomizeGroup"&gt; select * from Group g left join Blog b on g.id = b.id where g.id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 分步查询 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.GroupMapper"&gt; &lt;resultMap type="org.mybatis.example.bean.Group" id="CustomizeGroup"&gt; &lt;id column="group_id" property="id"/&gt; &lt;result column="group_name" property="name"/&gt; &lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog" select="org.mybatis.example.dao.GroupMapper.selectBlogByGroupId" column="id"&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;!-- 一个组中包含多个Blog --&gt; &lt;select id="selectBlog" resultMap="CustomizeGroup"&gt; select * from Group &lt;/select&gt; &lt;/mapper&gt; 懒加载 123456&lt;!-- 同上一个示例 --&gt;&lt;!-- 分步查询的条件下 在全局配置文件中开启懒加载 按需加载等功能 即可--&gt;&lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;!-- 懒加载 --&gt;&lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;!-- 按需加载 --&gt; 传递多参 手动懒加载 12345&lt;collection property="blogs" ofType="org.mybatis.example.bean.Blog" select="org.mybatis.example.dao.GroupMapper.selectBlogByGroupId" column="&#123;group_id = id&#125;" fetchType="lazy"&gt; &lt;!-- column="&#123;key1=column1,key2=column2&#125; fetchType="lazy|eager"--&gt;&lt;/collection&gt; discriminator1234567891011121314151617181920212223242526272829&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;!-- 联合 分步查询 定义结果规则 resultMap --&gt; &lt;resultMap type="org.mybatis.example.bean.Blog" id="CustomizeBlog"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="name" property="name"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;discriminator javaType="sex" column="string"&gt; &lt;case value="0" resultType=""&gt; &lt;association property="group" select="org.mybatis.example.dao.GroupMapper.getGroupById" column="group_id"&gt; &lt;/association&gt; &lt;/case&gt; &lt;case value="1" resultType="org.mybatis.example.bean.Blog"&gt; &lt;result column="sex" property="name"/&gt; &lt;/case&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;select id="selectBlog" resultMap="CustomizeBlog"&gt; select * from Blog &lt;/select&gt; &lt;/mapper&gt; 动态SQLIF标签1234567public class User&#123; private int id; private String name; private String sex; private String email; private Dept dept;&#125; 123public class UserMapper&#123; public List&lt;User&gt; getUsersbyIf(User user);&#125; 1234567891011121314&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user where&lt;!-- 1=1 --&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125;&lt;!-- and id=#&#123;id&#125; --&gt; &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; and sex=#&#123;sex&#125; &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;/select&gt; &lt;/mapper&gt;&lt;!-- 当没有id时 sql语句会出现问题 --&gt; WHERE标签12345678910111213141516&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;where&gt; &lt;if test="id!=null"&gt; id=#&#123;id&#125; &lt;!-- id=#&#123;id&#125; and --&gt; &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; and sex=#&#123;sex&#125; &lt;!-- id=#&#123;id&#125; and--&gt; &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; and email=#&#123;email&#125; &lt;!-- email=#&#123;email&#125; --&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; &lt;!-- and后置不好使 --&gt; TRIM标签123456789101112131415&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;trim prefix="where" prefixOverrides="xxx" suffix="" suffixOverrides="and"&gt; &lt;!-- 添加 where 前缀 覆盖xxx 添加后缀 覆盖and --&gt; &lt;if test="id!=null"&gt; xxx id=#&#123;id&#125; and &lt;/if&gt; &lt;if test="sex != null and sex != '' "&gt; sex=#&#123;sex&#125; and &lt;/if&gt; &lt;if test="email!=null and email.trim()!='' "&gt; email=#&#123;email&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; CHOOSE标签12345678910111213&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user &lt;where&gt; &lt;choose&gt; &lt;when test="id!=null"&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;when test="sex!=null"&gt;sex=#&#123;sex&#125;&lt;/when&gt; &lt;when test"emall!=null and emall!=''"&gt; email=#&#123;email&#125;&lt;/when&gt; &lt;otherwith&gt;1 = 1&lt;/otherwith&gt; &lt;/choose&gt; &lt;!-- 只会进入第一个配置成功的条件 如传入id和sex 只会查询 id --&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; SET标签12345678910&lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog &lt;set&gt; &lt;if test="属性！=null and 属性！='' "&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;if test="..."&gt;字段 = #&#123;属性名&#125;,&lt;/if&gt; &lt;/set&gt;&lt;!-- 作用就是可以在插入的时候正确去掉最后一个逗号 --&gt; where 字段 = #&#123;属性名&#125;&lt;/update&gt; FOREACH标签12345678&lt;!-- 传入一个包含多个id的List --&gt;&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; select * from user where id in( &lt;foreach collection="users_id" item="user_id" separator="," open"(" close=")"&gt; &lt;!--还可以添加index属性 遍历List时 index为索引 遍历map时index为键值--&gt; #&#123;user_id&#125; &lt;/foreach&gt;&lt;/select&gt; Bind标签123456&lt;!-- 例如：模糊查询拼串 --&gt;&lt;select id="getUsersbyIf" resultMap="com.wang.test.bean.User"&gt; &lt;bind name="_name" value="'%'+name+'%'"&gt; select * from user where name like #&#123;_name&#125; &lt;!-- 不安全 select * from user where name like '%$&#123;name&#125;%' --&gt;&lt;/select&gt; 内置参数_parameter 单个参数：_parameter为这个参数多个参数：_parameter为封装map _databaseId 当全局配置中配置了DatabaseIdProvider标签时，_databaseId代表当前数据库的别名。 1public List&lt;User&gt; getUser(User user); 12345678910111213141516&lt;select id="getUser" resultMap="com.wang.test.bean.User"&gt; &lt;if test="_databaseId=='oracle' "&gt; select * from oracle_user &lt;if test="_parameter!=null"&gt; where sex = #&#123;_parameter.sex&#125; &lt;/if&gt; &lt;/if&gt; &lt;if test="_databaseId=='mysql'"&gt; select * from user &lt;if test="_parameter!=null"&gt; where sex = #&#123;_parameter.sex&#125; &lt;/if&gt; &lt;/if&gt; &lt;/select&gt; SQL标签123456789&lt;!-- 抽取常用的相同的sql片段，使用时引入即可 --&gt;&lt;sql id="insColm"&gt; id,name,sex,dept_id&lt;/sql&gt;&lt;insert&gt; insert into user( &lt;include refid="insColm"/&gt;) values ...&lt;/insert&gt; 批量保存Mysql 批量方式一 1public void saveUsers(@Param("users")List&lt;User&gt;); 123456789&lt;!-- 批量保存 --&gt;&lt;!-- Mysql 方式 --&gt;&lt;!-- insert into user values (),(),() --&gt;&lt;insert id="saveUsers"&gt; insert into user values &lt;foreach collection="users" item="user" separator=","&gt; (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方式二 1234567&lt;insert id="saveUsers"&gt;&lt;!-- insert into user values ();insert into user values ();insert into user values (); --&gt; &lt;foreach collection="users" item="user" separator=";"&gt; insert into user values (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; &lt;!-- 开启数据库的连接属性 jdbc:mysql//lo....?allowMultiQueries=true--&gt; Oracle 批量保存方式一 1234567891011121314&lt;!-- 批量保存 --&gt;&lt;!-- Oracle 方式 --&gt;&lt;!-- 代码块 begin insert into user values (),(),()； insert into user values (),(),()； insert into user values (),(),()； end； --&gt;&lt;insert id="saveUsers" databaseId="oracle"&gt; &lt;foreach collection="users" item="user" separator=";" open="begin" close="end;"&gt; insert into user values (#&#123;user.id&#125;,#&#123;user.name&#125;,#&#123;user.email&#125;,#&#123;dept.id&#125;) &lt;/foreach&gt;&lt;/insert&gt; 方式二 12345678910111213141516171819&lt;!-- 批量保存 --&gt;&lt;!-- Oracle 方式 --&gt;&lt;!-- 中间表方式 insert into user(id,name,email,dept_id) select user_seq.nextval,name,email,dept_id from( select 'value1' name,'value2' email,'value3' dept_id from dual union select 'value1' name,'value2' email,'value3' dept_id from dual union select 'value1' name,'value2' email,'value3' dept_id from dual ) --&gt;&lt;insert id="saveUsers" databaseId="oracle"&gt; insert into user(id,name,email,dept_id) select user_seq.nextval,name,email,dept_id from &lt;foreach collection="users" item="user" separator="union" open="(" close=")" &gt; select #&#123;user.id&#125; name,#&#123;user.email&#125; email,#&#123;user.dept.id&#125; dept_id from dual &lt;/foreach&gt;&lt;/insert&gt; 缓存一级缓存默认只开启一级缓存，一级缓存时SqlSession级别的缓存，这也就是说处在数据库相同会话中的操作，数据会被缓存，查询可以取到缓存值，减少查询次数。当然缓存会有他的存在时间和区域。缓存失效情况： 不同的SqlSession对象 相同SqlSession查询条件不同 相同SqlSession查询间隔数据操作 相同SqlSession查询前清空缓存 二级缓存全局缓存，基于命名空间级别的缓存，一个命名空间对应一个二级缓存。当会话关闭时，一级缓存中的数据会被保存到二级缓存中。12345678#redis.propertiesredis.host=127.0.0.1redis.port=6379redis.pass=123456redis.maxIdle=200redis.maxActive=1024redis.maxWait=10000redis.testOnBorrow=true 12345678910111213141516171819202122232425262728293031&lt;!-- applicationContext-redis.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd "&gt;&lt;!-- 连接池基本参数配置，类似数据库连接池 --&gt; &lt;context:property-placeholder location="classpath:redis.properties" ignore-unresolvable="true"/&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="$&#123;redis.maxActive&#125;"/&gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;"/&gt; &lt;/bean&gt; &lt;!-- 连接池配置，类似数据库连接池 --&gt; &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="hostName" value="$&#123;redis.host&#125;"&gt;&lt;/property&gt; &lt;property name="port" value="$&#123;redis.port&#125;"&gt;&lt;/property&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.pass&#125;"&gt;&lt;/property&gt; --&gt; &lt;property name="poolConfig" ref="poolConfig"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="redisCacheTransfer" class="cn.qlq.jedis.RedisCacheTransfer"&gt; &lt;property name="jedisConnectionFactory" ref="jedisConnectionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public class RedisCache implements Cache &#123; // 初始化Jedis private Jedis jedis = new Jedis("127.0.0.1", 6379); private String cacheId; /* * MyBatis会把映射文件的命名空间作为 * 唯一标识cacheId，标识这个缓存策略属于哪个namespace * 这里定义好，并提供一个构造器，初始化这个cacheId即可 */ public RedisCache (String cacheId)&#123; this.cacheId = cacheId; &#125; /** * 清空缓存 */ @Override public void clear() &#123; // 但这方法不建议实现 &#125; @Override public String getId() &#123; return cacheId; &#125; /** * MyBatis会自动调用这个方法检测缓存 * 中是否存在该对象。既然是自己实现的缓存 * ，那么当然是到Redis中找了。 */ @Override public Object getObject(Object arg0) &#123; // arg0 在这里是键 try &#123; byte [] bt = jedis.get(SerializableTools.ObjToByteArray(arg0)); if (bt == null) &#123; // 如果没有这个对象，直接返回null return null; &#125; return SerializableTools.byteArrayToObj(bt); &#125; catch (Exception e) &#123;e.printStackTrace();&#125; return null; &#125; @Override public ReadWriteLock getReadWriteLock() &#123; return new ReentrantReadWriteLock(); &#125; @Override public int getSize() &#123; return Integer.parseInt(Long.toString(jedis.dbSize())); &#125; /** * MyBatis在读取数据时，会自动调用此方法 * 将数据设置到缓存中。这里就写入Redis */ @Override public void putObject(Object arg0, Object arg1) &#123; /* * arg0是key , arg1是值 * MyBatis会把查询条件当做键，查询结果当做值。 */ try &#123; jedis.set(SerializableTools.ObjToByteArray(arg0), SerializableTools.ObjToByteArray(arg1)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * MyBatis缓存策略会自动检测内存的大小，由此 * 决定是否删除缓存中的某些数据 */ @Override public Object removeObject(Object arg0) &#123; Object object = getObject(arg0); try &#123; jedis.del(SerializableTools.ObjToByteArray(arg0)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return object; &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class SerializableTools &#123; /** * 反序列化 * * @param bt * @return * @throws IOException * @throws Exception */ public static Object byteArrayToObj(byte[] bt) throws Exception &#123; ByteArrayInputStream bais = new ByteArrayInputStream(bt); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; /** * 对象序列化 * * @param obj * @return * @throws IOException */ public static byte[] ObjToByteArray(Object obj) throws IOException &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(obj); return bos.toByteArray(); &#125;&#125; 整合Redis，配置好Redis与Spring的集成后，重写Cache接口，在mapper的缓存标签中使用自定义的实现即可，即在type中写自己的实现，在Springboot中整合更容易，使用系统提供的注解并重写缓存序列化方法即可。 12345678910111213141516&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;cache eviction="FIFO" flushInterval="60000" readOnly="false" size="1024" type="自定义缓存实现"&gt; &lt;!-- 对应接口方法 ### --&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog" useCache="true"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 增删改默认缓存清空--&gt; &lt;insert flushCache="true" /&gt;&lt;/mapper&gt;&lt;!-- 全局配置开启 --&gt;&lt;setting name="cacheEnabled" value="true"/&gt; eviction:缓存回收策略 LRU(默认) 最近最少使用的将缓存，移除长时间不使用的对象 FIFO 先进先出，按照队列方式处理缓存 SOFT 软引用，基于垃圾回收器状态和软引用规则来移除对象缓存 WEAK 弱引用，积极移除基于垃圾收集器状态和弱引用规则的对象缓存 flushInterval: 缓存刷新间隔 默认不清空缓存，单位为毫秒。 readOnly 读写性，为真只读，直接传递引用，为假可改，使用序列化反序列化，默认为假，POJO对象必须实现序列化接口。 size 缓存存放元素个数 type 指定自定义缓存的全类名，当引入第三方缓存框架时，通过实现提供的接口，即可接管缓存工作。 框架整合123456&lt;!-- mybatis-config.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; &lt;configuration&gt; &lt;!-- 进行一些个性化配置 --&gt;&lt;/configuration&gt; 1234567891011121314151617181920212223&lt;!-- mapper 存放位置无要求 --&gt;&lt;!-- * org/mybatis/example/BlogMapper.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="org.mybatis.example.dao.BlogMapper"&gt; &lt;select id="selectBlog" resultType="org.mybatis.example.bean.Blog"&gt; select * from Blog where id = #&#123;id&#125; &lt;/select&gt; &lt;insert id="insertdBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; insert into Blog...values(#&#123;属性名&#125;，#&#123;属性名&#125;) &lt;/insert&gt; &lt;update id="updateBlog" parameterType ="org.mybatis.example.bean.Blog"&gt; update Blog set ... 字段 = #&#123;属性名&#125; where 字段 = #&#123;属性名&#125; &lt;/update&gt; &lt;delete id="deleteBlog"&gt; delete from Blog where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- applicationContext.xml --&gt;&lt;beans ...&gt; &lt;context:component-scan base-package="org.mybatis.example" use-default-filters="false"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!--数据源 --&gt; &lt;context:property-placeholder location="classpath:db.properties"&gt; &lt;bean id="datasource" class="com....."&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt; &lt;property name="..." value=""&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 注解事务 声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="datasource"&gt;&lt;/property&gt; &lt;!-- 配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt; &lt;!-- 别名 --&gt; &lt;property name="typeAliasesPackage" value="org.mybatis.example.bean"&gt;&lt;/property&gt; &lt;!-- sql映射文件路径 --&gt; &lt;property name="mapperLocations" value="classpath*:mybatis/mapper/*Mapper.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mybatis-spring:scan base-package="org.mybatis.example.dao"&gt; &lt;/beans&gt; 12345678910111213141516&lt;!-- spring-servlet.xml--&gt;...&lt;beans ...&gt; &lt;!-- 只扫描Controller --&gt; &lt;context:component-scan base-package="org.mybatis.example" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.Controller"/&gt; &lt;/context:component-scan&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;mvc:default-servlet-handler/&gt; &lt;/beans&gt; 逆向工程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!-- generator.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- targetRuntime="MyBatis3Simple":生成简单版的CRUD MyBatis3:豪华版 --&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- --&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator：指定javaBean的生成策略 targetPackage="test.model"：目标包名 targetProject="\MBGTestProject\src"：目标工程 --&gt; &lt;javaModelGenerator targetPackage="com.test.mybatis.bean" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：sql映射生成策略： --&gt; &lt;sqlMapGenerator targetPackage="com.test.mybatis.dao" targetProject=".\conf"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.test.mybatis.dao" targetProject=".\src"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt; &lt;table tableName="tbl_dept" domainObjectName="Department"&gt;&lt;/table&gt; &lt;table tableName="tbl_employee" domainObjectName="Employee"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 1234567891011public void testMbg() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("generator.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null);&#125; 存储过程1234567public class Page&#123; private int start; private int end; private int count; private List&lt;User&gt; users; ...&#125; 1234567create or replace procedure page_select(p_start in int,p_end in int,p_count out int,p_emps out sys_refcursor)begin select count(*) into p_count from user; open p_emps for select * from (select rownnum rn,e.* from user where rownum &lt;= p_end) where rn&gt;p_start;end 1public void pageSelect(Page page); 123456&lt;resultMap type="org.mybatis.example.bean.User" id="PageUser"&gt; ...&lt;/resultMap&gt;&lt;select id="pageSelect" resultType="org.mybatis.example.bean.Page" statementType="CALLABLE"&gt; &#123;call page_select(#&#123;start,mode=IN,jdbcType=INTEGER&#125;,#&#123;end,mode=IN,jdbcType=INTETER&#125;,#&#123;count,mode=OUT,jdbcType=INTEGER&#125;,#&#123;emps,mode=OUT,jdbcType=CURSOR,javaType=ResultSet,resultMap=PageUser&#125;)&#125;&lt;/select&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>XMl配置</tag>
        <tag>整合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 使用方法]]></title>
    <url>%2F2018%2F09%2F17%2FSpring-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简介Spring是一个开放源代码的设计层面框架，他解决的是业务逻辑层和其他各层的松耦合问题，因此它将面向接口的编程思想贯穿整个系统应用。轻量级非入侵式框架，简化企业级应用开发，IOC(DI)、AOP容器框架。 使用方法 1234567891011121314151617&lt;!-- server.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 12345678910111213141516171819&lt;!-- dao.xml --&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt; 12345678/ create and configure beansApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");// retrieve configured instancePetStoreService service = context.getBean("petStore", PetStoreService.class);// use configured instanceList&lt;String&gt; userList = service.getUsernameList(); Bean概述Spring 的Loc容器管理一个或多个bean，这些bean使用容器给定的配置，在容器中，这些bean会被定义为BeanDefinition对象将包含： Bean实现的类全类名 Bean的行为元素，作用域，生命周期回调等 引用bean执行其工作所需的其他bean，这些引用也称为协作者或依赖关系。 在新创建的对象中要设置的其他配置设置，例如，管理连接池的bean中要使用的连接数，或池的大小限制。 Bean定义属性 Property Explained in… class Instantiating beans name Naming beans scope Bean scopes constructor arguments Dependency Injection properties Dependency Injection autowiring mode Autowiring collaborators lazy-initialization mode Lazy-initialized beans initialization method Initialization callbacks destruction method Destruction callbacks 构造实例化123&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt; 静态工厂实例化123&lt;bean id="clientService" class="examples.ClientService" factory-method="createInstance"/&gt; 12345678public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; public static ClientService createInstance() &#123; return clientService; &#125;&#125; 工厂实例化123456789&lt;!-- the factory bean, which contains a method called createInstance() --&gt;&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;!-- the bean to be created via the factory bean --&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt; 12345678public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125;&#125; 一个工厂多个工厂方法 1234567891011&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id="clientService" factory-bean="serviceLocator" factory-method="createClientServiceInstance"/&gt;&lt;bean id="accountService" factory-bean="serviceLocator" factory-method="createAccountServiceInstance"/&gt; 1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; 依赖注入依赖注入(Dependency injection)是一个对象定义其依赖关系的过程，也就是说，与之协作的其他对象，如通过构造参数、工厂参数、属性等，将在本对象构造后或从工厂方法返回后进行注入。这个过程从根本上说就是bean本身的逆过程，bean本身通过类的构造或服务定位控制其他依赖对象的实例化或位置。 构造器注入下面的例子说明，通过构造器注入了一个依赖，这个依赖中的逻辑部分被注入方式隐藏，即这个只需注入依赖即可完成对应功能实现。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on a MovieFinder private MovieFinder movieFinder; // a constructor so that the Spring container can inject a MovieFinder public SimpleMovieLister(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; xml编写方式 构造器注入的参数是已知类型的bean时，在构造参数上不需要指定参数的类型，直接进行引用即可。 12345678package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ...两个构造参数 &#125;&#125; 123456789101112&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;/bean&gt; &lt;!-- 声明这个bean --&gt; &lt;!-- --&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt;&lt;/beans&gt; 当注入的参数是简单类型，即无法确定类型的时候，可以进行类型指定或者参数的索引位置指定或参数名称指定。 123456789101112131415package examples;public class ExampleBean &#123; // Number of years to calculate the Ultimate Answer private int years; // The Answer to Life, the Universe, and Everything private String ultimateAnswer; public ExampleBean(int years, String ultimateAnswer) &#123; this.years = years; this.ultimateAnswer = ultimateAnswer; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg type="int" value="7500000"/&gt; &lt;constructor-arg type="java.lang.String" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg index="0" value="7500000"/&gt; &lt;constructor-arg index="1" value="42"/&gt;&lt;/bean&gt;----------------------------------------------------------&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;constructor-arg name="years" value="7500000"/&gt; &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;&lt;/bean&gt; 属性注入下面示例中，依赖使用了一个属性，而这个属性的注入方式是使用的类中的set方法完成的。 123456789101112public class SimpleMovieLister &#123; // the SimpleMovieLister has a dependency on the MovieFinder private MovieFinder movieFinder; // a setter method so that the Spring container can inject a MovieFinder public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125; // business logic that actually uses the injected MovieFinder is omitted...&#125; 属性注入示例,可以书写引用属性也可以使用字引用标签的方式。 12345678910111213&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- setter injection using the nested ref element --&gt; &lt;property name="beanOne"&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/property&gt; &lt;!-- setter injection using the neater ref attribute --&gt; &lt;property name="beanTwo" ref="yetAnotherBean"/&gt; &lt;property name="integerProperty" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 1234567891011121314151617181920public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public void setBeanOne(AnotherBean beanOne) &#123; this.beanOne = beanOne; &#125; public void setBeanTwo(YetAnotherBean beanTwo) &#123; this.beanTwo = beanTwo; &#125; public void setIntegerProperty(int i) &#123; this.i = i; &#125;&#125; 此示例使用构造器方式实现上面的属性注入方式，用于对比两种注入方式。 123456789101112131415public class ExampleBean &#123; private AnotherBean beanOne; private YetAnotherBean beanTwo; private int i; public ExampleBean( AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123; this.beanOne = anotherBean; this.beanTwo = yetAnotherBean; this.i = i; &#125;&#125; 1234567891011121314&lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;!-- constructor injection using the nested ref element --&gt; &lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt; &lt;/constructor-arg&gt; &lt;!-- constructor injection using the neater ref attribute --&gt; &lt;constructor-arg ref="yetAnotherBean"/&gt; &lt;constructor-arg type="int" value="1"/&gt;&lt;/bean&gt;&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt; 详细依赖及配置直接给定值直接给定的如初始值、字符串等。 1234567891011121314151617181920212223&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- results in a setDriverClassName(String) call --&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="masterkaoli"/&gt;&lt;/bean&gt;&lt;!-- 还可以引入P命名空间来简化&lt;property&gt;标签的编写 这有那么一点点秀 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:driverClassName="com.mysql.jdbc.Driver" p:url="jdbc:mysql://localhost:3306/mydb" p:username="root" p:password="masterkaoli"/&gt;&lt;/beans&gt; ###引用其他 在需要注入的位置直接添加引用属性或引用标签既可以 123456&lt;constructor-arg&gt; &lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;&lt;!-- constructor injection using the neater ref attribute --&gt;&lt;constructor-arg ref="yetAnotherBean"/&gt; 父子容器，用子容器中的bean代理父容器中的bean 12345678910111213&lt;!-- in the parent context --&gt;&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt; &lt;!-- insert dependencies as required as here --&gt;&lt;/bean&gt;&lt;!-- in the child (descendant) context --&gt;&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt; class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt; &lt;/property&gt; &lt;!-- insert other configuration and dependencies as required here --&gt;&lt;/bean&gt; 内部创建可以在bean的property标签内继续创建新的bean，内部bean可以没有id属性 123456789&lt;bean id="outer" class="..."&gt; &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt; &lt;property name="target"&gt; &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt; &lt;property name="name" value="Fiona Apple"/&gt; &lt;property name="age" value="25"/&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 集合类型赋值12345678910111213141516171819202122232425262728293031&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt; &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt; &lt;prop key="support"&gt;support@example.org&lt;/prop&gt; &lt;prop key="development"&gt;development@example.org&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- results in a setSomeList(java.util.List) call --&gt; &lt;property name="someList"&gt; &lt;list&gt; &lt;value&gt;a list element followed by a reference&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setSomeMap(java.util.Map) call --&gt; &lt;property name="someMap"&gt; &lt;map&gt; &lt;entry key="an entry" value="just some string"/&gt; &lt;entry key ="a ref" value-ref="myDataSource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setSomeSet(java.util.Set) call --&gt; &lt;property name="someSet"&gt; &lt;set&gt; &lt;value&gt;just some string&lt;/value&gt; &lt;ref bean="myDataSource" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 属性值合并为集合 12345678910111213141516171819&lt;beans&gt; &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt; &lt;property name="adminEmails"&gt; &lt;props&gt; &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.com&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="child" parent="parent"&gt; &lt;property name="adminEmails"&gt; &lt;!-- the merge is specified on the child collection definition --&gt; &lt;props merge="true"&gt;&lt;!-- 这里将会合并 例如 setAdminEmils 传入一个map --&gt; &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt; &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;beans&gt; 强类型集合，当集合中的数据需要进行类型转换时，spring将自动完成类型转换工作 12345678public class Foo &#123; private Map&lt;String, Float&gt; accounts; public void setAccounts(Map&lt;String, Float&gt; accounts) &#123; this.accounts = accounts; &#125;&#125; 1234567891011&lt;beans&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="accounts"&gt; &lt;map&gt; &lt;entry key="one" value="9.99"/&gt; &lt;entry key="two" value="2.75"/&gt; &lt;entry key="six" value="3.99"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 空值规定空参数视为空字符串，null标签处理null值 123456789&lt;bean class="ExampleBean"&gt; &lt;property name="email" value=""/&gt;&lt;/bean&gt;&lt;bean class="ExampleBean"&gt; &lt;property name="email"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; C&amp;P属性标签12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:c="http://www.springframework.org/schema/c" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="bar" class="x.y.Bar"/&gt; &lt;bean id="baz" class="x.y.Baz"/&gt; &lt;!-- traditional declaration --&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;constructor-arg ref="bar"/&gt; &lt;constructor-arg ref="baz"/&gt; &lt;constructor-arg value="foo@bar.com"/&gt; &lt;property name="email" value="foo@bar.com"/&gt; &lt;/bean&gt; &lt;!-- c-namespace declaration --&gt; &lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com" p:email="foo@bar.com"/&gt;&lt;/beans&gt; 提前加载意思就是说，我这个bean在实例化前，你还得给我准备好我依赖的bean 12&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;&lt;bean id="manager" class="ManagerBean" /&gt; 懒加载1234567&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" lazy-init="true"/&gt;&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;&lt;!-- 容器级别的懒加载 --&gt;&lt;beans default-lazy-init="true"&gt; &lt;!-- no beans will be pre-instantiated... --&gt;&lt;/beans&gt; 方法注入查找方式，使用cglib动态代理方式，生成代理子类 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager &#123; public Object process(Object commandState) &#123; // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); &#125; // okay... but where is the implementation of this method? protected abstract Command createCommand();&#125; 12345678910&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt; &lt;lookup-method name="createCommand" bean="myCommand"/&gt; &lt;!-- 还可以使用@Lookup（"myCommand"） 注解标注上面类中的方法 --&gt;&lt;/bean&gt; 任意方法替换方式 123456789101112131415161718192021public class MyValueCalculator &#123; public String computeValue(String input) &#123; // some real code... &#125; // some other methods...&#125;/** * meant to be used to override the existing computeValue(String) * implementation in MyValueCalculator */public class ReplacementComputeValue implements MethodReplacer &#123; public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123; // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; &#125;&#125; 12345678&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt; &lt;!-- arbitrary method replacement --&gt; &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt; 作用域 模式 描述 singleton 单例模式 prototype 原型模式、多例模式 request 每一个http请求都会创建一个单例的bean，仅web应用 session 在session的生命周期中存在，仅web应用 application ServletContext生命周期中存在，仅web应用 websocket WebSocket生命周期存在，仅web应用 单例模式 原型模式 Request 域HTTP 请求级别的bean，根据请求创建任意数量的bean，而且他们完全相同，互不影响，请求完成即销毁。 1&lt;bean id="loginAction" class="com.foo.LoginAction" scope="request"/&gt; 12345@RequestScope@Componentpublic class LoginAction &#123; // ...&#125; Session 域HTTP Session 级别，根据Session创建任意数量的bean，完全相同，互不影响，Session 关闭即销毁。 1&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt; 12345@SessionScope@Componentpublic class UserPreferences &#123; // ...&#125; Application 域ServletContext 级别，bean 服务整个web应用，bean作为ServletContext的一个普通的属性。 1&lt;bean id="appPreferences" class="com.foo.AppPreferences" scope="application"/&gt; 12345@ApplicationScope@Componentpublic class AppPreferences &#123; // ...&#125; 域对象注入域对象代理方式注入，对象既可以完成域对象本身的工作，也被注入了更长生命周期的bean中。 1234567891011121314&lt;beans ...&gt; &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt; &lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"&gt; &lt;!-- instructs the container to proxy the surrounding bean --&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt; &lt;bean id="userService" class="com.foo.SimpleUserService"&gt; &lt;!-- a reference to the proxied userPreferences bean --&gt; &lt;property name="userPreferences" ref="userPreferences"/&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义域重写接口或使用其个性化配置配置方法。 1234567//实现接口并注入到容器中org.springframework.beans.factory.config.ScopeObject get(String name, ObjectFactory objectFactory)Object remove(String name)void registerDestructionCallback(String name, Runnable destructionCallback)String getConversationId()void registerScope(String scopeName, Scope scope); 配置 12Scope threadScope = new SimpleThreadScope();beanFactory.registerScope("thread", threadScope); 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt; &lt;property name="scopes"&gt; &lt;map&gt; &lt;entry key="thread"&gt; &lt;bean class="org.springframework.context.support.SimpleThreadScope"/&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="bar" class="x.y.Bar" scope="thread"&gt; &lt;property name="name" value="Rick"/&gt; &lt;aop:scoped-proxy/&gt; &lt;/bean&gt; &lt;bean id="foo" class="x.y.Foo"&gt; &lt;property name="bar" ref="bar"/&gt; &lt;/bean&gt;&lt;/beans&gt; 生命周期调用初始化调用在bean完成各种在容器中的属性设置后，允许执行一个初始化的方法。 1&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt; 上面的定义与下面完全相同。123456public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; 同时，可以采用实现InitializingBean接口的方式，重写方法调用初始化方法，择一实用1&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt; 123456public class AnotherExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 销毁调用1&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt; 123456public class ExampleBean &#123; public void cleanup() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 1&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt; 123456public class AnotherExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 默认全局使用方法可以在bean的配置标签上配置好需要使用的生命周期方法，在编写类时，只需要实现了对应的方法，就会自动执行生命周期方法。 123456789101112131415public class DefaultBlogService implements BlogService &#123; private BlogDao blogDao; public void setBlogDao(BlogDao blogDao) &#123; this.blogDao = blogDao; &#125; // this is (unsurprisingly) the initialization callback method public void init() &#123; if (this.blogDao == null) &#123; throw new IllegalStateException("The [blogDao] property must be set."); &#125; &#125;&#125; 1234567&lt;beans default-init-method="init"&gt; &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt; &lt;property name="blogDao" ref="blogDao" /&gt; &lt;/bean&gt;&lt;/beans&gt; 混合使用当然可以混合使用，混合接口实现，混合方法实现，混合注解，都阔以的，总结方法有三。 InitializingBean DisposableBean callback interfaces init() and destroy() methods @PostConstruct and @PreDestroy annotations 启动和关闭123456789public interface Lifecycle &#123; void start(); void stop(); boolean isRunning();&#125;//生命周期接口 Aware Name Injected Dependency Explained in… ApplicationContextAware Declaring ApplicationContext ApplicationContextAware and BeanNameAware ApplicationEventPublisherAware Event publisher of the enclosing ApplicationContext Additional capabilities of the ApplicationContext BeanClassLoaderAware Class loader used to load the bean classes. Instantiating beans BeanFactoryAware Declaring BeanFactory ApplicationContextAware and BeanNameAware BeanNameAware Name of the declaring bean ApplicationContextAware and BeanNameAware BootstrapContextAware Resource adapter BootstrapContext the container runs in. Typically available only in JCA aware ApplicationContexts JCA CCI LoadTimeWeaverAware Defined weaver for processing class definition at load time Load-time weaving with AspectJ in the Spring Framework MessageSourceAware Configured strategy for resolving messages (with support for parametrization and internationalization) Additional capabilities of the ApplicationContext NotificationPublisherAware Spring JMX notification publisher Notifications ResourceLoaderAware Configured loader for low-level access to resources Resources ServletConfigAware Current ServletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext Spring MVC ServletContextAware Current ServletContext the container runs in. Valid only in a web-aware Spring ApplicationContext Spring MVC 继承父子bean12345678910111213&lt;bean id="inheritedTestBean" abstract="true" class="org.springframework.beans.TestBean"&gt; &lt;property name="name" value="parent"/&gt; &lt;property name="age" value="1"/&gt;&lt;/bean&gt;&lt;!-- 模板模式 --&gt;&lt;bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean" parent="inheritedTestBean" init-method="initialize"&gt; &lt;property name="name" value="override"/&gt; &lt;!-- the age property value of 1 will be inherited from parent --&gt;&lt;/bean&gt; 注解@Required用于bean属性的setter方法，标注后在使用bean时必须给对应属性赋值，避免空指针异常。 @Autowired可以标注在构造器上，也可以标注在setter方法上，甚至是任意的包含多个入参的方法。 1234567891011public class MovieRecommender &#123; private final CustomerPreferenceDao customerPreferenceDao; @Autowired public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123; this.customerPreferenceDao = customerPreferenceDao; &#125; //标注构造&#125; 123456789101112131415public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // 任意方法及任意参数&#125; 1234567public class MovieRecommender &#123; @Autowired private MovieCatalog[] movieCatalogs; // 你将获得一个自动注入的 MovieCatalog[] 数组 集合同&#125; 12345678910public class MovieRecommender &#123; @Autowired private ApplicationContext context; public MovieRecommender() &#123; &#125; // 已经存在在容器中的Bean 当然可以自动注入啦 这是用到最多的情况了&#125; @Primary按类型自动装载时出现多个候选值时，可以使用这个注解来标注需要使用的bean。 12345678910111213@Configurationpublic class MovieConfiguration &#123; @Bean @Primary public MovieCatalog firstMovieCatalog() &#123; ... &#125; //装载 primary 的Bean @Bean public MovieCatalog secondMovieCatalog() &#123; ... &#125; &#125; 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:annotation-config/&gt; &lt;bean class="example.SimpleMovieCatalog" primary="true"&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;&lt;/beans&gt; @Qualifier当有多个相同类型的Bean时，可以通过这个注解进行区分，即可获得对应正确的Bean。 123456789101112131415161718192021222324public class MovieRecommender &#123; @Autowired @Qualifier("main") private MovieCatalog movieCatalog; // 当然有多实现的时候 就很美&#125;public class MovieRecommender &#123; private MovieCatalog movieCatalog; private CustomerPreferenceDao customerPreferenceDao; @Autowired public void prepare(@Qualifier("action")MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; // 根据标记装载对应的类&#125; 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans ...&gt; &lt;context:annotation-config/&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier value="main"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier value="action"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;&lt;/beans&gt; 下面不是重点 1234567@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Genre &#123; //自己搞个注解用 String value();&#125; 1234567891011121314151617&lt;beans ...&gt; &lt;context:annotation-config/&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier type="Genre" value="Action"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean class="example.SimpleMovieCatalog"&gt; &lt;qualifier type="example.Genre" value="Comedy"/&gt; &lt;!-- inject any dependencies required by this bean --&gt; &lt;/bean&gt; &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;&lt;/beans&gt; @Resource根据需要注入的类的名称进行查找然后进行类型查找最后注入 123456789public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; 123456789public class SimpleMovieLister &#123; private MovieFinder movieFinder; @Resource(name="myMovieFinder") public void setMovieFinder(MovieFinder movieFinder) &#123; this.movieFinder = movieFinder; &#125;&#125; // 这里自动装载的时名为 myMovieFinder 的实例 12345678910111213public class MovieRecommender &#123; @Resource private CustomerPreferenceDao customerPreferenceDao; @Resource private ApplicationContext context; public MovieRecommender() &#123; &#125; // context 查找的已知的 可使用的依赖进行注入 因为只有一个 ApplicationContext&#125; @PostConstruct 和 @PreDestroy注解后，这个类的实例化后，销毁前都会执行的对应的方法。 123456789101112public class CachingMovieLister &#123; @PostConstruct public void populateMovieCache() &#123; // populates the movie cache upon initialization... &#125; @PreDestroy public void clearMovieCache() &#123; // clears the movie cache upon destruction... &#125;&#125; @Component标记一个组件类，当然被扫描了会被容器管理起来，开发里的@Repository、@Service、@Controller专门的@Component。 元注解 12345678@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Component // Spring will see this and treat @Service in the same way as @Componentpublic @interface Service &#123; // 这个就是Service注解&#125; @Bean12345678910111213@Componentpublic class FactoryMethodComponent &#123; @Bean @Qualifier("public") public TestBean publicInstance() &#123; return new TestBean("publicInstance"); &#125; public void doWork() &#123; // Component method implementation omitted &#125;&#125; 这里很重要 划重点！ 123456789101112131415161718192021222324252627282930313233@Componentpublic class FactoryMethodComponent &#123; private static int i; @Bean @Qualifier("public") public TestBean publicInstance() &#123; return new TestBean("publicInstance"); &#125; // use of a custom qualifier and autowiring of method parameters @Bean protected TestBean protectedInstance( @Qualifier("public") TestBean spouse, @Value("#&#123;privateInstance.age&#125;") String country) &#123; TestBean tb = new TestBean("protectedInstance", 1); tb.setSpouse(spouse); tb.setCountry(country); return tb; &#125; @Bean private TestBean privateInstance() &#123; return new TestBean("privateInstance", i++); &#125; @Bean @RequestScope public TestBean requestScopedInstance() &#123; return new TestBean("requestScopedInstance", 3); &#125;&#125; 扫描注解1234567@Configuration@ComponentScan(basePackages = "org.example", includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"), excludeFilters = @Filter(Repository.class))public class AppConfig &#123; ...&#125; 12345678&lt;beans&gt; &lt;context:component-scan base-package="org.example"&gt; &lt;context:include-filter type="regex" expression=".*Stub.*Repository"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 组件起名123456789@Service("myMovieLister")public class SimpleMovieLister &#123; // 它就叫 myMovieLister&#125;@Repositorypublic class MovieFinderImpl implements MovieFinder &#123; // ... 他就叫 movieFinderImpl&#125; 这里下面就了解一下 我是不会用的我保证 12345@Configuration@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)public class AppConfig &#123; ...&#125; 1234&lt;beans&gt; &lt;context:component-scan base-package="org.example" name-generator="org.example.MyNameGenerator" /&gt;&lt;/beans&gt; 作用域还记得那些作用域吗？ 他们是加到bean上的，那么这些组件是不是bean，什么是bean？ 哈哈 自动忽略这段话吧 12345@Scope("prototype")@Repositorypublic class MovieFinderImpl implements MovieFinder &#123; // ...&#125; 自定义我就不写了。 带别名的！12345678910111213141516@Component@Qualifier("Action")public class ActionMovieCatalog implements MovieCatalog &#123; // ...&#125;@Component@Genre("Action")public class ActionMovieCatalog implements MovieCatalog &#123; // ...&#125;@Component@Offlinepublic class CachingMovieCatalog implements MovieCatalog &#123; // ...&#125;//这仨也在前面写过了 生成候选组件索引就是它会给你生成一个组件的索引，在用到的时候不会去扫描了，自动拿，我有索引，我要第B168号组件，谢谢。 123456789&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt; &lt;version&gt;5.0.9.RELEASE&lt;/version&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!-- 对 加个依赖完事了 --&gt; AspectJ基本概念基本概念先来了解一下吧。 Aspect：切面，跨越多个类的横切关注点，如事务管理器。 Join point：切点，程序执行过程中的一个点，如方法的执行或异常的处理，在Spring AOP中，连接点表示一个执行的方法 Advice：通知，在切面的一个切点上执行的方法。包括有”around”, “before” and “after” ，常被定义为一个拦截器 Introduction：声明方法或字段为一个类型。 Target object：目标对象，需要进行切面处理对象，当然它将是一个代理对象。 AOP proxy：代理处理对象，即完成切面编程的，我叫它AOP 代理，一般有两种，JDK 动态代理和CGLIB 代理 Waving：编织，也就是将声明的切面和原目标对象混合在一起，可以在任意时期完成（编、运）,spring时在运行时完成的。 通知类型： Before advice：连接点之前执行，但是不能阻止执行到达连接点，抛异常当然就过不去了。 After returing advice：切点方法正常结束的执行切点任务后执行。 After throwing advice：跑异常将会被执行。 After(finally) advice：切点方法结束后总是执行的方法 Around advice：环绕通知，方法前后都阔以，还可以通过返回值或跑异常来提前结束切面任务。 AOP 代理Spring AOP默认为AOP代理使用标准JDK动态代理。这允许代理任何接口(或一组接口)。Spring AOP还可以使用CGLIB代理。这对于代理类而不是接口是必要的。如果业务对象没有实现接口，则默认使用CGLIB。因为编写接口而不是类是很好的实践;业务类通常会实现一个或多个业务接口。有可能强制使用CGLIB，在那些(希望是罕见的)情况下，您需要通知没有在接口上声明的方法，或者需要将代理对象作为具体类型传递给方法。 开启功能很容易你就开启了aop面向切面编程 12345@Configuration@EnableAspectJAutoProxypublic class AppConfig &#123;&#125; 1&lt;aop:aspectj-autoproxy/&gt; 声明切面123&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 1234567package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect &#123;&#125; 声明切点来了解一些切点的表达式吧。 execution - for matching method execution join points, this is the primary pointcut designator you will use when working with Spring AOP within - limits matching to join points within certain types (simply the execution of a method declared within a matching type when using Spring AOP) this - limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type target - limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type args - limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types @target - limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type @args - limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given type(s) @within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP) @annotation - limits matching to join points where the subject of the join point (method being executed in Spring AOP) has the given annotation 当然不是这个。 execution ：方法匹配 within：将匹配限制在这些类型里 this：这个this内我加连接点 target：将会连接一个目标对象 args：参数是给定类型被连接 @args、@target、@within、@annotation 面向注解版本的匹配 12@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() &#123;&#125;// the pointcut signature 组合表达式，就是模糊匹配，通配符匹配。 1234567891011@Pointcut("execution(public * *(..))")private void anyPublicOperation() &#123;&#125;@Pointcut("within(com.xyz.someapp.trading..*)")private void inTrading() &#123;&#125;@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")private void tradingOperation() &#123;&#125;//anyPublicOperation //inTrading//tradingOperation 来看一个例子吧，只有五个方法，淡定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.xyz.someapp;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class SystemArchitecture &#123; /** * A join point is in the web layer if the method is defined * in a type in the com.xyz.someapp.web package or any sub-package * under that. */ @Pointcut("within(com.xyz.someapp.web..*)") public void inWebLayer() &#123;&#125; /** * A join point is in the service layer if the method is defined * in a type in the com.xyz.someapp.service package or any sub-package * under that. */ @Pointcut("within(com.xyz.someapp.service..*)") public void inServiceLayer() &#123;&#125; /** * A join point is in the data access layer if the method is defined * in a type in the com.xyz.someapp.dao package or any sub-package * under that. */ @Pointcut("within(com.xyz.someapp.dao..*)") public void inDataAccessLayer() &#123;&#125; /** * A business service is the execution of any method defined on a service * interface. This definition assumes that interfaces are placed in the * "service" package, and that implementation types are in sub-packages. * * If you group service interfaces by functional area (for example, * in packages com.xyz.someapp.abc.service and com.xyz.someapp.def.service) then * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))" * could be used instead. * * Alternatively, you can write the expression using the 'bean' * PCD, like so "bean(*Service)". (This assumes that you have * named your Spring service beans in a consistent fashion.) */ @Pointcut("execution(* com.xyz.someapp..service.*.*(..))") public void businessService() &#123;&#125; /** * A data access operation is the execution of any method defined on a * dao interface. This definition assumes that interfaces are placed in the * "dao" package, and that implementation types are in sub-packages. */ @Pointcut("execution(* com.xyz.someapp.dao.*.*(..))") public void dataAccessOperation() &#123;&#125;&#125; 1234567891011&lt;aop:config&gt; &lt;aop:advisor pointcut="com.xyz.someapp.SystemArchitecture.businessService()" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 声明通知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Aspectpublic class AdviceExample &#123; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @Before("execution(* com.xyz.myapp.dao.*.*(..))") public void doAccessCheck() &#123; // ... &#125; @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doAccessCheck() &#123; // ... &#125; @AfterReturning( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", returning="retVal") public void doAccessCheck(Object retVal) &#123; // ... &#125; @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doRecoveryActions() &#123; // ... &#125; @AfterThrowing( pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()", throwing="ex") public void doRecoveryActions(DataAccessException ex) &#123; // ... &#125; @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()") public void doReleaseLock() &#123; // ... &#125; @Around("com.xyz.myapp.SystemArchitecture.businessService()") public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal; &#125; @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)") public void validateAccount(Account account) &#123; // ... &#125;&#125; 是不是蒙圈了，我也蒙圈了，我特地找了个图，看图，是不是一下子又明白了！ 我们继续。 1234567@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)")private void accountDataAccessOperation(Account account) &#123;&#125;@Before("accountDataAccessOperation(account)")public void validateAccount(Account account) &#123; // ...&#125; 通知运行顺序 当有相同通知的时候，优先级高的先运行，方法都在用切面了，通知还有一万种类型，还要重的话，那它也没有说怎么用优先级，我也不会……不，优先级是通过向支持方面的bean添加Order注释或让bean实现有序接口来确定的。 引入方法这个例子是说，这个类将被作为一个接口被service下的类实现，所有service下的类都会实现我，被当做接口实现的。 1234567891011@Aspectpublic class UsageTracking &#123; @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 编程使用12345678910111213// create a factory that can generate a proxy for the given target objectAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);// add an aspect, the class must be an @AspectJ aspect// you can call this as many times as you need with different aspectsfactory.addAspect(SecurityManager.class);// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspectfactory.addAspect(usageTracker);// now get the proxy object...MyInterfaceType proxy = factory.getProxy();// 说的很详细了... AOP还原理还是和上面AspectJ一样，但是我们可以在xml里面来完成切面编程这个事情。 声明切面123456789&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aBean" class="..."&gt; ...&lt;/bean&gt; 声明切点1234567891011121314151617181920212223242526272829303132333435363738394041&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;&lt;/aop:config&gt;&lt;!-- aspectJ 书写方式 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;&lt;/aop:config&gt;&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!-- 子标签 --&gt;&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt; &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!-- 顺带把通知也写了 --&gt;&lt;aop:config&gt; &lt;aop:aspect id="myAspect" ref="aBean"&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service..(..)) and this(service)"/&gt; &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;!-- and or not --&gt; 声明通知说来说去通知建议，建议通知，这个就是，你在画了一个切点之后，这个切点到底要干什么，什么时候执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="beforeExample" ref="aBean"&gt; &lt;aop:before pointcut="execution(* com.xyz.myapp.dao.*.*(..))" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt; &lt;aop:after-returning pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt; &lt;aop:after-throwing pointcut-ref="dataAccessOperation" throwing="dataAccessEx" method="doRecoveryActions"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt; &lt;aop:after pointcut-ref="dataAccessOperation" method="doReleaseLock"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:aspect id="aroundExample" ref="aBean"&gt; &lt;aop:around pointcut-ref="businessService" method="doBasicProfiling"/&gt; ...&lt;/aop:aspect&gt;&lt;aop:before pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)" method="audit" arg-names="auditable"/&gt; 引入方法还记得上次那个类吗？ 对 被它拿去当借口给别人实现的。 12345678910111213&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt; &lt;aop:declare-parents types-matching="com.xzy.myapp.service.*+" implement-interface="com.xyz.myapp.service.tracking.UsageTracked" default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt; &lt;aop:before pointcut="com.xyz.myapp.SystemArchitecture.businessService() and this(usageTracked)" method="recordUsage"/&gt;&lt;/aop:aspect&gt; 顾问12345678910111213141516&lt;aop:config&gt; &lt;aop:pointcut id="businessService" expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt; &lt;aop:advisor pointcut-ref="businessService" advice-ref="tx-advice"/&gt;&lt;/aop:config&gt;&lt;tx:advice id="tx-advice"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*" propagation="REQUIRED"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 结束吧到这里为止吧，省略了一些没有写出来，整篇基本上是基于官方文档的翻译，在写的时候翻阅资料，发现官方的是最好的，后面还写了切面编程的原理部分，以及spring自己对于目录数据等的处理，这里也就不写了，有兴趣或者需要的话，回去翻文档，完整看过一次不至于找不到在哪了。 [官方文档]：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html]]></content>
      <categories>
        <category>Spring 教程</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
</search>
